import Foundation
import Testing

// MARK: - Regression Test Suite

/// Automated regression testing suite with known-good datasets preventing reoccurrence of fixed issues
/// Maintains repository of test datasets with Git LFS integration and GitHub issue tracking
public actor RegressionTestSuite {

    // MARK: - Core Types

    /// Known-good test dataset with versioned expected outcomes
    public struct KnownGoodDataset {
        public let id: String
        public let name: String
        public let description: String
        public let format: ImportFormat
        public let dataSize: Int64
        public let createdAt: Date
        public let lastValidatedAt: Date?
        public let dataURL: URL
        public let expectedOutcomeURL: URL
        public let metadata: DatasetMetadata
        public let validationRules: [ValidationRule]

        public init(
            id: String = UUID().uuidString,
            name: String,
            description: String,
            format: ImportFormat,
            dataSize: Int64,
            createdAt: Date = Date(),
            lastValidatedAt: Date? = nil,
            dataURL: URL,
            expectedOutcomeURL: URL,
            metadata: DatasetMetadata,
            validationRules: [ValidationRule]
        ) {
            self.id = id
            self.name = name
            self.description = description
            self.format = format
            self.dataSize = dataSize
            self.createdAt = createdAt
            self.lastValidatedAt = lastValidatedAt
            self.dataURL = dataURL
            self.expectedOutcomeURL = expectedOutcomeURL
            self.metadata = metadata
            self.validationRules = validationRules
        }

        /// Whether this dataset is stored in Git LFS
        public var isLFSManaged: Bool {
            dataSize > 1024 * 1024 // >1MB files use LFS
        }

        /// Age of the dataset in days
        public var ageInDays: Int {
            Calendar.current.dateComponents([.day], from: createdAt, to: Date()).day ?? 0
        }

        /// Whether the dataset needs revalidation
        public var needsRevalidation: Bool {
            guard let lastValidated = lastValidatedAt else { return true }
            let daysSinceValidation = Calendar.current.dateComponents([.day], from: lastValidated, to: Date()).day ?? 0
            return daysSinceValidation > 30 // Revalidate monthly
        }
    }

    /// Metadata about a test dataset
    public struct DatasetMetadata {
        public let source: DataSource
        public let complexity: ComplexityLevel
        public let tags: Set<String>
        public let associatedIssues: [GitHubIssue]
        public let associatedCommits: [String]
        public let anonymized: Bool
        public let specialCharacteristics: [String]

        public init(
            source: DataSource,
            complexity: ComplexityLevel,
            tags: Set<String> = [],
            associatedIssues: [GitHubIssue] = [],
            associatedCommits: [String] = [],
            anonymized: Bool = false,
            specialCharacteristics: [String] = []
        ) {
            self.source = source
            self.complexity = complexity
            self.tags = tags
            self.associatedIssues = associatedIssues
            self.associatedCommits = associatedCommits
            self.anonymized = anonymized
            self.specialCharacteristics = specialCharacteristics
        }
    }

    /// Source of test dataset
    public enum DataSource {
        case synthetic                  // Generated by test framework
        case productionAnonymized      // Anonymized production data
        case userSubmitted             // User-reported issue data
        case edgeCase                  // Manually crafted edge case
        case regression                // Dataset from previous bug
        case benchmark                 // Standard benchmark dataset

        public var description: String {
            switch self {
            case .synthetic: return "Synthetic test data"
            case .productionAnonymized: return "Anonymized production data"
            case .userSubmitted: return "User-submitted issue data"
            case .edgeCase: return "Manually crafted edge case"
            case .regression: return "Regression test data"
            case .benchmark: return "Standard benchmark dataset"
            }
        }
    }

    /// Complexity level of test dataset
    public enum ComplexityLevel {
        case simple      // Basic functionality test
        case moderate    // Normal usage patterns
        case complex     // Advanced features
        case stress      // Maximum limits
        case pathological // Edge cases that might break

        public var description: String {
            switch self {
            case .simple: return "Simple test case"
            case .moderate: return "Moderate complexity"
            case .complex: return "Complex data structure"
            case .stress: return "Stress test case"
            case .pathological: return "Pathological edge case"
            }
        }
    }

    /// Import format supported by test suite
    public enum ImportFormat: String, CaseIterable {
        case json = "json"
        case markdown = "markdown"
        case html = "html"
        case sqlite = "sqlite"
        case office = "office"
        case csv = "csv"

        public var extensions: [String] {
            switch self {
            case .json: return ["json"]
            case .markdown: return ["md", "markdown"]
            case .html: return ["html", "htm"]
            case .sqlite: return ["sqlite", "db", "sql"]
            case .office: return ["docx", "xlsx", "pptx"]
            case .csv: return ["csv"]
            }
        }
    }

    /// Validation rule for dataset testing
    public struct ValidationRule {
        public let name: String
        public let description: String
        public let rule: ValidationRuleType
        public let severity: Severity
        public let enabled: Bool

        public init(
            name: String,
            description: String,
            rule: ValidationRuleType,
            severity: Severity = .error,
            enabled: Bool = true
        ) {
            self.name = name
            self.description = description
            self.rule = rule
            self.severity = severity
            self.enabled = enabled
        }
    }

    /// Type of validation rule
    public enum ValidationRuleType {
        case exactNodeCount(Int)
        case minimumNodeCount(Int)
        case maximumNodeCount(Int)
        case requiredFields([String])
        case forbiddenPatterns([String])
        case customValidation((([Node]) async throws -> Bool))

        public var description: String {
            switch self {
            case .exactNodeCount(let count):
                return "Exact node count: \(count)"
            case .minimumNodeCount(let count):
                return "Minimum node count: \(count)"
            case .maximumNodeCount(let count):
                return "Maximum node count: \(count)"
            case .requiredFields(let fields):
                return "Required fields: \(fields.joined(separator: ", "))"
            case .forbiddenPatterns(let patterns):
                return "Forbidden patterns: \(patterns.joined(separator: ", "))"
            case .customValidation:
                return "Custom validation function"
            }
        }
    }

    /// Severity of validation rule
    public enum Severity {
        case error      // Test fails if rule violated
        case warning    // Test passes but warning issued
        case info       // Informational only

        public var symbol: String {
            switch self {
            case .error: return "âŒ"
            case .warning: return "âš ï¸"
            case .info: return "â„¹ï¸"
            }
        }
    }

    /// GitHub issue information
    public struct GitHubIssue {
        public let number: Int
        public let title: String
        public let url: String
        public let state: IssueState
        public let labels: [String]
        public let milestone: String?

        public init(
            number: Int,
            title: String,
            url: String,
            state: IssueState,
            labels: [String] = [],
            milestone: String? = nil
        ) {
            self.number = number
            self.title = title
            self.url = url
            self.state = state
            self.labels = labels
            self.milestone = milestone
        }
    }

    public enum IssueState: String {
        case open = "open"
        case closed = "closed"
    }

    /// Result of regression test execution
    public struct RegressionTestResult {
        public let dataset: KnownGoodDataset
        public let importer: String
        public let testId: String
        public let success: Bool
        public let executionTime: TimeInterval
        public let actualNodes: [Node]
        public let ruleViolations: [RuleViolation]
        public let comparisonResult: ComparisonResult?
        public let detectedRegression: Bool
        public let testedAt: Date

        public init(
            dataset: KnownGoodDataset,
            importer: String,
            testId: String = UUID().uuidString,
            success: Bool,
            executionTime: TimeInterval,
            actualNodes: [Node],
            ruleViolations: [RuleViolation] = [],
            comparisonResult: ComparisonResult? = nil,
            detectedRegression: Bool = false,
            testedAt: Date = Date()
        ) {
            self.dataset = dataset
            self.importer = importer
            self.testId = testId
            self.success = success
            self.executionTime = executionTime
            self.actualNodes = actualNodes
            self.ruleViolations = ruleViolations
            self.comparisonResult = comparisonResult
            self.detectedRegression = detectedRegression
            self.testedAt = testedAt
        }

        /// Whether this test indicates a potential regression
        public var indicatesRegression: Bool {
            detectedRegression || !ruleViolations.filter { $0.severity == .error }.isEmpty
        }
    }

    /// Violation of a validation rule
    public struct RuleViolation {
        public let rule: ValidationRule
        public let severity: Severity
        public let description: String
        public let actualValue: String?
        public let expectedValue: String?

        public init(
            rule: ValidationRule,
            severity: Severity,
            description: String,
            actualValue: String? = nil,
            expectedValue: String? = nil
        ) {
            self.rule = rule
            self.severity = severity
            self.description = description
            self.actualValue = actualValue
            self.expectedValue = expectedValue
        }
    }

    /// Comparison result between expected and actual outcomes
    public struct ComparisonResult {
        public let expectedNodes: [Node]
        public let actualNodes: [Node]
        public let matchPercentage: Double
        public let differences: [NodeDifference]
        public let summary: String

        public init(
            expectedNodes: [Node],
            actualNodes: [Node],
            matchPercentage: Double,
            differences: [NodeDifference],
            summary: String
        ) {
            self.expectedNodes = expectedNodes
            self.actualNodes = actualNodes
            self.matchPercentage = matchPercentage
            self.differences = differences
            self.summary = summary
        }
    }

    /// Difference between expected and actual nodes
    public struct NodeDifference {
        public let type: DifferenceType
        public let nodeId: String?
        public let field: String?
        public let expectedValue: String?
        public let actualValue: String?
        public let description: String

        public init(
            type: DifferenceType,
            nodeId: String? = nil,
            field: String? = nil,
            expectedValue: String? = nil,
            actualValue: String? = nil,
            description: String
        ) {
            self.type = type
            self.nodeId = nodeId
            self.field = field
            self.expectedValue = expectedValue
            self.actualValue = actualValue
            self.description = description
        }
    }

    public enum DifferenceType {
        case missingNode
        case extraNode
        case fieldMismatch
        case contentDifference
    }

    /// Repository for managing test datasets
    public protocol TestDataRepository {
        /// Store a new dataset
        func store(dataset: KnownGoodDataset, data: Data, expectedOutcome: Data) async throws

        /// Retrieve a dataset
        func retrieve(datasetId: String) async throws -> (dataset: KnownGoodDataset, data: Data, expectedOutcome: Data?)

        /// List all datasets matching criteria
        func listDatasets(format: ImportFormat?, complexity: ComplexityLevel?) async throws -> [KnownGoodDataset]

        /// Delete a dataset
        func delete(datasetId: String) async throws

        /// Update dataset metadata
        func updateMetadata(datasetId: String, metadata: DatasetMetadata) async throws
    }

    // MARK: - Dependencies

    private let testHarness: ImportTestHarness
    private let dataIntegrityValidator: DataIntegrityValidator
    private let testDataRepository: any TestDataRepository

    // MARK: - State

    private var knownDatasets: [String: KnownGoodDataset] = [:]
    private var testHistory: [RegressionTestResult] = []
    private var issueTracker: GitHubIssueTracker?

    public init(
        testHarness: ImportTestHarness,
        dataIntegrityValidator: DataIntegrityValidator,
        testDataRepository: any TestDataRepository
    ) {
        self.testHarness = testHarness
        self.dataIntegrityValidator = dataIntegrityValidator
        self.testDataRepository = testDataRepository
    }

    // MARK: - Public Methods

    /// Set up GitHub issue tracking integration
    public func setupIssueTracking(_ tracker: GitHubIssueTracker) {
        self.issueTracker = tracker
    }

    /// Add a new known-good dataset to the repository
    public func addKnownGoodDataset(
        name: String,
        description: String,
        format: ImportFormat,
        data: Data,
        expectedOutcome: Data,
        metadata: DatasetMetadata,
        validationRules: [ValidationRule] = []
    ) async throws -> KnownGoodDataset {
        let dataset = KnownGoodDataset(
            name: name,
            description: description,
            format: format,
            dataSize: Int64(data.count),
            dataURL: URL(fileURLWithPath: "/tmp/\(name)"), // Temporary, will be updated by repository
            expectedOutcomeURL: URL(fileURLWithPath: "/tmp/\(name)-expected"), // Temporary
            metadata: metadata,
            validationRules: validationRules
        )

        try await testDataRepository.store(dataset: dataset, data: data, expectedOutcome: expectedOutcome)
        knownDatasets[dataset.id] = dataset

        print("ðŸ“Š Added known-good dataset: \(name)")
        print("   Format: \(format.rawValue)")
        print("   Size: \(formatBytes(Int64(data.count)))")
        print("   Complexity: \(metadata.complexity.description)")

        return dataset
    }

    /// Run regression tests for a specific importer
    public func runRegressionTests<T: ImportTestHarness.ImporterProtocol>(
        importer: T,
        format: ImportFormat? = nil,
        complexity: ComplexityLevel? = nil
    ) async throws -> [RegressionTestResult] {
        print("ðŸ” Running regression tests for \(importer.importerName)")

        let datasets = try await testDataRepository.listDatasets(format: format, complexity: complexity)
        let filteredDatasets = datasets.filter { dataset in
            // Only test datasets compatible with this importer
            let supportedExtensions = Set(importer.supportedExtensions.map { $0.lowercased() })
            let datasetExtensions = Set(dataset.format.extensions)
            return !supportedExtensions.isDisjoint(with: datasetExtensions)
        }

        print("   Testing \(filteredDatasets.count) datasets")

        var results: [RegressionTestResult] = []

        for (index, dataset) in filteredDatasets.enumerated() {
            do {
                let result = try await runSingleRegressionTest(importer: importer, dataset: dataset)
                results.append(result)

                if result.indicatesRegression {
                    print("   âš ï¸ Regression detected in dataset: \(dataset.name)")

                    // Notify issue tracker if available
                    if let issueTracker = issueTracker {
                        try await reportRegressionToGitHub(
                            issueTracker: issueTracker,
                            result: result
                        )
                    }
                }

                if (index + 1) % 10 == 0 {
                    print("   Progress: \(index + 1)/\(filteredDatasets.count) tests completed")
                }

            } catch {
                print("   âŒ Test failed for dataset \(dataset.name): \(error)")

                // Create failure result
                let failureResult = RegressionTestResult(
                    dataset: dataset,
                    importer: importer.importerName,
                    success: false,
                    executionTime: 0,
                    actualNodes: [],
                    detectedRegression: true
                )
                results.append(failureResult)
            }
        }

        // Store results in history
        testHistory.append(contentsOf: results)

        // Generate summary
        let successCount = results.filter { $0.success }.count
        let regressionCount = results.filter { $0.indicatesRegression }.count

        print("âœ… Regression test completed for \(importer.importerName)")
        print("   Total tests: \(results.count)")
        print("   Successful: \(successCount)")
        print("   Regressions detected: \(regressionCount)")

        return results
    }

    /// Run regression test for all importers
    public func runAllRegressionTests(
        importers: [any ImportTestHarness.ImporterProtocol]
    ) async throws -> [String: [RegressionTestResult]] {
        print("ðŸ” Running comprehensive regression test suite")
        print("   Importers: \(importers.count)")

        var allResults: [String: [RegressionTestResult]] = [:]

        for importer in importers {
            let results = try await runRegressionTests(importer: importer)
            allResults[importer.importerName] = results
        }

        // Generate comprehensive summary
        let totalTests = allResults.values.flatMap { $0 }.count
        let totalRegressions = allResults.values.flatMap { $0 }.filter { $0.indicatesRegression }.count

        print("âœ… Comprehensive regression test suite completed")
        print("   Total tests across all importers: \(totalTests)")
        print("   Total regressions detected: \(totalRegressions)")

        if totalRegressions == 0 {
            print("   ðŸŽ‰ No regressions detected!")
        } else {
            print("   ðŸš¨ \(totalRegressions) regressions require attention")
        }

        return allResults
    }

    /// Add test case from a fixed bug
    public func addRegressionTestFromBug(
        issueNumber: Int,
        bugData: Data,
        fixedExpectedOutcome: Data,
        format: ImportFormat,
        description: String
    ) async throws -> KnownGoodDataset {
        let issue = GitHubIssue(
            number: issueNumber,
            title: "Regression test for issue #\(issueNumber)",
            url: "https://github.com/mshaler/isometry/issues/\(issueNumber)",
            state: .closed
        )

        let metadata = DatasetMetadata(
            source: .regression,
            complexity: .pathological, // Bug cases are typically pathological
            tags: ["regression", "bug-fix"],
            associatedIssues: [issue],
            specialCharacteristics: ["Previously caused bug #\(issueNumber)"]
        )

        let validationRules: [ValidationRule] = [
            ValidationRule(
                name: "No regression for issue #\(issueNumber)",
                description: "Ensure this data doesn't cause the same bug again",
                rule: .customValidation({ nodes in
                    // Custom validation can be added here
                    return !nodes.isEmpty
                })
            )
        ]

        return try await addKnownGoodDataset(
            name: "regression-issue-\(issueNumber)",
            description: "Regression test for \(description)",
            format: format,
            data: bugData,
            expectedOutcome: fixedExpectedOutcome,
            metadata: metadata,
            validationRules: validationRules
        )
    }

    /// Get regression test statistics
    public func getRegressionStatistics() -> RegressionStatistics {
        let totalTests = testHistory.count
        let recentTests = testHistory.filter { $0.testedAt > Calendar.current.date(byAdding: .day, value: -7, to: Date())! }
        let successfulTests = testHistory.filter { $0.success }.count
        let regressionsDetected = testHistory.filter { $0.indicatesRegression }.count

        let avgExecutionTime = totalTests > 0 ?
            testHistory.map { $0.executionTime }.reduce(0, +) / Double(totalTests) : 0

        return RegressionStatistics(
            totalTests: totalTests,
            recentTests: recentTests.count,
            successRate: totalTests > 0 ? Double(successfulTests) / Double(totalTests) : 0,
            regressionRate: totalTests > 0 ? Double(regressionsDetected) / Double(totalTests) : 0,
            averageExecutionTime: avgExecutionTime,
            datasetsAvailable: knownDatasets.count,
            lastRunAt: testHistory.last?.testedAt
        )
    }

    // MARK: - Private Implementation

    private func runSingleRegressionTest<T: ImportTestHarness.ImporterProtocol>(
        importer: T,
        dataset: KnownGoodDataset
    ) async throws -> RegressionTestResult {
        let startTime = Date()

        // Retrieve dataset and expected outcome
        let (_, data, expectedOutcome) = try await testDataRepository.retrieve(datasetId: dataset.id)

        // Set up isolated database for testing
        let isolatedDb = try IsometryDatabase(path: ":memory:")
        try await isolatedDb.initialize()

        // Import the test data
        let importResult = try await importer.importData(data, filename: "regression-test", folder: "test")
        let actualNodes = try await isolatedDb.getAllNodes()

        // Validate against expected outcome if available
        var comparisonResult: ComparisonResult?
        if let expectedOutcome = expectedOutcome {
            comparisonResult = try await compareWithExpectedOutcome(
                actualNodes: actualNodes,
                expectedOutcome: expectedOutcome
            )
        }

        // Check validation rules
        let ruleViolations = try await validateAgainstRules(
            nodes: actualNodes,
            rules: dataset.validationRules
        )

        // Detect regression
        let detectedRegression = detectRegression(
            dataset: dataset,
            actualNodes: actualNodes,
            comparisonResult: comparisonResult,
            ruleViolations: ruleViolations
        )

        let executionTime = Date().timeIntervalSince(startTime)
        let success = importResult.imported > 0 && ruleViolations.filter { $0.severity == .error }.isEmpty

        return RegressionTestResult(
            dataset: dataset,
            importer: importer.importerName,
            success: success,
            executionTime: executionTime,
            actualNodes: actualNodes,
            ruleViolations: ruleViolations,
            comparisonResult: comparisonResult,
            detectedRegression: detectedRegression
        )
    }

    private func compareWithExpectedOutcome(
        actualNodes: [Node],
        expectedOutcome: Data
    ) async throws -> ComparisonResult {
        // Parse expected outcome (assuming JSON format for expected nodes)
        let decoder = JSONDecoder()
        let expectedNodes = try decoder.decode([Node].self, from: expectedOutcome)

        // Calculate match percentage
        let actualNodeMap = Dictionary(uniqueKeysWithValues: actualNodes.map { ($0.id, $0) })
        let expectedNodeMap = Dictionary(uniqueKeysWithValues: expectedNodes.map { ($0.id, $0) })

        var differences: [NodeDifference] = []
        var matchingNodes = 0

        // Check for missing nodes
        for expectedNode in expectedNodes {
            if let actualNode = actualNodeMap[expectedNode.id] {
                // Node exists, check for differences
                if expectedNode.name != actualNode.name {
                    differences.append(NodeDifference(
                        type: .fieldMismatch,
                        nodeId: expectedNode.id,
                        field: "name",
                        expectedValue: expectedNode.name,
                        actualValue: actualNode.name,
                        description: "Node name mismatch"
                    ))
                }

                if expectedNode.content != actualNode.content {
                    differences.append(NodeDifference(
                        type: .contentDifference,
                        nodeId: expectedNode.id,
                        field: "content",
                        expectedValue: expectedNode.content,
                        actualValue: actualNode.content,
                        description: "Node content differs"
                    ))
                }

                if differences.filter({ $0.nodeId == expectedNode.id }).isEmpty {
                    matchingNodes += 1
                }
            } else {
                differences.append(NodeDifference(
                    type: .missingNode,
                    nodeId: expectedNode.id,
                    description: "Expected node is missing"
                ))
            }
        }

        // Check for extra nodes
        for actualNode in actualNodes {
            if expectedNodeMap[actualNode.id] == nil {
                differences.append(NodeDifference(
                    type: .extraNode,
                    nodeId: actualNode.id,
                    description: "Unexpected extra node"
                ))
            }
        }

        let totalExpected = expectedNodes.count
        let matchPercentage = totalExpected > 0 ? Double(matchingNodes) / Double(totalExpected) : 1.0

        let summary = """
        Node comparison results:
        Expected nodes: \(expectedNodes.count)
        Actual nodes: \(actualNodes.count)
        Matching nodes: \(matchingNodes)
        Match percentage: \(String(format: "%.1f", matchPercentage * 100))%
        Differences found: \(differences.count)
        """

        return ComparisonResult(
            expectedNodes: expectedNodes,
            actualNodes: actualNodes,
            matchPercentage: matchPercentage,
            differences: differences,
            summary: summary
        )
    }

    private func validateAgainstRules(
        nodes: [Node],
        rules: [ValidationRule]
    ) async throws -> [RuleViolation] {
        var violations: [RuleViolation] = []

        for rule in rules where rule.enabled {
            switch rule.rule {
            case .exactNodeCount(let expectedCount):
                if nodes.count != expectedCount {
                    violations.append(RuleViolation(
                        rule: rule,
                        severity: rule.severity,
                        description: "Node count mismatch",
                        actualValue: "\(nodes.count)",
                        expectedValue: "\(expectedCount)"
                    ))
                }

            case .minimumNodeCount(let minCount):
                if nodes.count < minCount {
                    violations.append(RuleViolation(
                        rule: rule,
                        severity: rule.severity,
                        description: "Node count below minimum",
                        actualValue: "\(nodes.count)",
                        expectedValue: "â‰¥\(minCount)"
                    ))
                }

            case .maximumNodeCount(let maxCount):
                if nodes.count > maxCount {
                    violations.append(RuleViolation(
                        rule: rule,
                        severity: rule.severity,
                        description: "Node count exceeds maximum",
                        actualValue: "\(nodes.count)",
                        expectedValue: "â‰¤\(maxCount)"
                    ))
                }

            case .requiredFields(let fields):
                for field in fields {
                    let nodesWithField = nodes.filter { node in
                        switch field {
                        case "id": return !node.id.isEmpty
                        case "name": return !node.name.isEmpty
                        case "content": return node.content != nil && !node.content!.isEmpty
                        case "folder": return node.folder != nil
                        default: return false
                        }
                    }

                    if nodesWithField.count < nodes.count {
                        violations.append(RuleViolation(
                            rule: rule,
                            severity: rule.severity,
                            description: "Missing required field: \(field)",
                            actualValue: "\(nodesWithField.count)/\(nodes.count) nodes",
                            expectedValue: "All nodes"
                        ))
                    }
                }

            case .forbiddenPatterns(let patterns):
                for pattern in patterns {
                    let nodesWithPattern = nodes.filter { node in
                        node.name.contains(pattern) ||
                        node.content?.contains(pattern) == true ||
                        node.folder?.contains(pattern) == true
                    }

                    if !nodesWithPattern.isEmpty {
                        violations.append(RuleViolation(
                            rule: rule,
                            severity: rule.severity,
                            description: "Forbidden pattern found: \(pattern)",
                            actualValue: "\(nodesWithPattern.count) nodes",
                            expectedValue: "0 nodes"
                        ))
                    }
                }

            case .customValidation(let validation):
                let isValid = try await validation(nodes)
                if !isValid {
                    violations.append(RuleViolation(
                        rule: rule,
                        severity: rule.severity,
                        description: "Custom validation failed"
                    ))
                }
            }
        }

        return violations
    }

    private func detectRegression(
        dataset: KnownGoodDataset,
        actualNodes: [Node],
        comparisonResult: ComparisonResult?,
        ruleViolations: [RuleViolation]
    ) -> Bool {
        // Check for rule violations that are errors
        let errorViolations = ruleViolations.filter { $0.severity == .error }
        if !errorViolations.isEmpty {
            return true
        }

        // Check comparison result if available
        if let comparison = comparisonResult {
            // Consider <90% match as regression
            if comparison.matchPercentage < 0.9 {
                return true
            }

            // Check for critical differences
            let criticalDifferences = comparison.differences.filter { diff in
                diff.type == .missingNode || diff.type == .contentDifference
            }
            if criticalDifferences.count > comparison.expectedNodes.count / 10 { // >10% critical differences
                return true
            }
        }

        return false
    }

    private func reportRegressionToGitHub(
        issueTracker: GitHubIssueTracker,
        result: RegressionTestResult
    ) async throws {
        let title = "Regression detected in \(result.importer) with dataset \(result.dataset.name)"

        var body = """
        ## Regression Test Failure

        **Importer:** \(result.importer)
        **Dataset:** \(result.dataset.name)
        **Test ID:** \(result.testId)

        ### Dataset Information
        - **Format:** \(result.dataset.format.rawValue)
        - **Size:** \(formatBytes(result.dataset.dataSize))
        - **Complexity:** \(result.dataset.metadata.complexity.description)
        - **Source:** \(result.dataset.metadata.source.description)

        ### Failure Details
        """

        if !result.ruleViolations.isEmpty {
            body += "\n#### Rule Violations\n"
            for violation in result.ruleViolations {
                body += "- \(violation.severity.symbol) **\(violation.rule.name):** \(violation.description)\n"
                if let expected = violation.expectedValue, let actual = violation.actualValue {
                    body += "  - Expected: \(expected)\n"
                    body += "  - Actual: \(actual)\n"
                }
            }
        }

        if let comparison = result.comparisonResult {
            body += "\n#### Comparison Results\n"
            body += "- **Match percentage:** \(String(format: "%.1f", comparison.matchPercentage * 100))%\n"
            body += "- **Differences found:** \(comparison.differences.count)\n"

            if !comparison.differences.isEmpty {
                body += "\n##### Key Differences\n"
                for diff in comparison.differences.prefix(5) {
                    body += "- \(diff.type): \(diff.description)\n"
                }
            }
        }

        body += "\n### Associated Issues\n"
        for issue in result.dataset.metadata.associatedIssues {
            body += "- #\(issue.number): \(issue.title)\n"
        }

        try await issueTracker.createIssue(
            title: title,
            body: body,
            labels: ["regression", "testing", "bug"]
        )
    }

    private func formatBytes(_ bytes: Int64) -> String {
        let formatter = ByteCountFormatter()
        formatter.allowedUnits = [.useKB, .useMB, .useGB]
        formatter.countStyle = .file
        return formatter.string(fromByteCount: bytes)
    }
}

// MARK: - Support Types

/// Statistics about regression testing
public struct RegressionStatistics {
    public let totalTests: Int
    public let recentTests: Int
    public let successRate: Double
    public let regressionRate: Double
    public let averageExecutionTime: TimeInterval
    public let datasetsAvailable: Int
    public let lastRunAt: Date?

    public var summary: String {
        """
        Regression Test Statistics

        Total Tests Run: \(totalTests)
        Recent Tests (7 days): \(recentTests)
        Success Rate: \(String(format: "%.1f", successRate * 100))%
        Regression Rate: \(String(format: "%.1f", regressionRate * 100))%
        Average Execution Time: \(String(format: "%.2f", averageExecutionTime))s
        Datasets Available: \(datasetsAvailable)
        Last Run: \(lastRunAt?.formatted() ?? "Never")
        """
    }
}

/// GitHub issue tracker integration
public protocol GitHubIssueTracker {
    func createIssue(title: String, body: String, labels: [String]) async throws
    func updateIssue(number: Int, title: String?, body: String?, state: RegressionTestSuite.IssueState?) async throws
    func getIssue(number: Int) async throws -> RegressionTestSuite.GitHubIssue
    func listIssues(labels: [String]?) async throws -> [RegressionTestSuite.GitHubIssue]
}

// MARK: - File System Test Data Repository

/// File system-based test data repository with Git LFS support
public actor FileSystemTestDataRepository: RegressionTestSuite.TestDataRepository {
    private let baseURL: URL
    private let lfsThreshold: Int64 = 1024 * 1024 // 1MB

    public init(baseURL: URL) throws {
        self.baseURL = baseURL
        try FileManager.default.createDirectory(at: baseURL, withIntermediateDirectories: true, attributes: nil)
    }

    public func store(dataset: RegressionTestSuite.KnownGoodDataset, data: Data, expectedOutcome: Data) async throws {
        let datasetDir = baseURL.appendingPathComponent(dataset.id)
        try FileManager.default.createDirectory(at: datasetDir, withIntermediateDirectories: true, attributes: nil)

        // Store dataset metadata
        let metadataURL = datasetDir.appendingPathComponent("metadata.json")
        let encoder = JSONEncoder()
        encoder.outputFormatting = .prettyPrinted
        let metadataData = try encoder.encode(dataset)
        try metadataData.write(to: metadataURL)

        // Store data file
        let dataURL = datasetDir.appendingPathComponent("data.\(dataset.format.extensions.first!)")
        try data.write(to: dataURL)

        // Store expected outcome
        let expectedURL = datasetDir.appendingPathComponent("expected.json")
        try expectedOutcome.write(to: expectedURL)

        // Add Git LFS tracking if file is large
        if data.count > lfsThreshold {
            try await addGitLFSTracking(for: dataURL)
        }
    }

    public func retrieve(datasetId: String) async throws -> (dataset: RegressionTestSuite.KnownGoodDataset, data: Data, expectedOutcome: Data?) {
        let datasetDir = baseURL.appendingPathComponent(datasetId)

        // Load metadata
        let metadataURL = datasetDir.appendingPathComponent("metadata.json")
        let metadataData = try Data(contentsOf: metadataURL)
        let decoder = JSONDecoder()
        let dataset = try decoder.decode(RegressionTestSuite.KnownGoodDataset.self, from: metadataData)

        // Load data
        let dataFiles = try FileManager.default.contentsOfDirectory(at: datasetDir, includingPropertiesForKeys: nil)
        guard let dataFile = dataFiles.first(where: { $0.lastPathComponent.hasPrefix("data.") }) else {
            throw RepositoryError.dataFileNotFound(datasetId)
        }
        let data = try Data(contentsOf: dataFile)

        // Load expected outcome if exists
        let expectedURL = datasetDir.appendingPathComponent("expected.json")
        let expectedOutcome = try? Data(contentsOf: expectedURL)

        return (dataset: dataset, data: data, expectedOutcome: expectedOutcome)
    }

    public func listDatasets(
        format: RegressionTestSuite.ImportFormat?,
        complexity: RegressionTestSuite.ComplexityLevel?
    ) async throws -> [RegressionTestSuite.KnownGoodDataset] {
        let contents = try FileManager.default.contentsOfDirectory(
            at: baseURL,
            includingPropertiesForKeys: [.isDirectoryKey],
            options: .skipsHiddenFiles
        )

        var datasets: [RegressionTestSuite.KnownGoodDataset] = []

        for item in contents {
            var isDirectory: ObjCBool = false
            if FileManager.default.fileExists(atPath: item.path, isDirectory: &isDirectory) && isDirectory.boolValue {
                do {
                    let metadataURL = item.appendingPathComponent("metadata.json")
                    let metadataData = try Data(contentsOf: metadataURL)
                    let decoder = JSONDecoder()
                    let dataset = try decoder.decode(RegressionTestSuite.KnownGoodDataset.self, from: metadataData)

                    // Apply filters
                    if let format = format, dataset.format != format { continue }
                    if let complexity = complexity, dataset.metadata.complexity != complexity { continue }

                    datasets.append(dataset)
                } catch {
                    // Skip invalid datasets
                    continue
                }
            }
        }

        return datasets.sorted { $0.createdAt > $1.createdAt }
    }

    public func delete(datasetId: String) async throws {
        let datasetDir = baseURL.appendingPathComponent(datasetId)
        try FileManager.default.removeItem(at: datasetDir)
    }

    public func updateMetadata(datasetId: String, metadata: RegressionTestSuite.DatasetMetadata) async throws {
        let (dataset, _, _) = try await retrieve(datasetId: datasetId)
        var dataset = dataset
        dataset = RegressionTestSuite.KnownGoodDataset(
            id: dataset.id,
            name: dataset.name,
            description: dataset.description,
            format: dataset.format,
            dataSize: dataset.dataSize,
            createdAt: dataset.createdAt,
            lastValidatedAt: dataset.lastValidatedAt,
            dataURL: dataset.dataURL,
            expectedOutcomeURL: dataset.expectedOutcomeURL,
            metadata: metadata,
            validationRules: dataset.validationRules
        )

        let datasetDir = baseURL.appendingPathComponent(datasetId)
        let metadataURL = datasetDir.appendingPathComponent("metadata.json")
        let encoder = JSONEncoder()
        encoder.outputFormatting = .prettyPrinted
        let metadataData = try encoder.encode(dataset)
        try metadataData.write(to: metadataURL)
    }

    private func addGitLFSTracking(for fileURL: URL) async throws {
        // This would integrate with Git LFS to track large files
        // For now, just log that LFS tracking would be added
        print("ðŸ“¦ Would add Git LFS tracking for: \(fileURL.lastPathComponent)")
    }
}

public enum RepositoryError: Error, LocalizedError {
    case dataFileNotFound(String)
    case invalidDataset(String)
    case storageError(String)

    public var errorDescription: String? {
        switch self {
        case .dataFileNotFound(let id):
            return "Data file not found for dataset: \(id)"
        case .invalidDataset(let id):
            return "Invalid dataset format: \(id)"
        case .storageError(let message):
            return "Storage error: \(message)"
        }
    }
}