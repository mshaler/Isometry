---
phase: 16-realtime-visualizations
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [
  src/components/performance/RealTimeRenderer.tsx,
  src/hooks/useCanvasPerformance.ts,
  src/utils/d3-optimization.ts,
  src/components/Canvas.tsx,
  scripts/performance-benchmark.js
]
autonomous: true

must_haves:
  truths:
    - "Visualizations maintain 60fps during live updates"
    - "Canvas component monitors render performance in real-time"
    - "Large datasets (6,891+ nodes) render smoothly"
    - "Memory usage stays stable during continuous updates"
    - "Performance degradation triggers automatic optimization"
  artifacts:
    - path: "src/components/performance/RealTimeRenderer.tsx"
      provides: "High-performance D3 rendering wrapper"
      exports: ["RealTimeRenderer"]
      min_lines: 200
    - path: "src/hooks/useCanvasPerformance.ts"
      provides: "Canvas-level performance monitoring"
      exports: ["useCanvasPerformance"]
      min_lines: 150
    - path: "src/utils/d3-optimization.ts"
      provides: "D3 rendering optimization utilities"
      exports: ["optimizeForLargeDatasets", "enableVirtualScrolling"]
      min_lines: 120
  key_links:
    - from: "src/components/performance/RealTimeRenderer.tsx"
      to: "requestAnimationFrame"
      via: "frame scheduling"
      pattern: "requestAnimationFrame.*render"
    - from: "src/hooks/useCanvasPerformance.ts"
      to: "performance.now"
      via: "timing measurement"
      pattern: "performance\\.now.*fps"
---

<objective>
Build real-time performance engine for D3 visualizations to ensure 60fps rendering during live data updates with large datasets.

Purpose: Create robust performance infrastructure that monitors, optimizes, and maintains smooth rendering for complex visualizations while handling the full 6,891 Apple Notes dataset with real-time updates.
Output: Performance-optimized rendering system ready for production deployment
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@src/hooks/useLiveData.tsx
@src/components/DataFlowMonitor.tsx
@src/components/Canvas.tsx
@src/components/views/NetworkView.tsx
@src/hooks/useD3.ts
</context>

<tasks>

<task type="auto">
  <name>Create Real-Time Rendering Engine</name>
  <files>src/components/performance/RealTimeRenderer.tsx</files>
  <action>
    Build high-performance wrapper for D3 visualizations with real-time capabilities:

    RealTimeRenderer features:
    - requestAnimationFrame-based rendering loop for smooth 60fps
    - Intelligent batching of D3 updates to prevent frame drops
    - Automatic LOD (Level of Detail) adjustments for large datasets
    - Memory-efficient rendering with object pooling for D3 elements
    - Progressive rendering for datasets >1000 nodes (render in chunks)
    - Frame timing analysis with automatic quality adjustment
    - Integration with live data subscriptions for optimized updates

    Component interface:
    ```typescript
    interface RealTimeRendererProps {
      children: React.ReactNode;
      maxNodes?: number; // Default: 10000
      targetFps?: number; // Default: 60
      enableLOD?: boolean; // Default: true
      onPerformanceChange?: (metrics: PerformanceMetrics) => void;
    }
    ```

    Key optimizations:
    - Use D3's data joins efficiently to minimize DOM manipulation
    - Implement viewport culling for off-screen elements
    - Cache computed layouts and reuse when data hasn't changed
    - Debounce expensive operations like force simulations
  </action>
  <verify>Component renders complex visualizations at 60fps, no frame drops during updates</verify>
  <done>RealTimeRenderer optimizes D3 performance with frame rate monitoring</done>
</task>

<task type="auto">
  <name>Build Canvas Performance Monitoring</name>
  <files>src/hooks/useCanvasPerformance.ts, src/components/Canvas.tsx</files>
  <action>
    Create comprehensive performance monitoring for the Canvas component:

    useCanvasPerformance hook:
    - Real-time FPS monitoring with rolling averages
    - Render time tracking per visualization type
    - Memory usage monitoring (heap size, DOM nodes)
    - Data throughput measurement (nodes/second processed)
    - Automatic performance profiling with bottleneck identification
    - Integration with browser performance APIs
    - Performance score calculation (0-100) based on multiple metrics

    Canvas.tsx integration:
    - Add performance monitoring overlay (development mode)
    - Automatic performance warnings when FPS drops below 45
    - Quality adjustment controls (High/Medium/Low performance modes)
    - Integration with existing DataFlowMonitor
    - Performance-based rendering strategy selection

    Monitoring metrics:
    ```typescript
    interface CanvasPerformanceMetrics {
      fps: number;
      renderTime: number;
      memoryUsage: number;
      nodeCount: number;
      performanceScore: number;
      bottlenecks: string[];
    }
    ```
  </action>
  <verify>Canvas shows performance metrics, automatically adjusts quality when needed</verify>
  <done>useCanvasPerformance provides real-time performance tracking for Canvas</done>
</task>

<task type="auto">
  <name>Create D3 Optimization Utilities and Benchmarks</name>
  <files>src/utils/d3-optimization.ts, scripts/performance-benchmark.js</files>
  <action>
    Build optimization utilities and performance benchmarking:

    d3-optimization.ts utilities:
    - optimizeForLargeDatasets: Dynamic LOD, viewport culling, progressive loading
    - enableVirtualScrolling: Efficient rendering for large lists/grids
    - batchD3Updates: Intelligent batching of DOM operations
    - createPerformantSimulation: Optimized force simulation settings
    - debounceDataUpdates: Prevent excessive re-renders during rapid changes
    - memoryPooling: Reuse D3 elements to reduce garbage collection

    Implementation:
    ```typescript
    export function optimizeForLargeDatasets(
      selection: d3.Selection,
      dataSize: number,
      viewport: { width: number; height: number }
    ): OptimizedRenderer

    export function enableVirtualScrolling<T>(
      container: d3.Selection,
      data: T[],
      itemHeight: number
    ): VirtualScrollRenderer<T>
    ```

    performance-benchmark.js:
    - Automated stress testing with varying dataset sizes
    - Render performance measurement across different view types
    - Memory leak detection during continuous updates
    - FPS stability testing over extended periods
    - Comparison testing against performance targets
    - Report generation with actionable recommendations
  </action>
  <verify>Utilities improve performance with large datasets, benchmark script runs successfully</verify>
  <done>D3 optimization utilities ready and performance benchmarks created</done>
</task>

</tasks>

<verification>
- RealTimeRenderer maintains 60fps with 6,891+ nodes
- Canvas performance monitoring shows accurate real-time metrics
- D3 optimization utilities improve rendering with large datasets
- Performance benchmark validates 60fps targets are met
- Memory usage remains stable during continuous live updates
</verification>

<success_criteria>
- Visualizations render smoothly at 60fps even with full Apple Notes dataset
- Performance monitoring provides actionable insights and automatic adjustments
- Optimization utilities handle edge cases and prevent performance degradation
- Benchmarks validate performance targets under stress conditions
- Canvas component automatically adapts quality based on performance
</success_criteria>

<output>
After completion, create `.planning/phases/16-realtime-visualizations/16-02-SUMMARY.md`
</output>