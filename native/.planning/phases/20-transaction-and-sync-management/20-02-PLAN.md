---
phase: 20-transaction-and-sync-management
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [
  "Sources/Isometry/Sync/ConflictResolutionManager.swift",
  "Sources/Isometry/Sync/CRDTNode.swift",
  "Sources/Isometry/Sync/ConflictResolver.swift",
  "Sources/Isometry/Database/schema.sql",
  "src/hooks/useConflictResolution.ts",
  "src/contexts/ConflictResolutionContext.tsx"
]
autonomous: true

must_haves:
  truths:
    - "Conflicts from simultaneous editing on multiple devices resolve with user control"
    - "Multi-device conflict resolution works without central coordination"
    - "Conflict resolution preserves data integrity during simultaneous edits"
    - "Users receive notification when conflicts occur with resolution options"
  artifacts:
    - path: "Sources/Isometry/Sync/ConflictResolutionManager.swift"
      provides: "CRDT-based conflict resolution with device coordination"
      exports: ["resolveConflicts", "detectConflicts", "mergeChanges"]
    - path: "Sources/Isometry/Sync/CRDTNode.swift"
      provides: "CRDT metadata for conflict-free replication"
      contains: "struct CRDTNode.*Codable"
    - path: "src/contexts/ConflictResolutionContext.tsx"
      provides: "React conflict resolution UI state management"
      exports: ["ConflictResolutionProvider", "useConflictResolution"]
  key_links:
    - from: "Sources/Isometry/Sync/ConflictResolutionManager.swift"
      to: "Sources/Isometry/Database/IsometryDatabase"
      via: "CRDT metadata queries and conflict detection"
      pattern: "dbVersion.*columnVersion.*conflict"
    - from: "src/contexts/ConflictResolutionContext.tsx"
      to: "Sources/Isometry/Sync/ConflictResolutionManager.swift"
      via: "Bridge messages for conflict resolution"
      pattern: "resolveConflict.*bridge"
---

<objective>
Implement CRDT-based conflict resolution framework for multi-device editing scenarios with automated conflict detection and user-controlled resolution options.

Purpose: Enable robust multi-device collaboration with conflict-free data replication and user-friendly conflict resolution when automatic merge fails.
Output: Complete conflict resolution system with CRDT support and React UI for conflict management.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/20-transaction-and-sync-management/20-RESEARCH.md
@.planning/phases/15-live-data-integration/15-01-SUMMARY.md
@.planning/phases/16-realtime-visualizations/16-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: CRDT Foundation and Schema Extensions</name>
  <files>
    Sources/Isometry/Sync/CRDTNode.swift
    Sources/Isometry/Database/schema.sql
    Sources/Isometry/Sync/ConflictResolver.swift
  </files>
  <action>
    Create CRDT data structures following research patterns. Implement CRDTNode struct with siteId (device identifier), columnVersion (per-column CRDT version), dbVersion (logical clock), and lastWriteWins timestamp. Extend database schema.sql with CRDT metadata columns: site_id TEXT, column_version INTEGER, db_version INTEGER, last_write_wins DATETIME. Add conflict detection tables for tracking unresolved conflicts. Create ConflictResolver with last-write-wins algorithm using site ID tiebreaker for simultaneous edits. Implement vector clock logic for ordering operations across devices. Use research patterns for CRDT conflict resolution without requiring external cr-sqlite dependency - build minimal CRDT support using existing SQLite and GRDB infrastructure.
  </action>
  <verify>
    Database migration succeeds adding CRDT columns. CRDT conflict resolution test: two simultaneous edits resolve to deterministic winner based on last-write-wins + siteId tiebreaker.
  </verify>
  <done>
    CRDT infrastructure exists with database schema support and deterministic conflict resolution algorithms.
  </done>
</task>

<task type="auto">
  <name>Task 2: Conflict Detection and Resolution Manager</name>
  <files>
    Sources/Isometry/Sync/ConflictResolutionManager.swift
    Sources/Isometry/Database/IsometryDatabase+Sync.swift
  </files>
  <action>
    Build ConflictResolutionManager actor that integrates with existing database infrastructure. Implement detectConflicts method that compares CRDT metadata during sync operations to identify conflicting changes. Create resolveConflicts method that applies CRDT resolution rules automatically for simple conflicts (different fields) and flags complex conflicts (same field changes) for user resolution. Add mergeChanges method that combines non-conflicting updates and preserves user selections for resolved conflicts. Integrate with existing CloudKit sync patterns without requiring changes to sync infrastructure. Use existing database transaction patterns and ensure conflict resolution participates in transaction safety. Include comprehensive logging and error handling for debugging multi-device scenarios.
  </action>
  <verify>
    Conflict detection correctly identifies simultaneous edits. Automatic resolution merges non-conflicting changes. Complex conflicts properly flagged for manual resolution.
  </verify>
  <done>
    Conflict resolution manager detects and resolves conflicts automatically with user escalation for complex cases.
  </done>
</task>

<task type="auto">
  <name>Task 3: React Conflict Resolution UI</name>
  <files>
    src/contexts/ConflictResolutionContext.tsx
    src/hooks/useConflictResolution.ts
    src/components/ConflictResolutionDialog.tsx
  </files>
  <action>
    Create React context for managing conflict resolution state. Implement ConflictResolutionContext that tracks pending conflicts, provides resolution options, and communicates with Swift conflict manager via bridge. Build useConflictResolution hook that provides conflict notification, resolution options (accept local, accept remote, manual merge), and resolution submission. Create ConflictResolutionDialog component that displays conflicting versions side-by-side with user-friendly comparison and resolution controls. Integrate with existing live data subscriptions to show real-time conflict notifications. Use existing WebView bridge patterns for communication with Swift conflict resolution manager. Include proper error handling and loading states. Design should be minimal and non-blocking - conflicts appear as notifications, not blocking modals.
  </action>
  <verify>
    Conflict resolution UI displays when conflicts detected. User can select resolution options and submit changes. Live data updates reflect resolved conflicts immediately.
  </verify>
  <done>
    Complete React conflict resolution interface with user control over conflict resolution decisions and real-time conflict notifications.
  </done>
</task>

</tasks>

<verification>
- Multi-device conflict detection works correctly during simultaneous edits
- Automatic conflict resolution handles non-conflicting changes transparently
- User interface provides clear conflict resolution options
- Resolved conflicts sync correctly across all devices
</verification>

<success_criteria>
- CRDT metadata enables conflict-free replication for independent changes
- Complex conflicts escalate to user with clear resolution interface
- Conflict resolution integrates with existing sync and live data systems
- Multi-device editing scenarios preserve data integrity
- User notifications for conflicts are non-blocking and informative
</success_criteria>

<output>
After completion, create `.planning/phases/20-transaction-and-sync-management/20-02-SUMMARY.md`
</output>