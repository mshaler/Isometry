<!DOCTYPE html>
<html>
<head>
    <title>Isometry App sql.js Capabilities Test</title>
    <style>
        body {
            font-family: 'SF Mono', Menlo, 'Monaco', 'Consolas', 'Liberation Mono', 'Courier New', monospace;
            padding: 20px;
            background: #1a1a1a;
            color: #00ff00;
            line-height: 1.5;
        }
        pre { background: #000; padding: 15px; border: 1px solid #333; border-radius: 4px; }
        .error { color: #ff6b6b; font-weight: bold; }
        .success { color: #51cf66; font-weight: bold; }
        .warning { color: #ffd43b; font-weight: bold; }
        .info { color: #74c0fc; }
        h1 { color: #ffffff; text-align: center; margin-bottom: 30px; }
        .gate-status {
            padding: 20px;
            margin: 20px 0;
            border: 2px solid;
            border-radius: 8px;
            text-align: center;
            font-size: 1.2em;
            font-weight: bold;
        }
        .gate-open { border-color: #51cf66; background: rgba(81, 207, 102, 0.1); }
        .gate-blocked { border-color: #ff6b6b; background: rgba(255, 107, 107, 0.1); }
    </style>
</head>
<body>
    <h1>üîç Isometry v4 P0 Gate Verification</h1>
    <p>Testing the actual app SQLiteProvider for FTS5 and recursive CTE support.</p>
    <div id="output"></div>

    <script type="module">
        const output = document.getElementById('output');

        function log(message, type = 'info') {
            const div = document.createElement('div');
            div.textContent = message;
            div.className = type;
            output.appendChild(div);
            console.log(message);
        }

        function showGateStatus(isOpen, requirements = []) {
            const div = document.createElement('div');
            div.className = `gate-status ${isOpen ? 'gate-open' : 'gate-blocked'}`;

            if (isOpen) {
                div.innerHTML = `
                    <div class="success">üö™ Phase 2 Gate Status: OPEN</div>
                    <div style="margin-top: 10px; font-size: 0.9em; color: #51cf66;">‚úÖ Ready for SuperGrid implementation</div>
                `;
            } else {
                div.innerHTML = `
                    <div class="error">üö™ Phase 2 Gate Status: BLOCKED</div>
                    <div style="margin-top: 10px; font-size: 0.9em; color: #ff6b6b;">Requirements not met:</div>
                    <ul style="text-align: left; margin-top: 5px;">
                        ${requirements.map(req => `<li>${req}</li>`).join('')}
                    </ul>
                `;
            }

            output.appendChild(div);
        }

        async function testAppCapabilities() {
            log('üîß Testing Isometry App sql.js capabilities...', 'info');

            try {
                // Import the SQLiteProvider from the actual app
                // Note: This will load the app's sql.js-fts5 configuration
                const { default: initSqlJs } = await import('sql.js-fts5');

                // Use the same locateFile configuration as SQLiteProvider
                const SQL = await initSqlJs({
                    locateFile: (file) => `/wasm/${file}`
                });

                const db = new SQL.Database();
                log('‚úÖ App sql.js-fts5 initialized successfully', 'success');

                // Test capabilities exactly like SQLiteProvider does
                const capabilities = {
                    fts5: false,
                    json1: false,
                    recursiveCte: false
                };

                // Test FTS5 support - exact same method as SQLiteProvider
                try {
                    db.exec("CREATE VIRTUAL TABLE fts_capability_test USING fts5(content)");
                    db.exec("INSERT INTO fts_capability_test VALUES ('test content')");
                    const fts5Results = db.exec("SELECT * FROM fts_capability_test WHERE fts_capability_test MATCH 'test'");
                    db.exec("DROP TABLE fts_capability_test");

                    if (fts5Results.length > 0) {
                        capabilities.fts5 = true;
                        log('‚úÖ FTS5 support verified with virtual table test', 'success');
                    } else {
                        throw new Error('FTS5 virtual table created but search failed');
                    }
                } catch (ftsError) {
                    log(`‚ùå FTS5 not available: ${ftsError.message}`, 'error');
                }

                // Test JSON1 support
                try {
                    db.exec("SELECT json('{\"test\": true}') AS json_result");
                    capabilities.json1 = true;
                    log('‚úÖ JSON1 support verified', 'success');
                } catch (jsonError) {
                    log(`‚ö†Ô∏è JSON1 not available: ${jsonError.message}`, 'warning');
                }

                // Test recursive CTE support - exact same as SQLiteProvider
                try {
                    const result = db.exec(`
                        WITH RECURSIVE test_cte(n) AS (
                            SELECT 1
                            UNION ALL
                            SELECT n+1 FROM test_cte WHERE n < 3
                        )
                        SELECT COUNT(*) as count FROM test_cte
                    `);

                    if (result.length > 0 && result[0].values.length > 0) {
                        const count = result[0].values[0][0];
                        if (count === 3) {
                            capabilities.recursiveCte = true;
                            log('‚úÖ Recursive CTE support verified', 'success');
                        } else {
                            throw new Error(`CTE returned incorrect result: ${count}, expected 3`);
                        }
                    } else {
                        throw new Error('CTE test returned empty result');
                    }
                } catch (cteError) {
                    log(`‚ùå Recursive CTEs failed: ${cteError.message}`, 'error');
                }

                // Test actual schema execution
                log('', 'info');
                log('üî® Testing Isometry schema execution...', 'info');

                try {
                    // Load and execute the actual schema
                    const response = await fetch('/db/schema.sql');
                    if (!response.ok) {
                        throw new Error(`Schema fetch failed: ${response.status}`);
                    }

                    const schemaSQL = await response.text();
                    db.exec(schemaSQL);
                    log('‚úÖ Isometry schema executed successfully', 'success');

                    // Verify FTS5 tables were created
                    const ftsTablesResult = db.exec(`
                        SELECT name FROM sqlite_master
                        WHERE type='table' AND name LIKE '%_fts'
                        ORDER BY name
                    `);

                    if (ftsTablesResult.length > 0) {
                        const ftsTables = ftsTablesResult[0].values.map(row => row[0]);
                        log(`‚úÖ FTS5 virtual tables created: ${ftsTables.join(', ')}`, 'success');
                    }

                    // Test FTS5 search on actual schema
                    const searchTest = db.exec(`
                        SELECT name FROM nodes_fts
                        WHERE nodes_fts MATCH 'isometry'
                        LIMIT 5
                    `);
                    log(`‚úÖ FTS5 search test: ${searchTest.length > 0 ? searchTest[0].values.length : 0} results`, 'success');

                    // Test graph traversal on actual schema
                    const graphTest = db.exec(`
                        WITH RECURSIVE connected_nodes(id, path, depth) AS (
                            SELECT id, name, 0 FROM nodes WHERE id = 'card-1'
                            UNION ALL
                            SELECT e.target_id, cn.path || ' -> ' || n.name, cn.depth + 1
                            FROM connected_nodes cn
                            JOIN edges e ON e.source_id = cn.id
                            JOIN nodes n ON n.id = e.target_id
                            WHERE cn.depth < 3
                        )
                        SELECT COUNT(*) as reachable_count FROM connected_nodes
                    `);

                    if (graphTest.length > 0) {
                        const reachableCount = graphTest[0].values[0][0];
                        log(`‚úÖ Graph traversal test: ${reachableCount} reachable nodes`, 'success');
                    }

                } catch (schemaError) {
                    log(`‚ö†Ô∏è Schema test failed: ${schemaError.message}`, 'warning');
                }

                db.close();

                // Final assessment
                log('', 'info');
                log('üîç FINAL GATE ASSESSMENT:', 'info');
                log(`FTS5 Support: ${capabilities.fts5 ? '‚úÖ AVAILABLE' : '‚ùå MISSING'}`, capabilities.fts5 ? 'success' : 'error');
                log(`JSON1 Support: ${capabilities.json1 ? '‚úÖ AVAILABLE' : '‚ùå MISSING'}`, capabilities.json1 ? 'success' : 'warning');
                log(`Recursive CTEs: ${capabilities.recursiveCte ? '‚úÖ AVAILABLE' : '‚ùå MISSING'}`, capabilities.recursiveCte ? 'success' : 'error');

                const gateRequirements = [];
                const gateOpen = capabilities.fts5 && capabilities.recursiveCte;

                if (!capabilities.fts5) {
                    gateRequirements.push('FTS5 full-text search support');
                }
                if (!capabilities.recursiveCte) {
                    gateRequirements.push('Recursive CTE support for graph traversal');
                }

                showGateStatus(gateOpen, gateRequirements);

                if (gateOpen) {
                    log('üöÄ Phase 2 SuperGrid implementation can proceed!', 'success');
                } else {
                    log('üö® Phase 2 blocked until requirements are met', 'error');
                }

                return gateOpen;

            } catch (error) {
                log(`üí• App capabilities test FAILED: ${error.message}`, 'error');
                showGateStatus(false, [`Critical error: ${error.message}`]);
                return false;
            }
        }

        // Run the test automatically
        testAppCapabilities();
    </script>
</body>
</html>