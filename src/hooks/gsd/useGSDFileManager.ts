/**
 * GSD File Management System
 *
 * Complete file management infrastructure for .planning/ directory structure.
 * Provides Terminal.app workflow parity with automated file generation,
 * milestone tracking, phase management, and session persistence.
 */

import { useCallback, useRef, useMemo } from 'react';
import { useGSDDatabase } from './useGSDDatabase';

/**
 * File structure patterns for GSD workflows
 */
interface GSDFileStructure {
  milestones: {
    path: string;
    requirements: string[];
    phases: GSDPhaseStructure[];
  };
  phases: GSDPhaseStructure[];
  sessions: {
    path: string;
    metadata: GSDSessionMetadata;
  }[];
}

interface GSDPhaseStructure {
  id: string;
  name: string;
  path: string;
  planFile: string;
  researchFile?: string;
  verificationFile?: string;
  summaryFile?: string;
  requirements: string[];
}

interface GSDSessionMetadata {
  sessionId: string;
  timestamp: Date;
  duration: number;
  commands: string[];
  filesModified: string[];
  commitHashes: string[];
}

interface MilestoneTemplate {
  name: string;
  description: string;
  phases: {
    name: string;
    requirements: string[];
    estimatedDuration: string;
  }[];
}

interface ProjectTemplate {
  name: string;
  description: string;
  structure: GSDFileStructure;
  defaultRequirements: string[];
}

export function useGSDFileManager() {
  const { saveSession: saveDbSession, restoreSession: restoreDbSession } = useGSDDatabase() || {};
  const fileOperationQueue = useRef<Promise<any>[]>([]);
  const currentMilestone = useRef<string | null>(null);
  const currentPhase = useRef<string | null>(null);

  // File system operations
  const ensureDirectoryExists = useCallback(async (dirPath: string) => {
    try {
      // In browser environment, we simulate filesystem with localStorage
      const existingDirs = JSON.parse(localStorage.getItem('gsd_directories') || '[]');
      if (!existingDirs.includes(dirPath)) {
        existingDirs.push(dirPath);
        localStorage.setItem('gsd_directories', JSON.stringify(existingDirs));
      }
      return true;
    } catch (error) {
      console.error('Failed to ensure directory exists:', dirPath, error);
      return false;
    }
  }, []);

  const writeFile = useCallback(async (filePath: string, content: string) => {
    try {
      // Simulate file system with localStorage
      const fileKey = `gsd_file_${filePath}`;
      localStorage.setItem(fileKey, content);

      // Track file modification
      const fileList = JSON.parse(localStorage.getItem('gsd_files') || '[]');
      const fileEntry = {
        path: filePath,
        lastModified: Date.now(),
        size: content.length
      };

      const existingIndex = fileList.findIndex((f: any) => f.path === filePath);
      if (existingIndex >= 0) {
        fileList[existingIndex] = fileEntry;
      } else {
        fileList.push(fileEntry);
      }

      localStorage.setItem('gsd_files', JSON.stringify(fileList));
      return true;
    } catch (error) {
      console.error('Failed to write file:', filePath, error);
      return false;
    }
  }, []);

  const readFile = useCallback(async (filePath: string): Promise<string | null> => {
    try {
      const fileKey = `gsd_file_${filePath}`;
      return localStorage.getItem(fileKey);
    } catch (error) {
      console.error('Failed to read file:', filePath, error);
      return null;
    }
  }, []);

  const listFiles = useCallback(async (dirPath: string): Promise<string[]> => {
    try {
      const fileList = JSON.parse(localStorage.getItem('gsd_files') || '[]');
      return fileList
        .filter((f: any) => f.path.startsWith(dirPath))
        .map((f: any) => f.path);
    } catch (error) {
      console.error('Failed to list files:', dirPath, error);
      return [];
    }
  }, []);

  // Milestone Management
  const createMilestone = useCallback(async (name: string, template?: string) => {
    const milestoneId = name.toLowerCase().replace(/\s+/g, '-');
    const milestonePath = `.planning/milestones/${milestoneId}`;

    await ensureDirectoryExists(milestonePath);

    const milestoneContent = `# Milestone: ${name}

**Created:** ${new Date().toISOString()}
**Status:** planning
**Template:** ${template || 'custom'}

## Overview

${name} milestone with automated phase management.

## Phases

(Phases will be added as they are planned)

## Requirements

- [ ] Phase planning complete
- [ ] Verification criteria defined
- [ ] Success metrics established

## Progress

- Milestone created: ${new Date().toLocaleDateString()}

---

*Generated by GSD File Manager*
`;

    const success = await writeFile(`${milestonePath}/MILESTONE.md`, milestoneContent);
    if (success) {
      currentMilestone.current = milestoneId;
      return { milestoneId, path: milestonePath };
    }

    throw new Error('Failed to create milestone file');
  }, [ensureDirectoryExists, writeFile]);

  const listMilestones = useCallback(async () => {
    const milestoneFiles = await listFiles('.planning/milestones/');
    const milestones = [];

    for (const file of milestoneFiles) {
      if (file.endsWith('MILESTONE.md')) {
        const content = await readFile(file);
        if (content) {
          const nameMatch = content.match(/# Milestone: (.+)/);
          const statusMatch = content.match(/\*\*Status:\*\* (.+)/);

          milestones.push({
            path: file.replace('/MILESTONE.md', ''),
            name: nameMatch ? nameMatch[1] : 'Unknown',
            status: statusMatch ? statusMatch[1] : 'unknown'
          });
        }
      }
    }

    return milestones;
  }, [listFiles, readFile]);

  // Project Management
  const createProject = useCallback(async (name: string, template?: string) => {
    const projectId = name.toLowerCase().replace(/\s+/g, '-');
    const projectPath = `.planning/projects/${projectId}`;

    await ensureDirectoryExists(projectPath);
    await ensureDirectoryExists(`${projectPath}/phases`);

    const projectContent = `# Project: ${name}

**Created:** ${new Date().toISOString()}
**Template:** ${template || 'standard'}
**Status:** active

## Project Overview

${name} - GSD managed project with phase-based development.

## Structure

- **Phases Directory:** \`${projectPath}/phases/\`
- **Planning Files:** Auto-generated during phase planning
- **Research:** Background research for each phase
- **Verification:** Automated verification reports

## Current Phase

None yet - use \`/gsd:plan-phase\` to create first phase.

## Progress Tracking

- Project initialized: ${new Date().toLocaleDateString()}

---

*Generated by GSD File Manager*
`;

    const stateContent = `# Project State: ${name}

## Current Position

Project: ${projectId}
Phase: None
Status: Initialized

## Metrics

- Total phases: 0
- Completed phases: 0
- Active phase: None

## Last Update

${new Date().toISOString()}
`;

    await writeFile(`${projectPath}/PROJECT.md`, projectContent);
    await writeFile(`${projectPath}/STATE.md`, stateContent);

    return { projectId, path: projectPath };
  }, [ensureDirectoryExists, writeFile]);

  // Phase Management
  const createPhase = useCallback(async (name: string, requirements?: string[]) => {
    const phaseNumber = String(Math.floor(Math.random() * 100) + 1).padStart(2, '0');
    const phaseId = `${phaseNumber}-${name.toLowerCase().replace(/\s+/g, '-')}`;
    const phasePath = `.planning/phases/${phaseId}`;

    await ensureDirectoryExists(phasePath);

    const phaseContent = `# Phase ${phaseNumber}: ${name}

**Created:** ${new Date().toISOString()}
**Status:** planning
**Requirements:** ${requirements?.length || 0} defined

## Phase Goal

${name}

## Requirements

${requirements ? requirements.map((req, i) => `- REQ-${String(i + 1).padStart(2, '0')}: ${req}`).join('\n') : '(No specific requirements defined)'}

## Implementation Plan

(Plan will be generated during phase planning)

## Verification Criteria

(Verification criteria will be defined during planning)

---

*Generated by GSD File Manager*
`;

    const planContent = `---
phase: ${phaseId}
status: planning
created: ${new Date().toISOString()}
---

# ${phaseId.toUpperCase()}-PLAN.md

## Objective

${name}

## Tasks

- [ ] Phase research
- [ ] Implementation planning
- [ ] Verification setup

## Timeline

Estimated: TBD
Actual: TBD

---

*Plan generated by GSD File Manager*
`;

    await writeFile(`${phasePath}/${phaseId.toUpperCase()}.md`, phaseContent);
    await writeFile(`${phasePath}/${phaseId.toUpperCase()}-PLAN.md`, planContent);

    currentPhase.current = phaseId;
    return { phaseId, path: phasePath };
  }, [ensureDirectoryExists, writeFile]);

  const executePhase = useCallback(async () => {
    if (!currentPhase.current) {
      throw new Error('No active phase to execute');
    }

    const phasePath = `.planning/phases/${currentPhase.current}`;
    const executionLog = `# Phase Execution Log

**Phase:** ${currentPhase.current}
**Started:** ${new Date().toISOString()}
**Status:** executing

## Execution Steps

- Phase execution started
- Implementation in progress

## Real-time Updates

${new Date().toLocaleTimeString()}: Execution initiated

---

*Generated by GSD File Manager*
`;

    await writeFile(`${phasePath}/EXECUTION.md`, executionLog);
    return { phaseId: currentPhase.current, status: 'executing' };
  }, [writeFile]);

  const verifyPhase = useCallback(async () => {
    if (!currentPhase.current) {
      throw new Error('No active phase to verify');
    }

    const phasePath = `.planning/phases/${currentPhase.current}`;
    const verificationContent = `# Phase Verification Report

**Phase:** ${currentPhase.current}
**Verified:** ${new Date().toISOString()}
**Status:** verification_in_progress

## Verification Checklist

- [ ] Requirements met
- [ ] Quality gates passed
- [ ] Integration tested
- [ ] Documentation updated

## Automated Checks

(Results from automated verification systems)

## Manual Verification Required

(Items requiring human verification)

---

*Generated by GSD File Manager*
`;

    await writeFile(`${phasePath}/VERIFICATION.md`, verificationContent);
    return { phaseId: currentPhase.current, status: 'verifying' };
  }, [writeFile]);

  // Research and Documentation
  const startResearch = useCallback(async (topic: string) => {
    if (!currentPhase.current) {
      const researchId = topic.toLowerCase().replace(/\s+/g, '-');
      const researchPath = `.planning/research/${researchId}`;
      await ensureDirectoryExists(researchPath);

      const researchContent = `# Research: ${topic}

**Started:** ${new Date().toISOString()}
**Status:** active

## Research Questions

- What are the key requirements for ${topic}?
- What are the best practices and patterns?
- What are potential challenges and solutions?

## Findings

(Research findings will be documented here)

## Sources

- [ ] Documentation review
- [ ] Code analysis
- [ ] Best practices research

---

*Generated by GSD File Manager*
`;

      await writeFile(`${researchPath}/RESEARCH.md`, researchContent);
      return { researchId, path: researchPath };
    } else {
      const phasePath = `.planning/phases/${currentPhase.current}`;
      const researchContent = `# Phase Research: ${topic}

**Phase:** ${currentPhase.current}
**Started:** ${new Date().toISOString()}
**Topic:** ${topic}

## Research Scope

Phase-specific research for ${currentPhase.current}

## Key Questions

- How does this impact the current phase goals?
- What implementation approaches are available?
- What dependencies and risks exist?

## Research Results

(Results will be documented here)

---

*Generated by GSD File Manager*
`;

      await writeFile(`${phasePath}/RESEARCH.md`, researchContent);
      return { phaseId: currentPhase.current, topic };
    }
  }, [currentPhase, ensureDirectoryExists, writeFile]);

  const mapCodebase = useCallback(async () => {
    const mappingContent = `# Codebase Mapping

**Generated:** ${new Date().toISOString()}
**Tool:** GSD File Manager

## Architecture Overview

(Architecture analysis will be generated here)

## Key Components

(Component analysis will be generated here)

## Dependencies

(Dependency graph will be generated here)

## Integration Points

(Integration analysis will be generated here)

---

*Generated by GSD File Manager*
`;

    await writeFile('.planning/CODEBASE_MAP.md', mappingContent);
    return { status: 'mapped', file: '.planning/CODEBASE_MAP.md' };
  }, [writeFile]);

  // Session Management
  const saveSession = useCallback(async () => {
    const sessionData = {
      sessionId: Date.now().toString(),
      timestamp: new Date().toISOString(),
      milestone: currentMilestone.current,
      phase: currentPhase.current,
      files: await listFiles('.planning/'),
      metadata: {
        fileCount: (await listFiles('.planning/')).length,
        lastActivity: new Date().toISOString()
      }
    };

    const sessionPath = `.planning/sessions/${sessionData.sessionId}`;
    await ensureDirectoryExists(sessionPath);
    await writeFile(`${sessionPath}/session.json`, JSON.stringify(sessionData, null, 2));

    // Also save to database if available
    if (saveDbSession) {
      await saveDbSession(sessionData);
    }

    return sessionData;
  }, [currentMilestone, currentPhase, listFiles, ensureDirectoryExists, writeFile, saveDbSession]);

  const restoreSession = useCallback(async (sessionId: string) => {
    const sessionPath = `.planning/sessions/${sessionId}`;
    const sessionData = await readFile(`${sessionPath}/session.json`);

    if (sessionData) {
      const session = JSON.parse(sessionData);
      currentMilestone.current = session.milestone;
      currentPhase.current = session.phase;

      // Also restore from database if available
      if (restoreDbSession) {
        await restoreDbSession(sessionId);
      }

      return session;
    }

    throw new Error(`Session not found: ${sessionId}`);
  }, [readFile, restoreDbSession]);

  const updateState = useCallback(async () => {
    const stateContent = `# Project State

## Current Position

Milestone: ${currentMilestone.current || 'None'}
Phase: ${currentPhase.current || 'None'}
Updated: ${new Date().toISOString()}

## File Summary

- Total files: ${(await listFiles('.planning/')).length}
- Last update: ${new Date().toLocaleTimeString()}

## Active Sessions

(Session tracking data)

---

*Generated by GSD File Manager*
`;

    await writeFile('.planning/STATE.md', stateContent);
    return { status: 'updated', timestamp: new Date().toISOString() };
  }, [currentMilestone, currentPhase, listFiles, writeFile]);

  // Integration and Deployment
  const checkIntegration = useCallback(async () => {
    const integrationReport = `# Integration Check Report

**Generated:** ${new Date().toISOString()}
**Status:** checking

## System Integration

- [ ] Database connectivity
- [ ] File system access
- [ ] Git integration
- [ ] Hook integration

## Dependencies

- [ ] Core dependencies available
- [ ] Version compatibility
- [ ] Configuration valid

## Results

(Integration check results will be documented here)

---

*Generated by GSD File Manager*
`;

    await writeFile('.planning/INTEGRATION_CHECK.md', integrationReport);
    return { status: 'checked', report: '.planning/INTEGRATION_CHECK.md' };
  }, [writeFile]);

  const deployPhase = useCallback(async () => {
    if (!currentPhase.current) {
      throw new Error('No active phase to deploy');
    }

    const deploymentLog = `# Phase Deployment

**Phase:** ${currentPhase.current}
**Deployed:** ${new Date().toISOString()}
**Status:** deployment_initiated

## Deployment Steps

- [ ] Pre-deployment checks
- [ ] Build verification
- [ ] Integration testing
- [ ] Production deployment
- [ ] Post-deployment validation

## Results

(Deployment results will be documented here)

---

*Generated by GSD File Manager*
`;

    const phasePath = `.planning/phases/${currentPhase.current}`;
    await writeFile(`${phasePath}/DEPLOYMENT.md`, deploymentLog);

    return { phaseId: currentPhase.current, status: 'deploying' };
  }, [currentPhase, writeFile]);

  // Debug and Analytics
  const startDebugSession = useCallback(async (issue: string) => {
    const debugId = `debug-${Date.now()}`;
    const debugPath = `.planning/debug/${debugId}`;
    await ensureDirectoryExists(debugPath);

    const debugContent = `# Debug Session: ${issue}

**Started:** ${new Date().toISOString()}
**Issue:** ${issue}
**Session ID:** ${debugId}

## Problem Description

${issue}

## Investigation Steps

- [ ] Reproduce issue
- [ ] Gather system information
- [ ] Analyze logs
- [ ] Identify root cause
- [ ] Implement fix
- [ ] Verify resolution

## Findings

(Investigation findings will be documented here)

## Solution

(Solution will be documented here)

---

*Generated by GSD File Manager*
`;

    await writeFile(`${debugPath}/DEBUG.md`, debugContent);
    return { debugId, path: debugPath };
  }, [ensureDirectoryExists, writeFile]);

  const showAnalytics = useCallback(async () => {
    const files = await listFiles('.planning/');
    const analytics = {
      totalFiles: files.length,
      milestones: files.filter(f => f.includes('/milestones/')).length,
      phases: files.filter(f => f.includes('/phases/')).length,
      sessions: files.filter(f => f.includes('/sessions/')).length,
      lastUpdate: new Date().toISOString()
    };

    const analyticsContent = `# GSD Analytics Dashboard

**Generated:** ${new Date().toISOString()}

## File System Metrics

- **Total Files:** ${analytics.totalFiles}
- **Milestones:** ${analytics.milestones}
- **Phases:** ${analytics.phases}
- **Sessions:** ${analytics.sessions}

## Activity Summary

- **Current Milestone:** ${currentMilestone.current || 'None'}
- **Current Phase:** ${currentPhase.current || 'None'}
- **Last Activity:** ${analytics.lastUpdate}

## Performance Metrics

(Detailed metrics will be generated here)

---

*Generated by GSD File Manager*
`;

    await writeFile('.planning/ANALYTICS.md', analyticsContent);
    return analytics;
  }, [listFiles, writeFile, currentMilestone, currentPhase]);

  const generateVelocityReport = useCallback(async () => {
    const velocityContent = `# Velocity Report

**Generated:** ${new Date().toISOString()}

## Development Velocity

- **Active Phase:** ${currentPhase.current || 'None'}
- **Phase Duration:** Calculating...
- **Files per Hour:** Calculating...

## Trends

(Velocity trends will be calculated here)

## Recommendations

(Performance recommendations will be generated here)

---

*Generated by GSD File Manager*
`;

    await writeFile('.planning/VELOCITY_REPORT.md', velocityContent);
    return { status: 'generated', report: '.planning/VELOCITY_REPORT.md' };
  }, [writeFile, currentPhase]);

  // Template Management
  const loadTemplate = useCallback(async (templateName: string) => {
    const templateKey = `gsd_template_${templateName}`;
    const templateData = localStorage.getItem(templateKey);

    if (templateData) {
      return JSON.parse(templateData);
    }

    throw new Error(`Template not found: ${templateName}`);
  }, []);

  const saveTemplate = useCallback(async (templateName: string, templateData?: any) => {
    const template = templateData || {
      name: templateName,
      created: new Date().toISOString(),
      milestone: currentMilestone.current,
      phase: currentPhase.current,
      structure: await listFiles('.planning/')
    };

    const templateKey = `gsd_template_${templateName}`;
    localStorage.setItem(templateKey, JSON.stringify(template));

    return { templateName, status: 'saved' };
  }, [currentMilestone, currentPhase, listFiles]);

  const createTemplate = useCallback(async (templateName: string) => {
    const template: ProjectTemplate = {
      name: templateName,
      description: `Custom template: ${templateName}`,
      structure: {
        milestones: {
          path: '.planning/milestones/',
          requirements: ['Define milestone scope', 'Set success criteria'],
          phases: []
        },
        phases: [],
        sessions: []
      },
      defaultRequirements: [
        'Requirements analysis complete',
        'Implementation plan defined',
        'Verification criteria established'
      ]
    };

    return await saveTemplate(templateName, template);
  }, [saveTemplate]);

  // File Operations
  const createPlanFile = useCallback(async () => {
    if (!currentPhase.current) {
      throw new Error('No active phase for plan file creation');
    }

    const phasePath = `.planning/phases/${currentPhase.current}`;
    const planContent = `---
phase: ${currentPhase.current}
created: ${new Date().toISOString()}
status: active
---

# ${currentPhase.current.toUpperCase()}-PLAN.md

## Objective

(Define phase objective here)

## Implementation Tasks

- [ ] Task 1
- [ ] Task 2
- [ ] Task 3

## Acceptance Criteria

- [ ] Criteria 1
- [ ] Criteria 2
- [ ] Criteria 3

## Timeline

- **Estimated Duration:** TBD
- **Start Date:** ${new Date().toLocaleDateString()}
- **Target Completion:** TBD

---

*Generated by GSD File Manager*
`;

    await writeFile(`${phasePath}/${currentPhase.current.toUpperCase()}-PLAN.md`, planContent);
    return { phaseId: currentPhase.current, file: `${currentPhase.current.toUpperCase()}-PLAN.md` };
  }, [currentPhase, writeFile]);

  const updateSummaryFile = useCallback(async () => {
    const summaryContent = `# Project Summary

**Last Updated:** ${new Date().toISOString()}

## Current Status

- **Milestone:** ${currentMilestone.current || 'None'}
- **Phase:** ${currentPhase.current || 'None'}
- **Files:** ${(await listFiles('.planning/')).length}

## Recent Activity

- Summary updated: ${new Date().toLocaleTimeString()}

## Progress Overview

(Progress details will be generated here)

---

*Generated by GSD File Manager*
`;

    await writeFile('.planning/SUMMARY.md', summaryContent);
    return { status: 'updated', file: '.planning/SUMMARY.md' };
  }, [currentMilestone, currentPhase, listFiles, writeFile]);

  // Public API
  return {
    // File operations
    ensureDirectoryExists,
    writeFile,
    readFile,
    listFiles,

    // Milestone management
    createMilestone,
    listMilestones,

    // Project management
    createProject,

    // Phase management
    createPhase,
    executePhase,
    verifyPhase,

    // Research and documentation
    startResearch,
    mapCodebase,

    // Session management
    saveSession,
    restoreSession,
    updateState,

    // Integration and deployment
    checkIntegration,
    deployPhase,

    // Debug and analytics
    startDebugSession,
    showAnalytics,
    generateVelocityReport,

    // Template management
    loadTemplate,
    saveTemplate,
    createTemplate,

    // File operations
    createPlanFile,
    updateSummaryFile,

    // State accessors
    getCurrentMilestone: () => currentMilestone.current,
    getCurrentPhase: () => currentPhase.current,
    setCurrentMilestone: (milestone: string) => { currentMilestone.current = milestone; },
    setCurrentPhase: (phase: string) => { currentPhase.current = phase; }
  };
}