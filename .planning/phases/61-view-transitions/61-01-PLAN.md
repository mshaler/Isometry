---
phase: 61-view-transitions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/d3/grid-rendering/GridRenderingEngine.ts
  - src/d3/SuperGrid.ts
autonomous: true

must_haves:
  truths:
    - "User changes axis mapping and sees cards smoothly transition to new positions (300ms animation)"
    - "User changes axis mapping and sees single-level header elements smoothly transition with cards"
    - "User changes axis mapping and sees nested headers fade in with opacity animation (repositioning not animated)"
    - "User has cards selected, changes axis mapping, and selected cards remain selected after transition"
  artifacts:
    - path: "src/d3/grid-rendering/GridRenderingEngine.ts"
      provides: "Card and header transitions with selection preservation"
      contains: ".transition().duration(300)"
    - path: "src/d3/SuperGrid.ts"
      provides: "SelectionContext wiring to GridRenderingEngine"
      contains: "setSelectedIds"
  key_links:
    - from: "src/d3/SuperGrid.ts"
      to: "src/d3/grid-rendering/GridRenderingEngine.ts"
      via: "setSelectedIds method call"
      pattern: "renderingEngine\\.setSelectedIds"
    - from: "src/d3/grid-rendering/GridRenderingEngine.ts"
      to: "cards with transitions"
      via: ".transition().duration(300)"
      pattern: "\\.transition\\(\\)\\.duration\\(300\\)"
    - from: "GridRenderingEngine renderProjectionHeaders"
      to: "single-level header animations"
      via: ".join() enter/update/exit transitions"
      pattern: "\\.join\\([^)]*enter[^)]*transition"
    - from: "GridRenderingEngine renderNestedAxisHeaders"
      to: "nested header opacity fade"
      via: ".append().attr('opacity', 0).transition()"
      pattern: "append\\('g'\\)[^;]*opacity.*0[^;]*transition"
---

<objective>
Implement smooth animated view transitions when PAFV axis mappings change in the Navigator.

Purpose: Complete the view transition experience (TRANS-01, TRANS-02, TRANS-03) so users see polished animations when reorganizing the grid rather than jarring position jumps.

Output: GridRenderingEngine with coordinated card/header transitions and selection state preservation.

**Scope note:** Nested (hierarchical) headers use imperative DOM creation via `.append()`, not data-driven `.join()`. This phase implements opacity fade-in for nested headers; repositioning animation for nested headers requires a larger refactor deferred to a future phase.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/61-view-transitions/61-RESEARCH.md
@src/d3/grid-rendering/GridRenderingEngine.ts
@src/d3/SuperGrid.ts
@src/state/SelectionContext.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add transition interruption and standardize card animations</name>
  <files>src/d3/grid-rendering/GridRenderingEngine.ts</files>
  <action>
Modify GridRenderingEngine to properly handle view transitions:

1. **Add transition interruption at start of render()**
   - Before any rendering, call `.interrupt()` on cards, col-headers, row-headers
   - This prevents animation buildup during rapid axis changes
   - Add at start of `render()` method after container validation:
   ```typescript
   // Interrupt any ongoing transitions to prevent buildup
   this.container.selectAll('.card').interrupt();
   this.container.selectAll('.col-header').interrupt();
   this.container.selectAll('.row-header').interrupt();
   ```

2. **Standardize card animation durations in renderCards()**
   - Change enter animation from 200ms to 300ms for consistency
   - Keep update animation at 300ms (already correct)
   - Change exit animation from 200ms to 300ms
   - Use d3.easeCubicOut for enter/exit animations (already used for update)

3. **Add key function verification**
   - Verify `.data()` calls use key function `(d: CardRecord) => String(d.id)`
   - This is already present but confirm it's applied correctly for object constancy

Do NOT modify header rendering in this task — that's Task 2.
  </action>
  <verify>
Run `npm run typecheck` to verify no TypeScript errors.
Run the app with `npm run dev`, open SuperGrid preview, and rapidly change axis mappings in Navigator — cards should not jitter or stack animations.
  </verify>
  <done>
Card animations are 300ms enter/update/exit, transitions are interrupted on each render, and rapid axis changes don't cause animation buildup.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add header transitions coordinated with card animations</name>
  <files>src/d3/grid-rendering/GridRenderingEngine.ts</files>
  <action>
Add D3 transitions to header rendering methods. **Note: There are two rendering paths:**
- **Single-level headers:** `renderProjectionHeaders()` — uses `.join()`, supports full enter/update/exit transitions
- **Stacked headers:** `renderStackedProjectionHeaders()` delegates to `renderNestedAxisHeaders()` or `renderSimpleAxisHeaders()`

**1. Modify renderProjectionHeaders() for single-level headers (lines ~807-868)**

This method uses `.join('g')` pattern. MODIFY the existing `.join()` calls (do not replace the whole method) to ADD enter/update/exit transition callbacks:

For column headers (around line 807-833), change the existing `.join('g')` to:
```typescript
.join(
  enter => enter.append('g')
    .attr('class', 'col-header')
    .attr('transform', (_, i) =>
      `translate(${rowHeaderWidth + config.padding + i * (config.cardWidth + config.padding)}, -20)`)
    .attr('opacity', 0)
    .each(function (d) {
      const g = d3.select(this);
      g.append('rect')
        .attr('width', config.cardWidth)
        .attr('height', config.headerHeight)
        .attr('fill', '#f0f0f0')
        .attr('stroke', '#ddd')
        .attr('rx', 4);
      g.append('text')
        .attr('x', config.cardWidth / 2)
        .attr('y', config.headerHeight / 2 + 4)
        .attr('text-anchor', 'middle')
        .attr('font-size', '12px')
        .attr('fill', '#333')
        .text(d);
    })
    .call(g => g.transition()
      .duration(config.animationDuration)
      .ease(d3.easeCubicOut)
      .attr('transform', (_, i) =>
        `translate(${rowHeaderWidth + config.padding + i * (config.cardWidth + config.padding)}, 0)`)
      .attr('opacity', 1)),
  update => update
    .transition()
    .duration(config.animationDuration)
    .ease(d3.easeCubicOut)
    .attr('transform', (_, i) =>
      `translate(${rowHeaderWidth + config.padding + i * (config.cardWidth + config.padding)}, 0)`),
  exit => exit
    .transition()
    .duration(config.animationDuration)
    .attr('opacity', 0)
    .remove()
);
```

Apply the same pattern to row headers (lines ~835-863).

**2. Modify renderNestedAxisHeaders() for hierarchical/stacked headers**

This method uses imperative `.append('g')` without data binding, so it cannot support data-driven enter/update/exit repositioning. For this phase, add **opacity fade-in only** (repositioning animation is deferred).

Find the parent header group creation (around line 981-984) and modify:
```typescript
// Parent header group - add opacity fade-in
const parentGroup = headerContainer
  .append('g')
  .attr('class', 'row-header row-header--parent')
  .attr('transform', `translate(0, ${yPos})`)
  .attr('opacity', 0);
// ... add content (rect, text) ...
// After adding content, animate opacity:
parentGroup
  .transition()
  .duration(config.animationDuration)
  .attr('opacity', 1);
```

Apply the same pattern to:
- Child headers in the row axis section (around line 1012-1034)
- Parent headers in the column axis section (around line 1060-1063)
- Child headers in the column axis section

**3. Modify renderSimpleAxisHeaders() if it exists**

Apply the same `.join()` transition pattern as renderProjectionHeaders().

**4. Use config.animationDuration consistently**

Replace any hardcoded `duration(300)` with `duration(config.animationDuration)` (config already has `animationDuration: 300`).
  </action>
  <verify>
Run `npm run typecheck` to verify no TypeScript errors.
Run the app, change axis mappings:
- Single-level headers (one facet per axis) should slide in/out and reposition smoothly
- Nested headers (stacked facets) should fade in with opacity animation
  </verify>
  <done>
Single-level headers animate with full enter/update/exit transitions. Nested headers animate with opacity fade-in. All headers use consistent 300ms duration coordinated with card animations.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire SelectionContext to GridRenderingEngine for persistence</name>
  <files>
src/d3/grid-rendering/GridRenderingEngine.ts
src/d3/SuperGrid.ts
  </files>
  <action>
Preserve selection state across view transitions:

**1. Add selectedIds state to GridRenderingEngine**
```typescript
// Add to class properties
private selectedIds: Set<string> = new Set();

/**
 * Set selected card IDs for visual highlighting
 * Called from SuperGrid when SelectionContext changes
 */
public setSelectedIds(selectedIds: Set<string>): void {
  this.selectedIds = selectedIds;
}
```

**2. Apply selection styling in renderCards() after transitions**
In the card update transition, add `.on('end')` callback to re-apply selection:
```typescript
cardSelection
  .transition()
  .duration(this.config.animationDuration)
  .ease(d3.easeCubicOut)
  .attr('transform', (d: CardRecord) =>
    `translate(${(d.x as number) || 0}, ${(d.y as number) || 0})`
  )
  .on('end', (d: CardRecord, i: number, nodes: SVGGElement[]) => {
    const card = d3.select(nodes[i]);
    const isSelected = this.selectedIds.has(String(d.id));
    card.classed('selected', isSelected);
    card.select('.card-bg')
      .attr('stroke', isSelected ? '#2563eb' : '#e1e5e9')
      .attr('stroke-width', isSelected ? 2 : 1);
  });
```

**3. Apply selection to entering cards too**
After cardEnter transition, apply selection styling:
```typescript
cardEnter
  .transition()
  .duration(this.config.animationDuration)
  .attr('opacity', 1)
  .on('end', (d: CardRecord, i: number, nodes: SVGGElement[]) => {
    const card = d3.select(nodes[i]);
    const isSelected = this.selectedIds.has(String(d.id));
    card.classed('selected', isSelected);
    card.select('.card-bg')
      .attr('stroke', isSelected ? '#2563eb' : '#e1e5e9')
      .attr('stroke-width', isSelected ? 2 : 1);
  });
```

**4. Wire from SuperGrid.ts handleSelectionChange callback (line ~585-592)**
Modify to update renderingEngine:
```typescript
private handleSelectionChange(selectedIds: string[]): void {
  // Update drag controller with selected cards
  this.dragDropController.setSelectedCards(selectedIds);

  // NEW: Update rendering engine so transitions preserve selection
  this.renderingEngine.setSelectedIds(new Set(selectedIds));

  if (this.onSelectionChange) {
    this.onSelectionChange(selectedIds);
  }
}
```

**5. Add INITIAL selection sync in SuperGrid**

Selection must sync on initial render and after projection changes. Add sync call in two places:

**5a. After setProjection() triggers render (line ~277-294):**
```typescript
public setProjection(projection: PAFVProjection | null): void {
  const hasChanged = JSON.stringify(this.currentProjection) !== JSON.stringify(projection);
  this.currentProjection = projection;

  if (hasChanged) {
    superGridLogger.debug('PAFV projection updated:', { ... });

    if (this.currentData) {
      this.updateModulesWithData();
      // NEW: Sync selection state to rendering engine before render
      const currentSelection = this.selectionController.getSelectedIds?.() ?? [];
      this.renderingEngine.setSelectedIds(new Set(currentSelection));
      this.render();
    }
  }
}
```

**5b. After query() completes initial render (line ~236-237):**
```typescript
// After updateModulesWithData() and render():
// Sync selection state to rendering engine
const currentSelection = this.selectionController.getSelectedIds?.() ?? [];
this.renderingEngine.setSelectedIds(new Set(currentSelection));
```

**Note:** If `getSelectedIds()` doesn't exist on GridSelectionController, use an empty array as fallback to avoid breaking compilation. The selection will sync on subsequent user interactions.
  </action>
  <verify>
Run `npm run typecheck` to verify no TypeScript errors.
Test flow:
1. Open SuperGrid in preview
2. Click a card to select it (should highlight with blue border)
3. Change axis mapping in Navigator
4. Selected card should remain highlighted after transition completes

Also test:
- Multiple card selection persists through transitions
- Initial page load with no selection doesn't break rendering
  </verify>
  <done>
Selected cards remain selected after axis mapping changes. Selection styling (blue border) persists through animated view transitions. Initial render syncs selection state correctly.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Type check:** `npm run typecheck` passes
2. **Quality check:** `npm run check:quick` passes (types + lint)
3. **TRANS-01 verification:** Change axis mapping, see cards animate 300ms to new positions
4. **TRANS-02 verification:**
   - Single-level headers: Change axis mapping, see headers slide in/reposition/fade out
   - Nested headers: Change axis mapping, see headers fade in (opacity animation)
5. **TRANS-03 verification:** Select card, change axis, selected card stays selected
</verification>

<success_criteria>
- All three requirements (TRANS-01, TRANS-02, TRANS-03) are implemented
- Card transitions use 300ms duration with easeCubicOut easing
- Single-level header transitions are coordinated with card transitions (same duration)
- Nested header transitions use opacity fade-in (repositioning deferred to future phase)
- Selection state persists across view transitions
- Initial render syncs selection state correctly
- Rapid axis changes don't cause animation buildup (interrupt works)
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/61-view-transitions/61-01-SUMMARY.md`
</output>
