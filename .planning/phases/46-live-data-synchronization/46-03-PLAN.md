---
phase: 46-live-data-synchronization
plan: 03
type: execute
wave: 2
depends_on: ["46-01", "46-02"]
files_modified:
  - src/components/notebook/CaptureComponent.tsx
  - src/contexts/NotebookContext.tsx
autonomous: true

must_haves:
  truths:
    - "User clicks card in Preview and Capture loads that card (SYNC-02)"
    - "Current card auto-saves before loading new selection"
    - "TipTap editor scrolls to show the selected card content"
  artifacts:
    - path: "src/components/notebook/CaptureComponent.tsx"
      provides: "Capture component with selection-driven card loading"
      contains: "useSelection"
    - path: "src/contexts/NotebookContext.tsx"
      provides: "NotebookContext with loadCard capability"
      contains: "loadCard"
  key_links:
    - from: "src/components/notebook/CaptureComponent.tsx"
      to: "src/state/SelectionContext.tsx"
      via: "useSelection for listening to Preview selection changes"
      pattern: "useSelection\\(\\)"
    - from: "src/components/notebook/CaptureComponent.tsx"
      to: "src/contexts/NotebookContext.tsx"
      via: "useNotebook for loadCard function"
      pattern: "loadCard"
    - from: "src/components/notebook/CaptureComponent.tsx"
      to: "selection.lastSelectedId"
      via: "useEffect dependency that triggers card loading"
      pattern: "useEffect.*selection\\.lastSelectedId"
---

<objective>
Implement scroll-to-card navigation from Preview to Capture (SYNC-02).

Purpose: When a user clicks a card/node in Preview (NetworkGraph or Timeline), the Capture editor should automatically load and display that card's content. This creates a seamless cross-canvas workflow where selection in Preview drives content display in Capture.

Output: CaptureComponent that reacts to selection changes from Preview tabs, loading the selected card into the TipTap editor with auto-save of current work.

Note: Plan 02 completes SYNC-03 (selection highlighting across canvases). This plan focuses solely on SYNC-02 (loading card content in Capture when Preview selection changes).
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/46-live-data-synchronization/46-RESEARCH.md

# Source files
@src/state/SelectionContext.tsx
@src/components/notebook/CaptureComponent.tsx
@src/contexts/NotebookContext.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add loadCard function to NotebookContext</name>
  <files>
    src/contexts/NotebookContext.tsx
  </files>
  <action>
Add a loadCard function that loads a specific card by ID into the TipTap editor.

1. **Read existing NotebookContext to understand current structure:**
   - Check for existing setActiveCard or similar function
   - Identify how activeCard state is managed
   - Understand the current TipTap editor integration

2. **Add loadCard function to NotebookContext:**
   ```typescript
   // Add to NotebookContextValue interface
   loadCard: (cardId: string) => Promise<void>;

   // Add implementation in provider
   const loadCard = useCallback(async (cardId: string) => {
     // Query card from database
     const result = execute(`
       SELECT nc.*, n.name, n.content
       FROM notebook_cards nc
       LEFT JOIN nodes n ON nc.node_id = n.id
       WHERE nc.node_id = ? OR nc.id = ?
       LIMIT 1
     `, [cardId, cardId]);

     if (result && result.length > 0) {
       const card = result[0];
       setActiveCard({
         id: card.id,
         nodeId: card.node_id,
         cardType: card.card_type,
         markdownContent: card.markdown_content || card.content,
         // ... other fields as needed
       });
     }
   }, [execute, setActiveCard]);
   ```

3. **If NotebookContext already has card loading logic:**
   - Reuse existing patterns
   - Ensure the function is memoized with useCallback
   - Ensure it's exported in the context value

4. **Export loadCard in context value:**
   ```typescript
   const value = useMemo(() => ({
     // ... existing fields
     loadCard,
   }), [/* dependencies */]);
   ```

The goal is having a function we can call when selection changes to load that card.
  </action>
  <verify>
    - `npm run typecheck` passes
    - loadCard function exists in NotebookContext
    - useNotebook() hook returns loadCard function
  </verify>
  <done>
    - loadCard function available via useNotebook() hook
    - Function queries card by ID and updates activeCard state
    - Function is properly memoized with useCallback
  </done>
</task>

<task type="auto">
  <name>Task 2: Connect CaptureComponent to SelectionContext for SYNC-02</name>
  <files>
    src/components/notebook/CaptureComponent.tsx
  </files>
  <action>
Add a useEffect to CaptureComponent that loads the selected card when selection changes from Preview.

Follow the research-recommended pattern from 46-RESEARCH.md (lines 412-427):

1. **Add import for useSelection:**
   ```typescript
   import { useSelection } from '../../state/SelectionContext';
   ```

2. **Get selection state and loadCard:**
   ```typescript
   const { selection } = useSelection();
   const { loadCard, activeCard, isDirty, saveNow } = useNotebook();
   ```

3. **Add useEffect to react to selection changes (SYNC-02):**
   ```typescript
   // SYNC-02: When user clicks card in Preview, load it in Capture
   useEffect(() => {
     const selectedId = selection.lastSelectedId;
     if (!selectedId) return;

     // Don't reload if this is the current card
     if (activeCard?.id === selectedId || activeCard?.nodeId === selectedId) {
       return;
     }

     // Auto-save current card before loading new one (if dirty)
     if (isDirty) {
       saveNow().then(() => {
         loadCard(selectedId);
       });
     } else {
       loadCard(selectedId);
     }
   }, [selection.lastSelectedId, activeCard?.id, activeCard?.nodeId, isDirty, saveNow, loadCard]);
   ```

4. **Add TipTap scroll behavior after load:**
   If the editor has scrollable content, scroll to top after loading:
   ```typescript
   // In useEffect or as part of loadCard callback:
   editor?.commands.focus('start');
   ```

5. **Add documentation comment:**
   ```typescript
   // SYNC-02: Scroll-to-card navigation
   // When user clicks card in Preview (NetworkGraph, Timeline), load it here
   // Current work auto-saves before switching cards
   // Note: SYNC-03 (selection highlighting) is handled by Plan 02
   ```

IMPORTANT: This useEffect only reacts to selection changes. It does NOT update
selection when loading a card (that would be SYNC-03 which Plan 02 handles).
  </action>
  <verify>
    - `npm run typecheck` passes
    - CaptureComponent imports useSelection
    - CaptureComponent has useEffect that depends on selection.lastSelectedId
    - No infinite loops when clicking between canvases
  </verify>
  <done>
    - CaptureComponent loads card when Preview selection changes
    - SYNC-02: User clicks card in Preview and Capture shows it
    - Current work is preserved via auto-save before switch
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Run `npm run typecheck` - must pass
2. Run `npm run dev`
3. Manual integration test:
   - Open app with some cards in the database
   - View Network Graph in Preview
   - Click a node
   - Verify Capture editor loads and displays that card's content
   - Edit the card in Capture (make a change)
   - Click a different node in Network Graph
   - Verify the edit was auto-saved before loading new card
   - Verify new card is now displayed
4. Test with Timeline tab as well (if available)
5. Verify no console errors about selection or infinite loops
</verification>

<success_criteria>
- loadCard function available in NotebookContext
- CaptureComponent listens to selection.lastSelectedId via useEffect
- Clicking card in Preview loads its content in Capture editor
- Current work is auto-saved before switching cards
- No infinite loops between canvases
- SYNC-02: User clicks card in Preview and Capture shows it
</success_criteria>

<output>
After completion, create `.planning/phases/46-live-data-synchronization/46-03-SUMMARY.md`
</output>
