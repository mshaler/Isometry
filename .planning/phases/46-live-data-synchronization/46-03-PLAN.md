---
phase: 46-live-data-synchronization
plan: 03
type: execute
wave: 2
depends_on: ["46-02"]
files_modified:
  - src/components/notebook/CaptureComponent.tsx
  - src/hooks/ui/useTipTapEditor.ts
  - src/contexts/NotebookContext.tsx
autonomous: true

must_haves:
  truths:
    - "User clicks card in Preview and Capture scrolls to show it (SYNC-02)"
    - "TipTap editor loads and displays the selected card content"
    - "Bidirectional navigation works: Preview selection updates Capture view"
  artifacts:
    - path: "src/components/notebook/CaptureComponent.tsx"
      provides: "Capture component with selection-driven card loading"
      contains: "useSelection"
    - path: "src/hooks/ui/useTipTapEditor.ts"
      provides: "TipTap hook with card loading capability"
      exports: ["useTipTapEditor"]
  key_links:
    - from: "src/components/notebook/CaptureComponent.tsx"
      to: "src/state/SelectionContext.tsx"
      via: "useSelection for listening to Preview selection changes"
      pattern: "useSelection\\(\\)"
    - from: "src/components/notebook/CaptureComponent.tsx"
      to: "src/hooks/ui/useTipTapEditor.ts"
      via: "loadCard function to display selected card"
      pattern: "loadCard|setActiveCard"
---

<objective>
Implement bidirectional navigation from Preview to Capture (SYNC-02).

Purpose: When a user clicks a card/node in Preview, the Capture editor should automatically load and display that card. This creates a seamless cross-canvas workflow where selection in one place affects the view in another.

Output: CaptureComponent that reacts to selection changes from Preview tabs, loading the selected card into the TipTap editor.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/46-live-data-synchronization/46-RESEARCH.md
@.planning/phases/46-live-data-synchronization/46-02-SUMMARY.md

# Source files
@src/state/SelectionContext.tsx
@src/components/notebook/CaptureComponent.tsx
@src/hooks/ui/useTipTapEditor.ts
@src/contexts/NotebookContext.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add loadCard capability to NotebookContext or useTipTapEditor</name>
  <files>
    src/contexts/NotebookContext.tsx
    src/hooks/ui/useTipTapEditor.ts
  </files>
  <action>
Add the ability to load a specific card by ID, making the TipTap editor display it.

1. **Check existing NotebookContext for setActiveCard:**
   - Read `src/contexts/NotebookContext.tsx`
   - Look for a `setActiveCard` or similar function
   - If it exists, check if it loads the card content into TipTap

2. **Check useTipTapEditor for card loading:**
   - Read `src/hooks/ui/useTipTapEditor.ts`
   - Look for how `activeCard` is set and how content is loaded
   - Identify the pattern for loading a new card

3. **If loadCard function doesn't exist, add it:**
   In NotebookContext.tsx:
   ```typescript
   // Add to context value interface
   interface NotebookContextValue {
     // ... existing fields
     loadCard: (cardId: string) => Promise<void>;
   }

   // Add implementation
   const loadCard = useCallback(async (cardId: string) => {
     // Query card from database
     const result = execute(`
       SELECT nc.*, n.name
       FROM notebook_cards nc
       LEFT JOIN nodes n ON nc.node_id = n.id
       WHERE nc.node_id = ? OR nc.id = ?
       LIMIT 1
     `, [cardId, cardId]);

     if (result && result.length > 0) {
       const card = result[0];
       setActiveCard({
         id: card.id,
         nodeId: card.node_id,
         cardType: card.card_type,
         markdownContent: card.markdown_content,
         // ... other fields
       });
     }
   }, [execute, setActiveCard]);
   ```

4. **If useTipTapEditor manages content loading:**
   - The editor hook may already have a mechanism to load content
   - Check if it listens to activeCard changes from NotebookContext
   - If so, we just need to call setActiveCard with the right card

5. **Export the loadCard function:**
   - Ensure it's available from useNotebook() hook

The goal is having a function we can call when selection changes to load that card.
  </action>
  <verify>
    - `npm run typecheck` passes
    - loadCard function exists and can be called with a cardId
    - Calling loadCard updates the TipTap editor content
  </verify>
  <done>
    - Card loading capability available via NotebookContext or useTipTapEditor
    - Function loads card content from database and displays in editor
  </done>
</task>

<task type="auto">
  <name>Task 2: Connect CaptureComponent to SelectionContext for card loading</name>
  <files>
    src/components/notebook/CaptureComponent.tsx
  </files>
  <action>
Add a useEffect to CaptureComponent that loads the card when selection changes from Preview.

1. **Add import for useSelection:**
   ```typescript
   import { useSelection } from '../../state/SelectionContext';
   ```

2. **Get selection state:**
   ```typescript
   const { selection } = useSelection();
   ```

3. **Add useEffect to react to selection changes:**
   ```typescript
   // SYNC-02: When user clicks card in Preview, load it in Capture
   useEffect(() => {
     const selectedId = selection.lastSelectedId;
     if (!selectedId) return;

     // Don't reload if this is the current card
     if (activeCard?.id === selectedId || activeCard?.nodeId === selectedId) {
       return;
     }

     // Auto-save current card before loading new one (if dirty)
     if (isDirty) {
       saveNow().then(() => {
         loadCard(selectedId);
       });
     } else {
       loadCard(selectedId);
     }
   }, [selection.lastSelectedId, activeCard?.id, activeCard?.nodeId, isDirty, saveNow, loadCard]);
   ```

4. **Handle the case where loadCard is from NotebookContext:**
   ```typescript
   const { loadCard } = useNotebook();  // If loadCard is in NotebookContext
   // OR
   const { loadCard } = useTipTapEditor();  // If added to the hook
   ```

5. **Add documentation comment:**
   ```typescript
   // SYNC-02: Bidirectional navigation
   // When selection changes in Preview (NetworkGraph, Timeline), load that card here
   // Auto-saves current work before switching
   ```

6. **Consider scroll behavior:**
   - If the editor has scroll, scrolling to top after loading is good UX
   - TipTap's `editor.commands.focus('start')` can help

NOTE: Be careful about infinite loops. The loadCard function should NOT trigger a selection
change, or if it does, we need to track "source" to avoid ping-pong.
  </action>
  <verify>
    - `npm run typecheck` passes
    - CaptureComponent reacts to selection.lastSelectedId changes
    - Clicking a node in NetworkGraph loads that card in Capture
    - Current card is auto-saved before switching
  </verify>
  <done>
    - CaptureComponent loads card when Preview selection changes
    - SYNC-02: User clicks card in Preview and Capture shows it
    - Current work is preserved via auto-save before switch
  </done>
</task>

<task type="auto">
  <name>Task 3: Add selection source tracking to prevent loops</name>
  <files>
    src/state/SelectionContext.tsx
    src/components/notebook/CaptureComponent.tsx
  </files>
  <action>
Add source tracking to selection to prevent infinite loops between canvases.

1. **Update SelectionState interface:**
   ```typescript
   interface SelectionState {
     selectedIds: Set<string>;
     lastSelectedId: string | null;
     source: 'capture' | 'preview' | 'shell' | null;  // NEW
   }
   ```

2. **Update select function to accept source:**
   ```typescript
   const select = useCallback((id: string, source: 'capture' | 'preview' | 'shell' = 'preview') => {
     setSelection(() => ({
       selectedIds: new Set([id]),
       lastSelectedId: id,
       source,
     }));
   }, []);
   ```

3. **Update NetworkGraphTab to pass source:**
   ```typescript
   const handleNodeClick = useCallback((nodeId: string) => {
     select(nodeId, 'preview');  // Explicitly from preview
   }, [select]);
   ```

4. **Update CaptureComponent to check source:**
   ```typescript
   useEffect(() => {
     const selectedId = selection.lastSelectedId;
     // Only react to selection changes from Preview, not from Capture itself
     if (!selectedId || selection.source === 'capture') {
       return;
     }
     // ... load card logic
   }, [selection.lastSelectedId, selection.source, ...]);
   ```

5. **Update TimelineTab similarly:**
   - Pass 'preview' as source when selecting

This prevents the loop: Preview selects → Capture loads → Capture selects → Preview re-selects...

Alternative: Use a ref to track "last loaded card ID" and skip if already loaded.
  </action>
  <verify>
    - `npm run typecheck` passes
    - Selection changes from Preview trigger Capture load
    - Selection changes from Capture do NOT trigger Capture load
    - No infinite loops when clicking between canvases
  </verify>
  <done>
    - Selection source tracking prevents infinite loops
    - Cross-canvas navigation is one-way per action
    - SYNC-02 complete without side effects
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Run `npm run typecheck` - must pass
2. Run `npm run dev`
3. Manual integration test:
   - Open app with some cards in the database
   - View Network Graph in Preview
   - Click a node
   - Verify Capture editor loads and displays that card's content
   - Edit the card in Capture (make a change)
   - Click a different node in Network Graph
   - Verify the edit was auto-saved before loading new card
   - Verify new card is now displayed
4. Test with Timeline tab as well
5. Verify no console errors about selection loops
</verification>

<success_criteria>
- loadCard function available and working
- CaptureComponent listens to selection changes from Preview
- Clicking card in Preview loads it in Capture editor
- Current work is auto-saved before switching cards
- No infinite loops between canvases
- SYNC-02: User clicks card in Preview and Capture scrolls to show it
</success_criteria>

<output>
After completion, create `.planning/phases/46-live-data-synchronization/46-03-SUMMARY.md`
</output>
