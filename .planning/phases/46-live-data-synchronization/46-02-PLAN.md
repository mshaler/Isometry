---
phase: 46-live-data-synchronization
plan: 02
type: execute
wave: 2
depends_on: ["46-01"]
files_modified:
  - src/hooks/sync/useDataChangeListener.ts
  - src/hooks/sync/index.ts
  - src/components/notebook/preview-tabs/NetworkGraphTab.tsx
  - src/components/notebook/preview-tabs/TimelineTab.tsx
  - src/components/notebook/preview-tabs/DataInspectorTab.tsx
autonomous: true

must_haves:
  truths:
    - "User sees Preview auto-refresh when Capture saves a card (SYNC-01)"
    - "NetworkGraphTab re-queries and re-renders when nodes/edges change"
    - "TimelineTab re-queries and re-renders when nodes change"
    - "DataInspectorTab shows latest data on refresh trigger"
  artifacts:
    - path: "src/hooks/sync/useDataChangeListener.ts"
      provides: "React hook for subscribing to data change events"
      exports: ["useDataChangeListener", "DataChangeListenerOptions"]
      min_lines: 40
    - path: "src/hooks/sync/index.ts"
      provides: "Barrel export for sync hooks"
      exports: ["useDataChangeListener"]
  key_links:
    - from: "src/components/notebook/preview-tabs/NetworkGraphTab.tsx"
      to: "src/hooks/sync/useDataChangeListener.ts"
      via: "useDataChangeListener call with table filter"
      pattern: "useDataChangeListener.*tables.*nodes"
    - from: "src/components/notebook/preview-tabs/TimelineTab.tsx"
      to: "src/hooks/sync/useDataChangeListener.ts"
      via: "useDataChangeListener call"
      pattern: "useDataChangeListener"
---

<objective>
Implement the data change listener hook and integrate it into Preview tabs for automatic refresh when data changes.

Purpose: Enable SYNC-01 - Preview auto-refreshes when Capture saves a card, providing seamless cross-canvas data synchronization without manual refresh buttons.

Output: useDataChangeListener hook with debouncing and table filtering, integrated into NetworkGraphTab, TimelineTab, and DataInspectorTab.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/46-live-data-synchronization/46-RESEARCH.md
@.planning/phases/46-live-data-synchronization/46-01-SUMMARY.md

# Source files to modify
@src/components/notebook/preview-tabs/NetworkGraphTab.tsx
@src/components/notebook/preview-tabs/TimelineTab.tsx
@src/components/notebook/preview-tabs/DataInspectorTab.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useDataChangeListener hook</name>
  <files>
    src/hooks/sync/useDataChangeListener.ts
    src/hooks/sync/index.ts
  </files>
  <action>
Create the React hook for subscribing to data change events with proper cleanup.

1. Create directory: `src/hooks/sync/`

2. Create `src/hooks/sync/useDataChangeListener.ts`:
   - Import `useEffect`, `useRef` from 'react'
   - Import `IsometryEventBus`, `DataChangeEvent` from '@/services/sync'
   - Define `DataChangeListenerOptions` interface:
     - `tables?: Array<'nodes' | 'edges' | 'notebook_cards' | 'facets'>` - filter by table
     - `operations?: Array<'INSERT' | 'UPDATE' | 'DELETE'>` - filter by operation
     - `debounceMs?: number` - debounce delay (default: 100)
     - `enabled?: boolean` - enable/disable listener (default: true)
   - Implement `useDataChangeListener(callback, options)`:
     - Use `useRef` to store latest callback (avoids stale closure issues)
     - Update callback ref in useEffect when callback changes
     - Main useEffect:
       - Return early if `enabled` is false
       - Create handler function that:
         - Filters by tables if specified (skip if event.table not in list)
         - Filters by operations if specified
         - If debounceMs > 0, use setTimeout with clearTimeout on debounce timer ref
         - Calls `callbackRef.current(event)`
       - Subscribe via `IsometryEventBus.onDataChange(handler)`
       - Return cleanup: unsubscribe + clear any pending debounce timer
     - Dependencies: [tables, operations, debounceMs, enabled] (serialize tables/operations for deps)

3. Create `src/hooks/sync/index.ts`:
   - Export everything from './useDataChangeListener'

CRITICAL: Use useRef for callback to avoid stale closures. The callback may reference external state that changes.
CRITICAL: Clear debounce timer on cleanup to prevent memory leaks and calls after unmount.
  </action>
  <verify>
    - `npm run typecheck` passes
    - Hook can be imported: `import { useDataChangeListener } from '@/hooks/sync'`
    - No lint errors in new files
  </verify>
  <done>
    - useDataChangeListener hook exists with proper subscription lifecycle
    - Debouncing prevents excessive re-renders on rapid changes
    - Table and operation filtering work correctly
    - Cleanup removes listener and clears timers
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate data change listener into Preview tabs</name>
  <files>
    src/components/notebook/preview-tabs/NetworkGraphTab.tsx
    src/components/notebook/preview-tabs/TimelineTab.tsx
    src/components/notebook/preview-tabs/DataInspectorTab.tsx
  </files>
  <action>
Add data change listeners to Preview tabs to enable automatic refresh on data changes.

1. Modify `src/components/notebook/preview-tabs/NetworkGraphTab.tsx`:
   - Add import: `import { useDataChangeListener } from '@/hooks/sync'`
   - Add state: `const [refreshKey, setRefreshKey] = useState(0)`
   - Add data change listener after existing hooks:
     ```typescript
     useDataChangeListener(
       () => setRefreshKey(prev => prev + 1),
       {
         tables: ['nodes', 'edges'],
         debounceMs: 200, // Debounce rapid changes
       }
     );
     ```
   - In the `useForceGraph` call, add `refreshKey` to trigger re-fetch:
     - Pass it as a new option if the hook supports it, OR
     - Add `refreshKey` to the dependency array of the useMemo that processes data, OR
     - If useForceGraph doesn't support refresh, add a key prop to force remount

   NOTE: Look at how useForceGraph is implemented. If it accepts a refresh trigger, use that.
   If not, the simplest approach is to add refreshKey to existing state that triggers re-query.

2. Modify `src/components/notebook/preview-tabs/TimelineTab.tsx`:
   - Add import: `import { useDataChangeListener } from '@/hooks/sync'`
   - The hook already has a `refresh` function returned from `useTimeline`
   - Add data change listener:
     ```typescript
     useDataChangeListener(
       () => refresh(),
       {
         tables: ['nodes'],
         debounceMs: 200,
       }
     );
     ```

3. Modify `src/components/notebook/preview-tabs/DataInspectorTab.tsx`:
   - Add import: `import { useDataChangeListener } from '@/hooks/sync'`
   - The hook has `runQuery` function from `useDataInspector`
   - Add data change listener that triggers re-query if there's an active query:
     ```typescript
     useDataChangeListener(
       () => {
         // Only re-run if there's an active query with results
         if (result) {
           runQuery();
         }
       },
       {
         tables: ['nodes', 'edges', 'notebook_cards', 'facets'],
         debounceMs: 300, // Slightly longer debounce for SQL queries
       }
     );
     ```

IMPORTANT: Check existing hook implementations to understand best integration approach.
The goal is minimal changes - just wire up the listener to trigger existing refresh mechanisms.
  </action>
  <verify>
    - `npm run typecheck` passes
    - `npm run dev` starts without errors
    - Manual test: Open app with Preview visible, save a card in Capture, verify Preview updates
  </verify>
  <done>
    - NetworkGraphTab auto-refreshes when nodes/edges change in database
    - TimelineTab auto-refreshes when nodes change
    - DataInspectorTab re-runs active query when any data table changes
    - SYNC-01 requirement satisfied: Preview auto-refresh on Capture save
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. Run `npm run typecheck` - must pass
2. Run `npm run dev`
3. Manual integration test:
   - Open the application
   - Navigate to have Preview visible (Network Graph tab)
   - Create or edit a card in Capture
   - Verify Network Graph updates without manual refresh
   - Switch to Timeline tab, edit a card
   - Verify Timeline updates
4. Check browser console for any errors or warnings
</verification>

<success_criteria>
- useDataChangeListener hook provides clean subscription API
- Debouncing prevents performance issues on rapid changes
- NetworkGraphTab, TimelineTab, DataInspectorTab auto-refresh on data changes
- No memory leaks (listeners cleaned up on unmount)
- No TypeScript errors, application functions normally
- SYNC-01: User sees Preview auto-refresh when Capture saves a card
</success_criteria>

<output>
After completion, create `.planning/phases/46-live-data-synchronization/46-02-SUMMARY.md`
</output>
