---
phase: 46-live-data-synchronization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/sync/event-bus.ts
  - src/services/sync/sql-change-tracker.ts
  - src/services/sync/types.ts
  - src/services/sync/index.ts
  - src/db/init.ts
autonomous: true

must_haves:
  truths:
    - "Data changes in sql.js dispatch CustomEvents on window"
    - "Event bus provides type-safe subscribe/dispatch API"
    - "sql.js updateHook triggers event on INSERT/UPDATE/DELETE to data tables"
  artifacts:
    - path: "src/services/sync/event-bus.ts"
      provides: "IsometryEventBus class with dispatch/subscribe methods"
      exports: ["IsometryEventBus", "DataChangeEvent", "SelectionChangeEvent"]
      min_lines: 40
    - path: "src/services/sync/sql-change-tracker.ts"
      provides: "enableChangeTracking function for sql.js"
      exports: ["enableChangeTracking"]
      min_lines: 30
    - path: "src/services/sync/types.ts"
      provides: "TypeScript interfaces for sync events"
      exports: ["DataChangeEvent", "SelectionChangeEvent", "SyncEventType"]
    - path: "src/db/init.ts"
      provides: "Updated initDatabase with change tracking enabled"
      contains: "enableChangeTracking"
  key_links:
    - from: "src/db/init.ts"
      to: "src/services/sync/sql-change-tracker.ts"
      via: "enableChangeTracking(db) call after initialization"
      pattern: "enableChangeTracking\\(.*db"
    - from: "src/services/sync/sql-change-tracker.ts"
      to: "src/services/sync/event-bus.ts"
      via: "IsometryEventBus.dispatchDataChange call in updateHook"
      pattern: "IsometryEventBus\\.dispatchDataChange"
---

<objective>
Create the event bus foundation and sql.js change tracking infrastructure for live data synchronization.

Purpose: Establish the publish-subscribe communication layer that enables Preview tabs to auto-refresh when Capture saves data, without tight component coupling or prop drilling.

Output: Event bus service, SQL change tracker, and integrated database initialization with change tracking enabled.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/46-live-data-synchronization/46-RESEARCH.md

# Source files to modify
@src/db/init.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create sync types and event bus service</name>
  <files>
    src/services/sync/types.ts
    src/services/sync/event-bus.ts
    src/services/sync/index.ts
  </files>
  <action>
Create the sync directory structure and implement the type-safe event bus.

1. Create `src/services/sync/types.ts`:
   - Define `DataChangeEvent` interface with fields:
     - `table`: 'nodes' | 'edges' | 'notebook_cards' | 'facets'
     - `operation`: 'INSERT' | 'UPDATE' | 'DELETE'
     - `rowid`: number
     - `nodeId`: string | undefined (optional, for convenience)
     - `timestamp`: Date
   - Define `SelectionChangeEvent` interface with fields:
     - `cardId`: string
     - `source`: 'capture' | 'preview' | 'shell'
   - Export `SyncEventType` as union of 'isometry:data-change' | 'isometry:selection-change'

2. Create `src/services/sync/event-bus.ts`:
   - Import types from './types'
   - Implement `IsometryEventBus` class with static methods:
     - `dispatchDataChange(event: DataChangeEvent): void` - dispatches CustomEvent('isometry:data-change')
     - `dispatchSelectionChange(event: SelectionChangeEvent): void` - dispatches CustomEvent('isometry:selection-change')
     - `onDataChange(handler: (event: DataChangeEvent) => void): () => void` - returns cleanup function
     - `onSelectionChange(handler: (event: SelectionChangeEvent) => void): () => void` - returns cleanup function
   - Use private static constants for event names to avoid typos
   - Set `bubbles: false` on CustomEvents (global events, no bubbling needed)
   - Each subscribe method returns cleanup function that calls removeEventListener

3. Create `src/services/sync/index.ts`:
   - Re-export all types from './types'
   - Re-export IsometryEventBus from './event-bus'
  </action>
  <verify>
    - `npm run typecheck` passes
    - Files exist at specified paths
    - Event bus can be imported: `import { IsometryEventBus, DataChangeEvent } from '@/services/sync'`
  </verify>
  <done>
    - Event bus service exists with type-safe dispatch/subscribe methods
    - Types are exported and can be imported throughout codebase
    - No TypeScript errors in new files
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SQL change tracker and integrate with database initialization</name>
  <files>
    src/services/sync/sql-change-tracker.ts
    src/db/init.ts
  </files>
  <action>
Create the SQL change tracking service and integrate it with database initialization.

1. Create `src/services/sync/sql-change-tracker.ts`:
   - Import `Database` type from 'sql.js'
   - Import `IsometryEventBus` from './event-bus'
   - Implement `enableChangeTracking(db: Database): void` function:
     - Check if `updateHook` method exists on db instance: `if ('updateHook' in db && typeof db.updateHook === 'function')`
     - If available, call `db.updateHook()` with callback that:
       - Maps SQLite action codes to operations: 9=DELETE, 18=INSERT, 23=UPDATE
       - Filters to only track tables: 'nodes', 'edges', 'notebook_cards', 'facets'
       - Uses `setTimeout(..., 0)` to defer event dispatch (CRITICAL: avoids blocking transaction)
       - Dispatches via `IsometryEventBus.dispatchDataChange()`
     - If updateHook not available, log warning via devLogger: "sql.js updateHook not available. Live sync requires sql.js v1.13+"
   - Export `enableChangeTracking`

2. Update `src/services/sync/index.ts`:
   - Add re-export: `export { enableChangeTracking } from './sql-change-tracker'`

3. Modify `src/db/init.ts`:
   - Add import: `import { enableChangeTracking } from '@/services/sync'`
   - In `initDatabase()` function, after `dbInstance = new SQL.Database()` and schema loading but BEFORE returning:
     - Call `enableChangeTracking(dbInstance)`
   - This ensures change tracking is active from the moment the database is ready
   - The devLogger.info call at end should now include `changeTracking: true` in the metadata object

Note: The sql.js package used (sql.js-fts5 or standard sql.js v1.13+) may have different updateHook API.
If type errors occur with updateHook, use type assertion: `(db as any).updateHook(...)` with a comment explaining why.
  </action>
  <verify>
    - `npm run typecheck` passes
    - `npm run dev` starts without errors
    - Console shows "sql.js database initialized" log with changeTracking info
    - If updateHook unavailable, warning is logged (acceptable - fallback can be added later)
  </verify>
  <done>
    - SQL change tracker integrates with sql.js via updateHook API
    - Database initialization enables change tracking automatically
    - INSERT/UPDATE/DELETE to data tables dispatch 'isometry:data-change' events
    - Events are dispatched asynchronously (via setTimeout) to avoid blocking transactions
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. Run `npm run typecheck` - must pass with zero errors
2. Run `npm run dev` and check browser console for database init log
3. Manually test event dispatch by running in browser console:
   ```javascript
   // Add listener
   window.addEventListener('isometry:data-change', (e) => console.log('Data changed:', e.detail));

   // This should trigger after any INSERT/UPDATE/DELETE via the application
   ```
</verification>

<success_criteria>
- Event bus service provides type-safe publish/subscribe API
- SQL change tracker wraps sql.js updateHook API
- Database initialization enables change tracking by default
- Events dispatch asynchronously on data changes
- No TypeScript errors, application starts normally
</success_criteria>

<output>
After completion, create `.planning/phases/46-live-data-synchronization/46-01-SUMMARY.md`
</output>
