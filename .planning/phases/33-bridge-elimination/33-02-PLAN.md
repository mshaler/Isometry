---
phase: 33-bridge-elimination
plan: 02
type: execute
wave: 2
depends_on: [33-01]
files_modified: [src/d3/index.ts, src/d3/SuperGrid.ts, src/d3/__tests__/SuperGrid.test.ts]
autonomous: true

must_haves:
  truths:
    - "D3.js queries sql.js directly with zero serialization overhead"
    - "Data binding uses same memory space for cards array"
    - "SuperGrid renders live data from DatabaseService"
    - "No bridge API calls in D3.js visualization code"
  artifacts:
    - path: "src/d3/SuperGrid.ts"
      provides: "D3.js grid renderer with direct sql.js access"
      exports: ["SuperGrid"]
      min_lines: 80
    - path: "src/d3/__tests__/SuperGrid.test.ts"
      provides: "TDD tests for D3-sql.js integration"
      contains: "DatabaseService"
  key_links:
    - from: "SuperGrid.render"
      to: "DatabaseService.query"
      via: "direct synchronous call"
      pattern: "this\\.db\\.query"
    - from: "d3.selectAll().data()"
      to: "cards array"
      via: "same memory space binding"
      pattern: "\\.data\\(cards"
---

<objective>
Establish D3.js direct data access pattern using sql.js with zero serialization overhead.

Purpose: Prove the core architecture change - D3.js visualization getting data directly from sql.js in the same memory space, eliminating the MessageBridge entirely. This validates the fundamental assumption of the bridge elimination architecture.

Output: Working SuperGrid component that renders live data from DatabaseService without any bridge calls.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/33-bridge-elimination/33-01-SUMMARY.md
@docs/specs/v4 specs/BRIDGE-ELIMINATION-ARCHITECTURE.md
@src/db/DatabaseService.ts
@CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Create SuperGrid with direct sql.js data binding</name>
  <files>src/d3/SuperGrid.ts</files>
  <action>
    Create SuperGrid D3.js renderer with direct DatabaseService access following CLAUDE.md patterns:

    ```typescript
    import * as d3 from 'd3';
    import { DatabaseService } from '../db/DatabaseService';

    export class SuperGrid {
      private db: DatabaseService;
      private container: d3.Selection<SVGElement, unknown, null, undefined>;

      constructor(container: SVGElement, db: DatabaseService) {
        this.db = db;
        this.container = d3.select(container);
      }

      render(filters: Record<string, any> = {}): void {
        // Direct synchronous query - core CLAUDE.md requirement
        const cards = this.db.query<{id: string, name: string, x?: number, y?: number}>(
          "SELECT id, name, x, y FROM nodes WHERE deleted_at IS NULL ORDER BY modified_at DESC",
          []
        );

        // D3.js data binding in same memory space - zero serialization
        const selection = this.container
          .selectAll(".card")
          .data(cards, d => d.id); // Key function required per CLAUDE.md

        // Enter/update/exit pattern
        selection.join(
          enter => enter.append("rect")
            .attr("class", "card")
            .attr("x", d => d.x || 0)
            .attr("y", d => d.y || 0)
            .attr("width", 100)
            .attr("height", 60),
          update => update
            .attr("x", d => d.x || 0)
            .attr("y", d => d.y || 0),
          exit => exit.remove()
        );

        // Text labels
        const labels = this.container
          .selectAll(".label")
          .data(cards, d => d.id);

        labels.join(
          enter => enter.append("text")
            .attr("class", "label")
            .attr("x", d => (d.x || 0) + 5)
            .attr("y", d => (d.y || 0) + 15)
            .text(d => d.name),
          update => update
            .attr("x", d => (d.x || 0) + 5)
            .attr("y", d => (d.y || 0) + 15)
            .text(d => d.name),
          exit => exit.remove()
        );
      }
    }
    ```

    Key requirements from CLAUDE.md:
    - Always use .join() with key functions (d => d.id)
    - Direct synchronous db.query() calls (no promises)
    - Same memory space data binding (cards array directly to D3)
    - No bridge API calls anywhere
    - Proper enter/update/exit patterns

    Anti-patterns to avoid:
    - Manual enter/update/exit without .join()
    - Missing key functions in data binding
    - Any async/await in render methods
    - Bridge or API calls for data
  </action>
  <verify>grep -E "db\.query.*SELECT|\.data\(cards|\.join\(" src/d3/SuperGrid.ts</verify>
  <done>SuperGrid exists with direct sql.js queries and proper D3.js data binding patterns</done>
</task>

<task type="auto">
  <name>Write TDD tests for D3-sql.js integration</name>
  <files>src/d3/__tests__/SuperGrid.test.ts</files>
  <action>
    Write tests verifying D3.js works with DatabaseService following TDD methodology:

    ```typescript
    import { SuperGrid } from '../SuperGrid';
    import { DatabaseService } from '../../db/DatabaseService';
    import * as d3 from 'd3';

    describe('SuperGrid D3-sql.js Integration', () => {
      let db: DatabaseService;
      let svg: SVGElement;
      let grid: SuperGrid;

      beforeEach(async () => {
        // Setup test database
        db = new DatabaseService();
        await db.initialize();

        // Create test schema
        db.run(`
          CREATE TABLE IF NOT EXISTS nodes (
            id TEXT PRIMARY KEY,
            name TEXT NOT NULL,
            x INTEGER,
            y INTEGER,
            deleted_at TEXT
          )
        `);

        // Setup SVG container
        document.body.innerHTML = '<svg id="test-svg"></svg>';
        svg = document.getElementById('test-svg') as SVGElement;
        grid = new SuperGrid(svg, db);
      });

      it('renders cards from direct sql.js query', () => {
        // Insert test data
        db.run("INSERT INTO nodes (id, name, x, y) VALUES (?, ?, ?, ?)",
          ['n1', 'Test Card', 10, 20]);
        db.run("INSERT INTO nodes (id, name, x, y) VALUES (?, ?, ?, ?)",
          ['n2', 'Second Card', 30, 40]);

        // Render grid
        grid.render();

        // Verify D3 elements created
        const cards = d3.select(svg).selectAll('.card');
        expect(cards.size()).toBe(2);

        const labels = d3.select(svg).selectAll('.label');
        expect(labels.size()).toBe(2);
      });

      it('uses synchronous data access (no promises)', () => {
        // Test that render() is synchronous
        const startTime = performance.now();
        grid.render();
        const endTime = performance.now();

        // Should complete in microseconds, not milliseconds
        expect(endTime - startTime).toBeLessThan(10);
      });

      it('updates data reactively with database changes', () => {
        // Initial render
        db.run("INSERT INTO nodes (id, name, x, y) VALUES (?, ?, ?, ?)",
          ['n1', 'Initial Card', 10, 20]);
        grid.render();

        let cards = d3.select(svg).selectAll('.card');
        expect(cards.size()).toBe(1);

        // Add another card and re-render
        db.run("INSERT INTO nodes (id, name, x, y) VALUES (?, ?, ?, ?)",
          ['n2', 'New Card', 30, 40]);
        grid.render();

        cards = d3.select(svg).selectAll('.card');
        expect(cards.size()).toBe(2);
      });

      it('filters data via SQL WHERE clauses', () => {
        // Insert test data
        db.run("INSERT INTO nodes (id, name, x, y) VALUES (?, ?, ?, ?)",
          ['n1', 'Active Card', 10, 20]);
        db.run("INSERT INTO nodes (id, name, x, y, deleted_at) VALUES (?, ?, ?, ?, ?)",
          ['n2', 'Deleted Card', 30, 40, '2024-01-01']);

        grid.render();

        // Should only render non-deleted cards
        const cards = d3.select(svg).selectAll('.card');
        expect(cards.size()).toBe(1);

        const cardData = cards.data();
        expect(cardData[0]).toMatchObject({id: 'n1', name: 'Active Card'});
      });
    }
    ```

    Tests verify:
    1. Direct sql.js to D3.js data flow (no bridge)
    2. Synchronous operation (sub-10ms render times)
    3. Reactive updates (re-render after data changes)
    4. SQL filtering (WHERE clauses work properly)
    5. D3.js .join() patterns with key functions

    Critical: Tests must prove zero serialization overhead between DatabaseService.query() and D3.js .data() binding.
  </action>
  <verify>npm run test -- SuperGrid.test.ts</verify>
  <done>SuperGrid integration tests pass, proving direct sql.js to D3.js data flow</done>
</task>

<task type="auto">
  <name>Create D3 module exports and integration</name>
  <files>src/d3/index.ts</files>
  <action>
    Create D3 module exports following CLAUDE.md structure:

    ```typescript
    /**
     * Isometry D3.js Visualization Layer
     *
     * All visualization and interaction lives here.
     * Binds directly to sql.js query results with zero serialization.
     * Implements SuperGrid, Network, Kanban, Timeline renderers.
     */

    export { SuperGrid } from './SuperGrid';

    // Future exports for complete D3 renderer family
    // export { NetworkGraph } from './NetworkGraph';
    // export { KanbanBoard } from './KanbanBoard';
    // export { TimelineView } from './TimelineView';

    /**
     * D3.js Patterns for Isometry (from CLAUDE.md)
     *
     * ALWAYS: key function in data binding
     * d3.selectAll(".card").data(cards, d => d.id)
     *
     * ALWAYS: .join() over manual enter/update/exit
     * selection.join(
     *   enter => enter.append("div").attr("class", "card"),
     *   update => update,
     *   exit => exit.remove()
     * );
     *
     * SINGLE DATA SOURCE: same cards, different projections
     * const cards = db.exec("SELECT * FROM nodes WHERE deleted_at IS NULL");
     * d3.select("#grid").selectAll(".cell").data(cards, d => d.id).join("div");
     * d3.select("#kanban").selectAll(".card").data(cards, d => d.id).join("div");
     * d3.select("#graph").selectAll(".node").data(cards, d => d.id).join("circle");
     */

    export type { D3Selection, D3ScaleOrdinal } from 'd3';
    ```

    Key points:
    - Export SuperGrid as primary renderer
    - Document D3.js patterns from CLAUDE.md
    - Reserve exports for future renderers (Network, Kanban, Timeline)
    - Include TypeScript type exports for D3
    - Emphasize zero serialization architecture
  </action>
  <verify>grep -E "export.*SuperGrid|zero serialization|data.*cards.*d.*id" src/d3/index.ts</verify>
  <done>D3 module exports created with proper documentation and SuperGrid integration</done>
</task>

</tasks>

<verification>
1. SuperGrid renders cards from direct DatabaseService queries
2. D3.js data binding uses same memory space (zero serialization)
3. All render operations are synchronous (no promises)
4. Tests verify direct sql.js to D3.js data flow
5. Key functions used in all D3.js data binding operations
6. No bridge API calls anywhere in D3 code
</verification>

<success_criteria>
- D3.js SuperGrid component queries sql.js directly without bridge
- Data binding happens in same memory space (cards array â†’ D3 selection)
- Rendering is synchronous (sub-10ms from query to DOM)
- Tests prove zero serialization overhead in data flow
- Foundation established for all future D3 renderers (Network, Kanban, Timeline)
- Bridge elimination architecture validated with working visualization
</success_criteria>

<output>
After completion, create `.planning/phases/33-bridge-elimination/33-02-SUMMARY.md`
</output>