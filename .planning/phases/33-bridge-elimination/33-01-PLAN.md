---
phase: 33-bridge-elimination
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [package.json, public/wasm/sql-wasm.wasm, src/db/DatabaseService.ts, src/db/__tests__/DatabaseService.test.ts]
autonomous: true

must_haves:
  truths:
    - "sql.js initializes with FTS5 and JSON1 support from vendored WASM"
    - "Database queries execute synchronously in same memory space as D3.js"
    - "Recursive CTEs work for graph traversal operations"
    - "WASM binary loads from local public/wasm/ directory"
  artifacts:
    - path: "public/wasm/sql-wasm.wasm"
      provides: "FTS5+JSON1 enabled SQLite WASM binary"
      contains: "FTS5"
    - path: "src/db/DatabaseService.ts"
      provides: "Core sql.js wrapper with synchronous API"
      exports: ["DatabaseService"]
      min_lines: 100
    - path: "src/db/__tests__/DatabaseService.test.ts"
      provides: "TDD tests for sql.js capabilities"
      contains: "FTS5"
  key_links:
    - from: "src/db/DatabaseService.ts"
      to: "public/wasm/sql-wasm.wasm"
      via: "initSqlJs locateFile function"
      pattern: "locateFile.*wasm"
    - from: "DatabaseService.query"
      to: "sql.js Database.exec"
      via: "direct synchronous call"
      pattern: "db\\.exec|db\\.prepare"
---

<objective>
Establish sql.js foundation with verified FTS5, JSON1, and recursive CTE capabilities using locally vendored WASM binary.

Purpose: Create the core database service that eliminates the 40KB MessageBridge by putting SQLite in the same JavaScript runtime as D3.js. This gates all subsequent SuperGrid development in Phase 2.

Output: Working DatabaseService with all sql.js capabilities verified and ready for direct D3.js data binding.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@docs/specs/v4 specs/BRIDGE-ELIMINATION-ARCHITECTURE.md
@docs/specs/v4 specs/GSD-BRIDGE-ELIMINATION-PROMPT.md
@src/db/SQLiteProvider.tsx
@CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Vendor sql.js WASM binary with FTS5+JSON1 support</name>
  <files>public/wasm/sql-wasm.wasm, package.json</files>
  <action>
    Download sql.js WASM binary with FTS5 and JSON1 extensions enabled:

    1. Create public/wasm/ directory
    2. Download FTS5-enabled WASM from https://github.com/sql-js/sql.js/releases/latest (look for sql-wasm-fts.wasm)
    3. Place as public/wasm/sql-wasm.wasm
    4. Update package.json scripts to include WASM file in build

    Critical: Must use FTS5-enabled build, not standard sql-wasm.wasm. Standard build lacks FTS5 support which gates everything per CLAUDE.md.

    Verify with: file public/wasm/sql-wasm.wasm should show WebAssembly binary
  </action>
  <verify>ls -la public/wasm/sql-wasm.wasm && file public/wasm/sql-wasm.wasm</verify>
  <done>FTS5-enabled WASM binary exists in public/wasm/ and is WebAssembly format</done>
</task>

<task type="auto">
  <name>Create DatabaseService with synchronous sql.js API</name>
  <files>src/db/DatabaseService.ts</files>
  <action>
    Create core DatabaseService class following GSD-BRIDGE-ELIMINATION-PROMPT.md pattern:

    ```typescript
    import initSqlJs, { Database } from 'sql.js';

    export class DatabaseService {
      private db: Database | null = null;
      private dirty = false;
      private saveTimer: ReturnType<typeof setTimeout> | null = null;

      async initialize(dbBytes?: ArrayBuffer): Promise<void> {
        const SQL = await initSqlJs({
          locateFile: (file: string) => `/wasm/${file.replace('sql-wasm.wasm', 'sql-wasm.wasm')}`
        });

        this.db = dbBytes ? new SQL.Database(new Uint8Array(dbBytes)) : new SQL.Database();

        // Configure pragmas
        this.db.run("PRAGMA foreign_keys = ON");
        this.db.run("PRAGMA journal_mode = MEMORY");
      }

      // Synchronous query - core CLAUDE.md requirement
      query<T>(sql: string, params?: any[]): T[] {
        // Direct query execution in same memory space as D3.js
      }

      run(sql: string, params?: any[]): void {
        // Mutation with dirty tracking
      }

      export(): Uint8Array {
        // Export for Swift file I/O
      }
    }
    ```

    Key requirements:
    - Synchronous query/run methods (no promises after initialization)
    - Direct sql.js Database access
    - Proper WASM locateFile configuration
    - Error handling with descriptive messages
    - Export capability for Swift persistence
  </action>
  <verify>grep -E "query.*sql.*params|locateFile.*wasm|synchronous" src/db/DatabaseService.ts</verify>
  <done>DatabaseService exists with synchronous API and proper WASM configuration</done>
</task>

<task type="auto">
  <name>Write TDD tests verifying sql.js capabilities</name>
  <files>src/db/__tests__/DatabaseService.test.ts</files>
  <action>
    Write comprehensive tests verifying all critical sql.js capabilities per GSD-BRIDGE-ELIMINATION-PROMPT.md:

    ```typescript
    describe('DatabaseService', () => {
      let db: DatabaseService;

      beforeEach(async () => {
        db = new DatabaseService();
        await db.initialize(); // In-memory for tests
      });

      it('verifies FTS5 support is available', () => {
        // CRITICAL: This gates everything per CLAUDE.md
        expect(() => db.query("SELECT fts5_version()")).not.toThrow();
        const version = db.query<{fts5_version: string}>("SELECT fts5_version()");
        expect(version[0].fts5_version).toMatch(/^\d+\.\d+\.\d+$/);
      });

      it('executes recursive CTEs for graph traversal', () => {
        // Setup test data and verify recursive CTE execution
        // This gates graph queries per CLAUDE.md
      });

      it('performs synchronous CRUD operations', () => {
        // Test synchronous query/run methods
      });

      it('exports database as bytes for Swift persistence', () => {
        // Test export capability
      });
    }
    ```

    Tests must verify:
    1. FTS5 support (SELECT fts5_version() works)
    2. JSON1 support (SELECT json('{}') works)
    3. Recursive CTE support (WITH RECURSIVE works)
    4. Synchronous operation (no promises in query/run)
    5. Database export functionality

    Run tests first (TDD): npm run test -- DatabaseService.test.ts
    Tests should fail initially, then pass after implementation
  </action>
  <verify>npm run test -- DatabaseService.test.ts</verify>
  <done>All DatabaseService tests pass, including FTS5, recursive CTE, and synchronous operation verification</done>
</task>

</tasks>

<verification>
1. DatabaseService initializes successfully with vendored WASM
2. FTS5 queries return version string (not error)
3. Recursive CTE queries execute without errors
4. All operations are synchronous (no promises in API)
5. Database exports to bytes for Swift file I/O
6. Tests validate all critical sql.js capabilities
</verification>

<success_criteria>
- sql.js loads FTS5-enabled WASM from local public/wasm/ directory
- DatabaseService provides synchronous query API matching CLAUDE.md requirements
- FTS5 full-text search functionality verified working
- Recursive CTEs execute successfully for graph traversal
- Database export/import works for Swift bridge file I/O
- Zero serialization boundaries between sql.js and future D3.js usage
- Foundation ready for Phase 2 SuperGrid development
</success_criteria>

<output>
After completion, create `.planning/phases/33-bridge-elimination/33-01-SUMMARY.md`
</output>