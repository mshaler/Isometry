# Phase 104 Plan 02: SuperSize Persistence

**Plan:** 104-02
**Priority:** P0 (MVP Gate)
**Requirements:** SIZE-01, SIZE-02
**Est. Duration:** ~30 minutes

## Objective

Wire cell size persistence into SuperSize so resized columns survive navigation and browser refresh.

## Context

SuperSize.tsx already exists with:
- ✅ Cell expansion state management (CellExpansionState)
- ✅ Global size factor slider
- ✅ Expand/collapse all functionality
- ✅ Smooth animations
- ❌ No SQLite persistence

## Tasks

### Task 1: Create Cell Size Persistence Hook

**File:** `src/hooks/useCellSizePersistence.ts`

```typescript
import { useEffect, useRef, useCallback, useMemo } from 'react';
import { useSQLite } from '@/db/SQLiteProvider';
import { debounce } from 'lodash-es';

interface CellSizeState {
  cellSizes: Record<string, { width: number; height: number }>;
  globalSizeFactor: number;
}

const VIEW_STATE_KEY = 'supergrid-cell-sizes';

/**
 * Persist and restore cell sizes to/from SQLite view_state table
 */
export function useCellSizePersistence(datasetId: string = 'default') {
  const { db } = useSQLite();
  const initialLoadRef = useRef(false);

  // Load saved sizes on mount
  const loadSizes = useCallback(async (): Promise<CellSizeState | null> => {
    if (!db) return null;
    
    try {
      const result = db.exec(`
        SELECT state_json FROM view_state 
        WHERE id = ? AND family = 'LATCH'
      `, [VIEW_STATE_KEY]);
      
      if (result[0]?.values?.[0]?.[0]) {
        const state = JSON.parse(result[0].values[0][0] as string);
        return state.cellSizes ? state : null;
      }
    } catch (e) {
      console.warn('[useCellSizePersistence] Failed to load sizes:', e);
    }
    return null;
  }, [db]);

  // Save sizes (debounced to avoid DB spam)
  const saveSizes = useMemo(
    () => debounce((state: CellSizeState) => {
      if (!db) return;
      
      try {
        db.run(`
          INSERT OR REPLACE INTO view_state (id, dataset_id, app_id, family, state_json, updated_at)
          VALUES (?, ?, 'isometry', 'LATCH', ?, datetime('now'))
        `, [VIEW_STATE_KEY, datasetId, JSON.stringify(state)]);
      } catch (e) {
        console.warn('[useCellSizePersistence] Failed to save sizes:', e);
      }
    }, 500),
    [db, datasetId]
  );

  // Cleanup debounce on unmount
  useEffect(() => {
    return () => {
      saveSizes.cancel();
    };
  }, [saveSizes]);

  return {
    loadSizes,
    saveSizes,
    initialLoadRef
  };
}
```

**Test:** `src/hooks/__tests__/useCellSizePersistence.test.ts`

```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { renderHook, act, waitFor } from '@testing-library/react';
import { useCellSizePersistence } from '../useCellSizePersistence';

// Mock SQLite
const mockDb = {
  exec: vi.fn(),
  run: vi.fn()
};

vi.mock('@/db/SQLiteProvider', () => ({
  useSQLite: () => ({ db: mockDb })
}));

describe('useCellSizePersistence', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('loads sizes from SQLite on call', async () => {
    const savedState = {
      cellSizes: { 'cell-1': { width: 200, height: 100 } },
      globalSizeFactor: 1.5
    };
    
    mockDb.exec.mockReturnValue([{
      values: [[JSON.stringify(savedState)]]
    }]);

    const { result } = renderHook(() => useCellSizePersistence());
    
    const loaded = await result.current.loadSizes();
    
    expect(loaded).toEqual(savedState);
    expect(mockDb.exec).toHaveBeenCalledWith(
      expect.stringContaining('SELECT state_json FROM view_state'),
      expect.any(Array)
    );
  });

  it('saves sizes with debounce', async () => {
    const { result } = renderHook(() => useCellSizePersistence());
    
    const state = {
      cellSizes: { 'cell-1': { width: 150, height: 80 } },
      globalSizeFactor: 1.0
    };

    act(() => {
      result.current.saveSizes(state);
    });

    // Should not save immediately (debounced)
    expect(mockDb.run).not.toHaveBeenCalled();

    // Wait for debounce
    await waitFor(() => {
      expect(mockDb.run).toHaveBeenCalled();
    }, { timeout: 600 });
  });

  it('handles missing table gracefully', async () => {
    mockDb.exec.mockImplementation(() => {
      throw new Error('no such table: view_state');
    });

    const { result } = renderHook(() => useCellSizePersistence());
    
    const loaded = await result.current.loadSizes();
    
    expect(loaded).toBeNull();
  });
});
```

### Task 2: Wire Persistence into SuperSize

**File:** `src/components/supergrid/SuperSize.tsx`

Add import:
```typescript
import { useCellSizePersistence } from '@/hooks/useCellSizePersistence';
```

Add inside component, after existing state hooks:
```typescript
const { loadSizes, saveSizes, initialLoadRef } = useCellSizePersistence();

// Load saved state on mount
useEffect(() => {
  if (initialLoadRef.current) return;
  initialLoadRef.current = true;
  
  loadSizes().then(savedState => {
    if (savedState) {
      setGlobalSizeFactor(savedState.globalSizeFactor || 1.0);
      setExpansionState(prev => ({
        ...prev,
        cellSizes: new Map(Object.entries(savedState.cellSizes || {}))
      }));
    }
  });
}, [loadSizes]);

// Persist on size changes
useEffect(() => {
  // Skip initial render
  if (!initialLoadRef.current) return;
  
  saveSizes({
    cellSizes: Object.fromEntries(expansionState.cellSizes),
    globalSizeFactor
  });
}, [expansionState.cellSizes, globalSizeFactor, saveSizes]);
```

### Task 3: Verify view_state Table Exists

Check `src/db/schema.sql` contains:
```sql
CREATE TABLE IF NOT EXISTS view_state (
    id TEXT PRIMARY KEY,
    dataset_id TEXT NOT NULL,
    app_id TEXT NOT NULL,
    family TEXT NOT NULL,
    state_json TEXT NOT NULL,
    updated_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%SZ', 'now'))
);
```

If missing, add to schema initialization.

## Verification

```bash
# Run tests
npm run test:run -- --testPathPattern="useCellSizePersistence"

# Type check
npm run check:types

# Manual test:
# 1. Open SuperGrid
# 2. Resize a column
# 3. Navigate to another view
# 4. Return to SuperGrid
# 5. Verify column size is preserved
```

## Acceptance Criteria

- [ ] `useCellSizePersistence` tests pass
- [ ] Cell sizes persist across navigation
- [ ] Global size factor persists
- [ ] Debounce prevents DB spam (verify with console)
- [ ] TypeScript compiles with zero errors
