# Phase 104 Plan 01: SuperDynamic End-to-End Wiring

**Plan:** 104-01
**Priority:** P0 (MVP Gate)
**Requirements:** DYNAMIC-01, DYNAMIC-02, DYNAMIC-03
**Est. Duration:** ~45 minutes

## Objective

Wire the existing SuperDynamic component into SuperGrid so that drag-and-drop axis repositioning triggers actual grid layout changes via PAFVProvider.

## Context

SuperDynamic.tsx already exists with:
- ✅ Full drag state management (DragState interface)
- ✅ Visual drag feedback with ghost elements
- ✅ Drop zone detection via data-axis-drop-zone attributes
- ✅ Axis swap logic (performAxisSwap function)
- ❌ Not rendered in SuperGrid
- ❌ Not connected to usePAFV hook

## Tasks

### Task 1: Create Dimension Inference Utility

**File:** `src/utils/latch-inference.ts`

```typescript
import type { LATCHDimension } from '@/hooks/usePAFV';

/**
 * Infer LATCH dimension from facet name
 * Used when dragging axes in SuperDynamic
 */
export function inferDimensionFromFacet(facet: string): LATCHDimension {
  const lowerFacet = facet.toLowerCase();
  
  // Time-related facets
  if (['created_at', 'modified_at', 'date', 'year', 'month', 'quarter', 'week', 'day']
      .some(t => lowerFacet.includes(t))) {
    return 'time';
  }
  
  // Location-related facets
  if (['location', 'place', 'address', 'city', 'country', 'region']
      .some(l => lowerFacet.includes(l))) {
    return 'location';
  }
  
  // Hierarchy-related facets
  if (['folder', 'path', 'parent', 'priority', 'level']
      .some(h => lowerFacet.includes(h))) {
    return 'hierarchy';
  }
  
  // Alphabet-related facets
  if (['name', 'title', 'alphabetical']
      .some(a => lowerFacet.includes(a))) {
    return 'alphabet';
  }
  
  // Default to category (status, tags, type, etc.)
  return 'category';
}
```

**Test:** `src/utils/__tests__/latch-inference.test.ts`

```typescript
import { describe, it, expect } from 'vitest';
import { inferDimensionFromFacet } from '../latch-inference';

describe('inferDimensionFromFacet', () => {
  it('infers time dimension from date-related facets', () => {
    expect(inferDimensionFromFacet('created_at')).toBe('time');
    expect(inferDimensionFromFacet('modified_at')).toBe('time');
    expect(inferDimensionFromFacet('year')).toBe('time');
    expect(inferDimensionFromFacet('month')).toBe('time');
  });

  it('infers location dimension', () => {
    expect(inferDimensionFromFacet('location')).toBe('location');
    expect(inferDimensionFromFacet('city')).toBe('location');
  });

  it('infers hierarchy dimension', () => {
    expect(inferDimensionFromFacet('folder')).toBe('hierarchy');
    expect(inferDimensionFromFacet('priority')).toBe('hierarchy');
  });

  it('infers alphabet dimension', () => {
    expect(inferDimensionFromFacet('name')).toBe('alphabet');
    expect(inferDimensionFromFacet('title')).toBe('alphabet');
  });

  it('defaults to category for unknown facets', () => {
    expect(inferDimensionFromFacet('status')).toBe('category');
    expect(inferDimensionFromFacet('tags')).toBe('category');
    expect(inferDimensionFromFacet('type')).toBe('category');
  });
});
```

### Task 2: Create Available Facets Discovery Hook

**File:** `src/hooks/useAvailableFacets.ts`

```typescript
import { useMemo } from 'react';
import { useSQLiteQuery } from '@/hooks';

export interface FacetOption {
  id: string;
  label: string;
  description: string;
}

// Columns to exclude from facet list
const EXCLUDED_COLUMNS = ['id', 'content', 'deleted_at', 'created_at', 'modified_at'];

/**
 * Discover available facets from node schema
 */
export function useAvailableFacets(): FacetOption[] {
  // Query PRAGMA to get column names
  const { data: columns } = useSQLiteQuery<{ name: string }>(
    "SELECT name FROM pragma_table_info('nodes')",
    []
  );
  
  return useMemo(() => {
    if (!columns) return [];
    
    return columns
      .filter(col => !EXCLUDED_COLUMNS.includes(col.name))
      .map(col => ({
        id: col.name,
        label: formatFacetLabel(col.name),
        description: `Group by ${formatFacetLabel(col.name)}`
      }));
  }, [columns]);
}

function formatFacetLabel(name: string): string {
  return name
    .replace(/_/g, ' ')
    .replace(/\b\w/g, c => c.toUpperCase());
}
```

### Task 3: Wire SuperDynamic into SuperGrid

**File:** `src/components/supergrid/SuperGrid.tsx`

Add imports:
```typescript
import { SuperDynamic } from './SuperDynamic';
import { useAvailableFacets } from '@/hooks/useAvailableFacets';
import { inferDimensionFromFacet } from '@/utils/latch-inference';
```

Add hook calls inside component:
```typescript
const { setMapping, removeMapping } = usePAFV();
const availableFacets = useAvailableFacets();

// Track reflow state for animation
const [isReflowing, setIsReflowing] = useState(false);
const prevMappingsRef = useRef(pafvState.mappings);

// Handle axis change from SuperDynamic
const handleAxisChange = useCallback((
  plane: 'x' | 'y' | 'z',
  facetId: string
) => {
  if (!facetId) {
    removeMapping(plane);
  } else {
    const dimension = inferDimensionFromFacet(facetId);
    setMapping(plane, dimension, facetId);
  }
}, [setMapping, removeMapping]);

// Trigger reflow animation when mappings change
useEffect(() => {
  const currentJson = JSON.stringify(pafvState.mappings);
  const prevJson = JSON.stringify(prevMappingsRef.current);
  
  if (currentJson !== prevJson) {
    setIsReflowing(true);
    const timeout = setTimeout(() => setIsReflowing(false), 500);
    prevMappingsRef.current = pafvState.mappings;
    return () => clearTimeout(timeout);
  }
}, [pafvState.mappings]);
```

Add to render, before column headers:
```tsx
{/* MiniNav / SuperDynamic */}
{enableDragDrop && (
  <div className="supergrid__mininav">
    <SuperDynamic
      xAxis={gridLayout.columnFacet || ''}
      yAxis={gridLayout.rowFacet || ''}
      zAxis=""
      onAxisChange={handleAxisChange}
      availableAxes={availableFacets}
    />
  </div>
)}
```

Update data grid className:
```tsx
<div
  className={`supergrid__data-grid ${isReflowing ? 'supergrid__data-grid--reflowing' : ''}`}
  ...
>
```

### Task 4: Add Reflow Animation CSS

**File:** `src/components/supergrid/SuperGrid.css`

Add:
```css
/* MiniNav / SuperDynamic container */
.supergrid__mininav {
  grid-area: mininav;
  background: var(--bg-secondary, #f5f5f5);
  border-right: 1px solid var(--border-color, #e0e0e0);
  border-bottom: 1px solid var(--border-color, #e0e0e0);
  padding: 8px;
  overflow: auto;
}

/* Reflow animation on axis change */
.supergrid__data-grid--reflowing {
  transition: all 500ms cubic-bezier(0.4, 0, 0.2, 1);
}

.supergrid__data-grid--reflowing .supergrid__cell {
  transition: transform 500ms cubic-bezier(0.4, 0, 0.2, 1),
              opacity 300ms ease-out;
}
```

## Verification

```bash
# Run tests
npm run test:run -- --testPathPattern="latch-inference"

# Type check
npm run check:types

# Manual test: 
# 1. Open SuperGrid with data
# 2. Drag x-axis facet to y-axis slot
# 3. Verify grid transposes (rows become columns)
# 4. Press Escape during drag - verify cancel
```

## Acceptance Criteria

- [ ] `inferDimensionFromFacet` tests pass
- [ ] SuperDynamic renders in SuperGrid
- [ ] Dragging axis triggers grid reflow
- [ ] Reflow animation completes < 500ms
- [ ] TypeScript compiles with zero errors
