---
phase: 42-large-dataset-persistence
plan: 03
type: execute
wave: 2
depends_on: [42-01]
files_modified:
  - src/db/SQLiteProvider.tsx
  - src/components/Canvas.tsx
autonomous: true

must_haves:
  truths:
    - "FTS5 search performs <50ms queries on 15K+ node datasets"
    - "Performance remains at 60fps with real-world data density"
    - "Storage quota is monitored and user warned if approaching limits"
  artifacts:
    - path: "src/db/SQLiteProvider.tsx"
      provides: "FTS5 search with performance timing"
      contains: "nodes_fts"
    - path: "src/components/Canvas.tsx"
      provides: "60fps performance monitoring during rendering"
      contains: "useCanvasPerformance"
  key_links:
    - from: "src/db/SQLiteProvider.tsx"
      to: "sql.js"
      via: "FTS5 MATCH queries"
      pattern: "MATCH.*nodes_fts"
    - from: "src/components/Canvas.tsx"
      to: "src/hooks/performance/useCanvasPerformance.ts"
      via: "Performance hook"
      pattern: "recordRender"
---

<objective>
Verify performance benchmarks with alto-index data: FTS5 search under 50ms, 60fps rendering, and proper storage quota monitoring for production readiness.

Purpose: Success criteria require specific performance targets. This plan validates those targets with real data and ensures graceful degradation if limits are approached.

Output: Verified performance benchmarks documented, quota monitoring active, production-ready persistence layer.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/42-large-dataset-persistence/42-RESEARCH.md
@src/db/SQLiteProvider.tsx
@src/hooks/performance/useCanvasPerformance.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Verify FTS5 search performance on 15K+ nodes</name>
  <files>
    - src/db/SQLiteProvider.tsx
  </files>
  <action>
    1. Add FTS5 performance measurement to SQLiteProvider:
       - Create a diagnostic method to test FTS5 performance:
         ```typescript
         // Add to SQLiteContextValue interface
         testFTS5Performance: (query: string) => { results: number; timeMs: number };
         ```

       - Implement the method:
         ```typescript
         const testFTS5Performance = useCallback((query: string) => {
           if (!db) throw new Error('Database not initialized');

           const startTime = performance.now();

           try {
             // Use nodes_fts virtual table if it exists
             const results = db.exec(`
               SELECT COUNT(*) as count FROM nodes_fts
               WHERE nodes_fts MATCH ?
             `, [query]);

             const endTime = performance.now();
             const count = results[0]?.values[0]?.[0] as number ?? 0;

             devLogger.inspect('FTS5 Performance Test', {
               query,
               resultCount: count,
               timeMs: (endTime - startTime).toFixed(2)
             });

             return {
               results: count,
               timeMs: endTime - startTime
             };
           } catch (err) {
             // FTS5 table may not exist, fall back to LIKE search
             devLogger.warn('FTS5 not available, using LIKE fallback', { error: err });

             const results = db.exec(`
               SELECT COUNT(*) as count FROM nodes
               WHERE name LIKE ? OR content LIKE ?
             `, [`%${query}%`, `%${query}%`]);

             const endTime = performance.now();
             const count = results[0]?.values[0]?.[0] as number ?? 0;

             return {
               results: count,
               timeMs: endTime - startTime
             };
           }
         }, [db]);
         ```

    2. Run FTS5 benchmark tests:
       - Test with common search terms: "meeting", "project", "email"
       - Test with prefix search: "meet*", "proj*"
       - Verify all queries complete in <50ms

    3. Log FTS5 availability in telemetry:
       - If FTS5 is not available, log to telemetry for diagnosis
       - Document whether alto-index nodes have FTS5 indexing

    Why: FTS5 is critical for <50ms search at scale. Fallback to LIKE is orders of magnitude slower.
  </action>
  <verify>
    - FTS5 search queries complete in <50ms on 15K+ nodes
    - Console logs show FTS5 performance metrics
    - Fallback to LIKE works if FTS5 unavailable (with warning)
  </verify>
  <done>
    FTS5 search verified to perform under 50ms on alto-index dataset, with LIKE fallback for compatibility.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify 60fps rendering with alto-index data</name>
  <files>
    - src/components/Canvas.tsx
    - src/hooks/performance/useCanvasPerformance.ts (read-only)
  </files>
  <action>
    1. Ensure performance monitoring captures real render metrics:
       - Verify useCanvasPerformance is active during ViewEngine renders
       - Check recordRender() is called with accurate timing:
         ```typescript
         const renderTime = performance.now() - renderStartTime;
         recordRender(renderTime, nodes.length);
         ```

    2. Add 60fps threshold warning:
       - In Canvas, check if render times exceed 16.67ms (60fps budget):
         ```typescript
         if (renderTime > 16.67) {
           devLogger.warn('Render exceeded 60fps budget', {
             renderTime: `${renderTime.toFixed(2)}ms`,
             budget: '16.67ms',
             nodeCount: nodes.length,
             viewType
           });
         }
         ```

    3. Run performance stress test:
       - With alto-index data loaded (15K+ nodes):
         - Rapid view switching (Grid -> List -> Kanban -> Grid)
         - Scroll through data
         - Apply/remove LATCH filters
       - Monitor FPS in performance overlay
       - Document any drops below 30fps

    4. Identify virtualization effectiveness:
       - Check TanStack Virtual is limiting DOM nodes
       - Log visible vs total node count:
         ```typescript
         devLogger.debug('Virtualization stats', {
           totalNodes: nodes.length,
           visibleNodes: virtualizer?.getVirtualItems().length || 'N/A',
           containerHeight: containerRef.current?.clientHeight
         });
         ```

    Why: 60fps is the performance target. Virtualization should prevent DOM from growing proportionally with data.
  </action>
  <verify>
    - Render times stay under 16.67ms for typical operations
    - FPS counter shows 60fps during normal interaction
    - Performance warnings appear if budget exceeded
    - Virtualization limits visible DOM nodes
  </verify>
  <done>
    60fps performance verified with alto-index data, virtualization effective at limiting DOM size.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add storage quota monitoring and user warnings</name>
  <files>
    - src/db/IndexedDBPersistence.ts
    - src/db/SQLiteProvider.tsx
  </files>
  <action>
    1. Enhance IndexedDBPersistence with quota checking:
       - Add method to check storage quota:
         ```typescript
         async checkStorageQuota(): Promise<{
           used: number;
           quota: number;
           available: number;
           percentUsed: number;
           warning: boolean;
         }> {
           if (!navigator.storage || !navigator.storage.estimate) {
             return {
               used: 0, quota: 0, available: 0, percentUsed: 0, warning: false
             };
           }

           const estimate = await navigator.storage.estimate();
           const used = estimate.usage ?? 0;
           const quota = estimate.quota ?? 0;
           const available = quota - used;
           const percentUsed = quota > 0 ? (used / quota) * 100 : 0;

           return {
             used,
             quota,
             available,
             percentUsed,
             warning: percentUsed > 80 // Warn at 80% usage
           };
         }
         ```

    2. Add quota check before save operations:
       - In save() method, check quota first:
         ```typescript
         async save(data: Uint8Array): Promise<void> {
           const quota = await this.checkStorageQuota();

           if (quota.warning) {
             console.warn('Storage quota warning', {
               used: `${(quota.used / 1024 / 1024).toFixed(2)}MB`,
               available: `${(quota.available / 1024 / 1024).toFixed(2)}MB`,
               percentUsed: `${quota.percentUsed.toFixed(1)}%`
             });
           }

           // Check if new data would exceed available space
           if (data.length > quota.available * 0.9) {
             throw new Error(
               `Insufficient storage: need ${(data.length / 1024 / 1024).toFixed(2)}MB, ` +
               `only ${(quota.available / 1024 / 1024).toFixed(2)}MB available`
             );
           }

           // Proceed with save...
         }
         ```

    3. Expose quota info in SQLiteProvider context:
       - Add to SQLiteContextValue:
         ```typescript
         storageQuota: {
           used: number;
           quota: number;
           percentUsed: number;
           warning: boolean;
         } | null;
         ```

       - Periodically update quota info (every 30 seconds):
         ```typescript
         useEffect(() => {
           const updateQuota = async () => {
             const quota = await persistence.checkStorageQuota();
             setStorageQuota(quota);
           };

           updateQuota();
           const interval = setInterval(updateQuota, 30000);
           return () => clearInterval(interval);
         }, [persistence]);
         ```

    4. Add storage indicator in Canvas development overlay:
       - Show storage usage when warning threshold exceeded:
         ```typescript
         {storageQuota?.warning && (
           <div className="text-yellow-300">
             Storage: {storageQuota.percentUsed.toFixed(0)}% used
           </div>
         )}
         ```

    Why: Users need warning before storage quota is exceeded. Graceful degradation is better than QuotaExceededError crash.
  </action>
  <verify>
    - Storage quota check runs on save operations
    - Warning logged when storage exceeds 80%
    - Error thrown (with helpful message) if insufficient space
    - Canvas shows storage warning indicator when quota high
  </verify>
  <done>
    Storage quota monitoring active with user warnings and pre-save quota checks preventing QuotaExceededError.
  </done>
</task>

</tasks>

<verification>
Run these commands to verify plan completion:

```bash
# TypeScript compilation
npm run typecheck

# Full check pipeline
npm run check:quick
```

Manual verification:
1. Start dev server with alto-index data
2. Open console, check FTS5 performance logs (<50ms)
3. Watch FPS counter during view operations (60fps target)
4. Check Application > IndexedDB in DevTools for storage usage
5. Verify storage warnings appear if usage high
</verification>

<success_criteria>
1. FTS5 search completes in <50ms on 15K+ node dataset
2. Render times stay under 16.67ms for 60fps target
3. Performance warnings logged when budgets exceeded
4. Storage quota monitored with 80% warning threshold
5. Pre-save quota check prevents QuotaExceededError
6. Development overlay shows performance and storage metrics
</success_criteria>

<output>
After completion, create `.planning/phases/42-large-dataset-persistence/42-03-SUMMARY.md`
</output>
