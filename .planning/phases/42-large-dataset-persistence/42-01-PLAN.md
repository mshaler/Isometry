---
phase: 42-large-dataset-persistence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/IndexedDBPersistence.ts
  - src/db/SQLiteProvider.tsx
  - package.json
autonomous: true

must_haves:
  truths:
    - "Alto-index data (15K+ nodes) persists across page refreshes without quota errors"
    - "Database saves complete without QuotaExceededError"
    - "User data survives browser session restarts"
  artifacts:
    - path: "src/db/IndexedDBPersistence.ts"
      provides: "IndexedDB persistence service for sql.js database exports"
      exports: ["IndexedDBPersistence", "AutoSaveManager"]
      min_lines: 100
    - path: "src/db/SQLiteProvider.tsx"
      provides: "Updated save() function using IndexedDB instead of localStorage"
      contains: "IndexedDBPersistence"
  key_links:
    - from: "src/db/SQLiteProvider.tsx"
      to: "src/db/IndexedDBPersistence.ts"
      via: "import and save() call"
      pattern: "IndexedDBPersistence.*save"
    - from: "src/db/IndexedDBPersistence.ts"
      to: "idb"
      via: "npm package import"
      pattern: "import.*from 'idb'"
---

<objective>
Implement IndexedDB persistence layer to replace localStorage for database storage, enabling 50MB+ datasets without quota errors.

Purpose: localStorage is limited to 5-10MB and causes QuotaExceededError with alto-index data (82MB). IndexedDB supports 50MB+ datasets with proper storage management.

Output: Working IndexedDB persistence service integrated with SQLiteProvider, alto-index data persists across refreshes.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/42-large-dataset-persistence/42-RESEARCH.md
@src/db/SQLiteProvider.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install idb package and create IndexedDB persistence service</name>
  <files>
    - package.json
    - src/db/IndexedDBPersistence.ts
  </files>
  <action>
    1. Install the `idb` package (Jake Archibald's IndexedDB promise wrapper):
       ```bash
       npm install idb
       ```

    2. Create `src/db/IndexedDBPersistence.ts` with the following structure:
       - Import `openDB` and `IDBPDatabase` from 'idb'
       - Define `IsometryDB` interface for typed object stores:
         - 'database': key=string, value=Uint8Array (for sql.js exports)
         - 'metadata': key=string, value={ version, lastSaved, nodeCount, sizeBytes }
       - Implement `IndexedDBPersistence` class:
         - `init()`: Open IndexedDB with upgrade handler creating stores
         - `save(data: Uint8Array)`: Store sql.js export in 'database' store
         - `load()`: Retrieve database from IndexedDB, return null if not found
         - `getMetadata()`: Return storage metadata for diagnostics
         - `clear()`: Delete all stored data
       - Implement `AutoSaveManager` class:
         - 5-second debounce window for auto-save
         - Track `hasPendingChanges` flag
         - `notifyDataChanged()`: Schedule debounced save
         - `forceImmediateSave()`: Cancel timer and save now
         - `beforeunload` handler to warn about pending changes
       - Include storage quota checking using `navigator.storage.estimate()`

    3. Constants to use:
       - DB_NAME = 'isometry-db'
       - DB_VERSION = 1
       - DEBOUNCE_MS = 5000
       - DATABASE_STORE = 'database'
       - METADATA_STORE = 'metadata'

    Why idb over raw IndexedDB: Handles transaction auto-commit gotchas, promise-based API, battle-tested (1.19kB).

    Reference: 42-RESEARCH.md Pattern 1 (IndexedDB Export/Import) and Debounced Auto-Save Pattern.
  </action>
  <verify>
    - `npm ls idb` shows package installed
    - `npm run typecheck` passes with new file
    - File contains IndexedDBPersistence class with init, save, load methods
    - File contains AutoSaveManager class with debounce logic
  </verify>
  <done>
    IndexedDB persistence service created with type-safe stores, debounced auto-save, and storage quota monitoring.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate IndexedDB persistence into SQLiteProvider</name>
  <files>
    - src/db/SQLiteProvider.tsx
  </files>
  <action>
    1. Import IndexedDBPersistence at top of file:
       ```typescript
       import { IndexedDBPersistence, AutoSaveManager } from './IndexedDBPersistence';
       ```

    2. Add persistence state to SQLiteProvider:
       ```typescript
       const [persistence] = useState(() => new IndexedDBPersistence());
       const [autoSave] = useState(() => new AutoSaveManager(persistence));
       ```

    3. Modify initialization to try loading from IndexedDB first:
       - In `initDatabase()`, after sql.js is ready:
         ```typescript
         // Try to load from IndexedDB first (replaces localStorage backup)
         await persistence.init();
         const savedData = await persistence.load();
         if (savedData) {
           database = new sqlInstance.Database(savedData);
           devLogger.setup('Loaded database from IndexedDB', { bytes: savedData.length });
         } else {
           // Fall back to fetch from databaseUrl or create new
           // ... existing logic ...
         }
         ```

    4. Replace localStorage in save() function (lines 330-355):
       - Remove FileReader/localStorage logic
       - Replace with:
         ```typescript
         const save = useCallback(async (): Promise<void> => {
           if (!db) return;

           try {
             const data = db.export();
             await persistence.save(data);

             if (enableLogging) {
               devLogger.data('Database saved to IndexedDB', { bytes: data.length });
             }
           } catch (err) {
             console.error('Database save error:', err);
             // Check if quota exceeded
             if (err instanceof DOMException && err.name === 'QuotaExceededError') {
               // Surface to user via telemetry
               logCapabilityError('storage', err, {
                 operation: 'save',
                 dataSize: db.export().length
               });
             }
             throw err;
           }
         }, [db, persistence, enableLogging, logCapabilityError]);
         ```

    5. Update notifyDataChanged to use AutoSaveManager:
       - Replace immediate save() call with `autoSave.notifyDataChanged()`
       - Debounced save prevents export-every-write performance death (see RESEARCH.md Pitfall 2)

    6. Add cleanup in useEffect return:
       ```typescript
       return () => {
         autoSave.forceImmediateSave(); // Save pending changes on unmount
         isMounted = false;
       };
       ```

    Why: localStorage has 5-10MB limit causing QuotaExceededError. IndexedDB supports 50MB+ with proper quota checking.
  </action>
  <verify>
    - `npm run typecheck` passes
    - `npm run dev` starts without errors
    - Console shows "Loaded database from IndexedDB" or "Database saved to IndexedDB" messages
    - No localStorage.setItem calls remain for database backup
  </verify>
  <done>
    SQLiteProvider uses IndexedDB for persistence instead of localStorage, with debounced auto-save preventing performance issues.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify alto-index persistence across page refresh</name>
  <files>
    - No new files (verification task)
  </files>
  <action>
    1. Start development server: `npm run dev`

    2. Open browser to http://localhost:5173

    3. Import alto-index data (if not already present):
       - Use the import functionality to load alto-index.json
       - Wait for import to complete (15-30 seconds for 17K nodes)
       - Console should show "Database saved to IndexedDB"

    4. Verify storage in DevTools:
       - Open DevTools > Application > Storage > IndexedDB
       - Should see 'isometry-db' database
       - 'database' store should contain data
       - 'metadata' store should show nodeCount matching imported count

    5. Refresh the page (F5 or Ctrl+R)

    6. Verify data persistence:
       - Console should show "Loaded database from IndexedDB"
       - Node count should match pre-refresh count
       - No QuotaExceededError in console

    7. Check storage quota:
       - Run in console: `navigator.storage.estimate().then(e => console.log('Storage:', (e.usage/1024/1024).toFixed(2) + 'MB / ' + (e.quota/1024/1024).toFixed(2) + 'MB'))`
       - Should show reasonable usage (under 100MB for alto-index)

    If errors occur:
    - QuotaExceededError: Check if old localStorage backup exists, clear it
    - Load failure: Verify IndexedDB init() completed before save()
    - Data corruption: Check Uint8Array handling in save/load
  </action>
  <verify>
    - Alto-index data survives page refresh
    - No QuotaExceededError in console
    - IndexedDB shows stored database in DevTools
    - Storage quota usage is reasonable (<100MB for alto-index)
  </verify>
  <done>
    Alto-index data (15K+ nodes) persists across page refreshes without quota errors, IndexedDB storage verified in DevTools.
  </done>
</task>

</tasks>

<verification>
Run these commands to verify plan completion:

```bash
# TypeScript compilation
npm run typecheck

# Package installation
npm ls idb

# Lint check
npm run lint -- src/db/IndexedDBPersistence.ts src/db/SQLiteProvider.tsx
```

Manual verification:
1. Import alto-index data in browser
2. Refresh page
3. Data persists without errors
4. DevTools > Application > IndexedDB shows 'isometry-db'
</verification>

<success_criteria>
1. `idb` package installed and in package.json dependencies
2. IndexedDBPersistence.ts exists with save/load/init methods
3. SQLiteProvider.tsx uses IndexedDB instead of localStorage
4. Alto-index data persists across browser refreshes
5. No QuotaExceededError when saving large datasets
6. Auto-save debouncing prevents performance issues
</success_criteria>

<output>
After completion, create `.planning/phases/42-large-dataset-persistence/42-01-SUMMARY.md`
</output>
