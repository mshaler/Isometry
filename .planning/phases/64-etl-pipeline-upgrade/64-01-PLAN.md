---
phase: 64-etl-pipeline-upgrade
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - package-lock.json
  - src/etl/parsers/frontmatter.ts
  - src/etl/id-generation/deterministic.ts
autonomous: true

must_haves:
  truths:
    - "gray-matter and yaml packages are installed and importable"
    - "parseFrontmatter() accepts markdown string and returns typed frontmatter object"
    - "generateDeterministicSourceId() returns identical ID for identical (filePath, frontmatter) pairs"
    - "generateDeterministicSourceId() returns different ID when filePath or frontmatter changes"
  artifacts:
    - path: "src/etl/parsers/frontmatter.ts"
      provides: "gray-matter wrapper with yaml engine"
      exports: ["parseFrontmatter", "ParsedFrontmatter"]
    - path: "src/etl/id-generation/deterministic.ts"
      provides: "SHA-256 based source_id generation"
      exports: ["generateDeterministicSourceId", "hashString"]
  key_links:
    - from: "src/etl/parsers/frontmatter.ts"
      to: "gray-matter"
      via: "import matter from 'gray-matter'"
      pattern: "import matter from 'gray-matter'"
    - from: "src/etl/id-generation/deterministic.ts"
      to: "crypto"
      via: "createHash('sha256')"
      pattern: "createHash.*sha256"
---

<objective>
Install YAML parsing dependencies and create foundation modules for frontmatter extraction and deterministic source_id generation.

Purpose: Replace fragile regex-based YAML parser (108 lines) with battle-tested gray-matter library, and upgrade simple hash to cryptographic SHA-256 for collision-resistant deterministic IDs.

Output: Two new modules (parsers/frontmatter.ts, id-generation/deterministic.ts) plus installed dependencies.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/64-etl-pipeline-upgrade/64-RESEARCH.md

# Existing ETL code to understand current patterns
@src/etl/alto-parser.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install gray-matter and yaml packages</name>
  <files>package.json, package-lock.json</files>
  <action>
Run `npm install gray-matter yaml` to add dependencies.

Expected additions to package.json dependencies:
- "gray-matter": "^4.0.3"
- "yaml": "^2.3.4"

Verify installation by checking package.json contains both packages and node_modules/gray-matter exists.
  </action>
  <verify>`npm ls gray-matter yaml` shows both packages installed without errors</verify>
  <done>gray-matter and yaml packages are in dependencies and importable</done>
</task>

<task type="auto">
  <name>Task 2: Create frontmatter parser module</name>
  <files>src/etl/parsers/frontmatter.ts</files>
  <action>
Create `src/etl/parsers/` directory and `frontmatter.ts` module:

```typescript
/**
 * Frontmatter Parser using gray-matter
 *
 * Replaces custom regex-based parser with full YAML 1.2 spec support.
 * Handles nested objects, multi-line strings, anchors/aliases.
 */
import matter from 'gray-matter';
import YAML from 'yaml';

export interface ParsedFrontmatter {
  /** Parsed YAML frontmatter as key-value object */
  frontmatter: Record<string, unknown>;
  /** Markdown body content after frontmatter */
  body: string;
  /** Raw YAML string (without delimiters) for debugging */
  raw: string;
}

/**
 * Parse YAML frontmatter from markdown content.
 * Uses gray-matter with yaml package for full YAML 1.2 spec support.
 *
 * @param content - Raw markdown string with YAML frontmatter
 * @returns Parsed frontmatter and body, or null if no valid frontmatter
 */
export function parseFrontmatter(content: string): ParsedFrontmatter | null {
  try {
    const result = matter(content, {
      engines: {
        yaml: {
          parse: (str: string) => YAML.parse(str),
          stringify: (obj: unknown) => YAML.stringify(obj)
        }
      }
    });

    // gray-matter returns empty object for missing frontmatter
    // We consider this valid (file has no frontmatter)
    return {
      frontmatter: result.data as Record<string, unknown>,
      body: result.content,
      raw: result.matter || ''
    };
  } catch (error) {
    console.error('YAML parsing error:', error);
    return null;
  }
}
```

Key points:
- Uses YAML.parse as engine for full spec support (anchors, aliases, multi-line)
- Returns null on parse errors rather than throwing
- Preserves raw YAML for debugging
- Type-safe return interface
  </action>
  <verify>
1. File exists at src/etl/parsers/frontmatter.ts
2. `npm run check:types` passes (TypeScript compiles)
3. Exports parseFrontmatter and ParsedFrontmatter
  </verify>
  <done>parseFrontmatter function parses YAML frontmatter using gray-matter with yaml engine</done>
</task>

<task type="auto">
  <name>Task 3: Create deterministic source_id generator</name>
  <files>src/etl/id-generation/deterministic.ts</files>
  <action>
Create `src/etl/id-generation/` directory and `deterministic.ts` module:

```typescript
/**
 * Deterministic Source ID Generation
 *
 * Generates collision-resistant source IDs using SHA-256 hash of
 * (normalized filePath + sorted frontmatter JSON).
 *
 * Same input always produces same output (idempotent re-imports).
 */
import { createHash } from 'crypto';

/**
 * Generate a deterministic source_id from file path and frontmatter.
 *
 * Algorithm:
 * 1. Normalize file path (lowercase, forward slashes)
 * 2. Sort frontmatter keys for consistent stringification
 * 3. Create composite key: `${normalizedPath}:${sortedFrontmatterJSON}`
 * 4. SHA-256 hash, truncate to 16 hex chars
 * 5. Prefix with source name
 *
 * @param filePath - Original file path (will be normalized)
 * @param frontmatter - Parsed YAML frontmatter object
 * @param source - Source identifier prefix (default: 'alto')
 * @returns Deterministic source_id like "alto-a1b2c3d4e5f67890"
 */
export function generateDeterministicSourceId(
  filePath: string,
  frontmatter: Record<string, unknown>,
  source: string = 'alto'
): string {
  // Normalize file path: lowercase, forward slashes only
  const normalizedPath = filePath.toLowerCase().replace(/\\/g, '/');

  // Sort frontmatter keys for consistent JSON stringification
  const sortedKeys = Object.keys(frontmatter).sort();
  const sortedFrontmatter: Record<string, unknown> = {};
  for (const key of sortedKeys) {
    sortedFrontmatter[key] = frontmatter[key];
  }
  const frontmatterStr = JSON.stringify(sortedFrontmatter);

  // Composite key: path + frontmatter
  const compositeKey = `${normalizedPath}:${frontmatterStr}`;

  // SHA-256 hash, truncate to 16 chars for readability
  const hash = createHash('sha256')
    .update(compositeKey)
    .digest('hex')
    .substring(0, 16);

  return `${source}-${hash}`;
}

/**
 * Simple string hash for fallback cases (non-cryptographic).
 * Used when frontmatter is unavailable or for legacy compatibility.
 *
 * @param str - String to hash
 * @returns 32-bit hash as hex string
 */
export function hashString(str: string): string {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32-bit integer
  }
  return Math.abs(hash).toString(16);
}
```

Key points:
- Normalizes file paths for cross-platform consistency (macOS vs Linux)
- Sorts frontmatter keys to ensure identical JSON for identical data
- Uses SHA-256 (cryptographically secure) instead of djb2 hash
- Truncates to 16 chars for human-readable IDs while maintaining collision resistance
- Preserves hashString for legacy compatibility
  </action>
  <verify>
1. File exists at src/etl/id-generation/deterministic.ts
2. `npm run check:types` passes
3. Exports generateDeterministicSourceId and hashString
4. Manual verification: same (path, frontmatter) produces same ID
  </verify>
  <done>generateDeterministicSourceId produces SHA-256 based deterministic IDs from filePath and frontmatter</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Dependencies installed:**
   ```bash
   npm ls gray-matter yaml
   ```
   Both packages listed without errors.

2. **TypeScript compiles:**
   ```bash
   npm run check:types
   ```
   No errors in new files.

3. **New modules exist:**
   ```bash
   ls src/etl/parsers/frontmatter.ts src/etl/id-generation/deterministic.ts
   ```
   Both files present.

4. **Exports verified:**
   - parseFrontmatter function exported from frontmatter.ts
   - generateDeterministicSourceId and hashString exported from deterministic.ts
</verification>

<success_criteria>
- [x] gray-matter ^4.0.3 in package.json dependencies
- [x] yaml ^2.3.4 in package.json dependencies
- [x] src/etl/parsers/frontmatter.ts exists with parseFrontmatter export
- [x] src/etl/id-generation/deterministic.ts exists with generateDeterministicSourceId export
- [x] `npm run check:types` passes
- [x] Both modules use patterns from 64-RESEARCH.md
</success_criteria>

<output>
After completion, create `.planning/phases/64-etl-pipeline-upgrade/64-01-SUMMARY.md`
</output>
