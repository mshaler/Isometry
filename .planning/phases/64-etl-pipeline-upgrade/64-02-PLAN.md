---
phase: 64-etl-pipeline-upgrade
plan: 02
type: execute
wave: 2
depends_on: ["64-01"]
files_modified:
  - src/etl/storage/property-storage.ts
  - src/etl/alto-parser.ts
  - src/etl/alto-importer.ts
autonomous: true

must_haves:
  truths:
    - "Unknown frontmatter keys are stored in node_properties table"
    - "Re-importing same file produces identical source_id (idempotent)"
    - "All YAML frontmatter is preserved regardless of schema recognition"
    - "YAML files with complex structures (nested objects, arrays) parse correctly"
  artifacts:
    - path: "src/etl/storage/property-storage.ts"
      provides: "Store unknown keys to node_properties"
      exports: ["storeNodeProperties", "KNOWN_KEYS"]
    - path: "src/etl/alto-parser.ts"
      provides: "Refactored parser using gray-matter"
      exports: ["parseFrontmatter", "parseAltoFile"]
    - path: "src/etl/alto-importer.ts"
      provides: "Importer with property storage integration"
      exports: ["importAltoFiles", "mapToNodeRecord"]
  key_links:
    - from: "src/etl/alto-parser.ts"
      to: "src/etl/parsers/frontmatter.ts"
      via: "import { parseFrontmatter }"
      pattern: "import.*parseFrontmatter.*from.*parsers/frontmatter"
    - from: "src/etl/alto-importer.ts"
      to: "src/etl/id-generation/deterministic.ts"
      via: "import { generateDeterministicSourceId }"
      pattern: "import.*generateDeterministicSourceId"
    - from: "src/etl/alto-importer.ts"
      to: "src/etl/storage/property-storage.ts"
      via: "import { storeNodeProperties }"
      pattern: "import.*storeNodeProperties"
    - from: "src/etl/storage/property-storage.ts"
      to: "node_properties table"
      via: "INSERT INTO node_properties"
      pattern: "INSERT.*node_properties"
---

<objective>
Wire the foundation modules into the ETL pipeline: integrate property storage for unknown keys, refactor alto-parser to use gray-matter, and update alto-importer to use deterministic source_id generation.

Purpose: Complete the ETL-01, ETL-02, ETL-03 requirements by connecting Phase 64-01 modules to the existing import pipeline, ensuring all frontmatter is preserved and IDs are deterministic.

Output: Refactored alto-parser.ts and alto-importer.ts using new modules, plus property-storage.ts for node_properties integration.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/64-etl-pipeline-upgrade/64-RESEARCH.md
@.planning/phases/63-schema-query-safety/63-01-SUMMARY.md

# Files from 64-01 (dependencies for this plan)
@src/etl/parsers/frontmatter.ts
@src/etl/id-generation/deterministic.ts

# Files to refactor
@src/etl/alto-parser.ts
@src/etl/alto-importer.ts

# Schema reference for node_properties
@src/db/schema.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create property storage module</name>
  <files>src/etl/storage/property-storage.ts</files>
  <action>
Create `src/etl/storage/` directory and `property-storage.ts` module:

```typescript
/**
 * Property Storage for Unknown Frontmatter Keys
 *
 * Stores frontmatter keys that don't map to nodes table columns
 * in the node_properties EAV table (established in Phase 63).
 */
import type { Database } from 'sql.js';

/**
 * Known frontmatter keys that map directly to nodes table columns.
 * Keys not in this set are stored in node_properties.
 */
export const KNOWN_KEYS = new Set([
  // Identifiers
  'title', 'id', 'name',
  // Alto-specific identifiers
  'contact_id', 'chat_id', 'event_id', 'reminder_id',
  // Timestamps
  'created', 'modified', 'created_at', 'modified_at',
  'last_modified', 'created_date', 'modified_date',
  'start_date', 'end_date', 'due_date',
  'first_message', 'last_message',
  // Location
  'location', 'latitude', 'longitude',
  // Category/Organization
  'folder', 'calendar', 'organization', 'list',
  'tags', 'status', 'priority',
  // Metadata
  'source', 'source_url', 'source_id',
  // Special handling (arrays, nested objects)
  'attachments', 'links', 'participants', 'attendees', 'alarms', 'recurrence'
]);

/**
 * Store unknown frontmatter keys in node_properties table.
 *
 * Iterates over frontmatter, filters out KNOWN_KEYS, and inserts
 * remaining keys with JSON-serialized values.
 *
 * @param db - sql.js Database instance
 * @param nodeId - The node's UUID to link properties to
 * @param frontmatter - Parsed YAML frontmatter object
 */
export function storeNodeProperties(
  db: Database,
  nodeId: string,
  frontmatter: Record<string, unknown>
): void {
  for (const [key, value] of Object.entries(frontmatter)) {
    if (KNOWN_KEYS.has(key)) {
      continue; // Skip keys that map to nodes table columns
    }

    // Determine value type for reconstruction
    const valueType = Array.isArray(value) ? 'array'
      : value === null ? 'null'
      : typeof value;

    // Generate property ID (deterministic for idempotency)
    const propId = `prop-${nodeId}-${key}`;

    // Insert or replace (handles re-imports)
    db.run(`
      INSERT OR REPLACE INTO node_properties (id, node_id, key, value, value_type)
      VALUES (?, ?, ?, ?, ?)
    `, [
      propId,
      nodeId,
      key,
      JSON.stringify(value), // Preserve structure with JSON
      valueType
    ]);
  }
}

/**
 * Get all custom properties for a node.
 *
 * @param db - sql.js Database instance
 * @param nodeId - The node's UUID
 * @returns Object with property keys and parsed values
 */
export function getNodeProperties(
  db: Database,
  nodeId: string
): Record<string, unknown> {
  const result = db.exec(`
    SELECT key, value, value_type
    FROM node_properties
    WHERE node_id = ?
  `, [nodeId]);

  const properties: Record<string, unknown> = {};

  if (result.length > 0 && result[0]?.values) {
    for (const row of result[0].values) {
      const key = row[0] as string;
      const value = row[1] as string;
      // Parse JSON back to original type
      try {
        properties[key] = JSON.parse(value);
      } catch {
        properties[key] = value; // Fallback to string if not valid JSON
      }
    }
  }

  return properties;
}
```

Key points:
- KNOWN_KEYS set defines which keys map to nodes table (skip for node_properties)
- JSON.stringify preserves complex values (arrays, objects)
- value_type column enables type reconstruction on read
- INSERT OR REPLACE handles idempotent re-imports
- getNodeProperties for future Phase 65 facet discovery
  </action>
  <verify>
1. File exists at src/etl/storage/property-storage.ts
2. `npm run check:types` passes
3. Exports storeNodeProperties, getNodeProperties, KNOWN_KEYS
  </verify>
  <done>storeNodeProperties function stores unknown frontmatter keys in node_properties table</done>
</task>

<task type="auto">
  <name>Task 2: Refactor alto-parser to use gray-matter</name>
  <files>src/etl/alto-parser.ts</files>
  <action>
Refactor `src/etl/alto-parser.ts` to use the new parseFrontmatter module:

1. **Replace the custom parseFrontmatter function** (lines 126-234, ~108 lines):
   - Remove the entire parseFrontmatter function
   - Import from `./parsers/frontmatter`
   - Keep all other functions unchanged (extractTags, detectDataType, generateSourceId, parseAltoFile)

2. **Update the import section** at top of file:
```typescript
import { parseFrontmatter as parseYamlFrontmatter, type ParsedFrontmatter } from './parsers/frontmatter';
```

3. **Update parseAltoFile function** to use new import:
   - The return type from parseFrontmatter changes slightly
   - Handle the `raw` field if needed for debugging

4. **Keep generateSourceId for now** - Plan 02 Task 3 will update alto-importer to use the deterministic version. We keep the existing generateSourceId in alto-parser for backwards compatibility until integration is complete.

5. **Re-export parseFrontmatter** for external consumers:
```typescript
// Re-export for backwards compatibility
export { parseYamlFrontmatter as parseFrontmatter };
```

The goal is minimal changes - just swap out the parser implementation while preserving the module's external API.
  </action>
  <verify>
1. Custom parseFrontmatter function removed (was ~108 lines)
2. Import from './parsers/frontmatter' present
3. `npm run check:types` passes
4. parseAltoFile still works (calls new parseFrontmatter)
5. extractTags, detectDataType, generateSourceId unchanged
  </verify>
  <done>alto-parser.ts uses gray-matter via parsers/frontmatter module instead of custom regex parser</done>
</task>

<task type="auto">
  <name>Task 3: Integrate deterministic IDs and property storage into alto-importer</name>
  <files>src/etl/alto-importer.ts</files>
  <action>
Update `src/etl/alto-importer.ts` to:

1. **Add imports** for new modules:
```typescript
import { generateDeterministicSourceId } from './id-generation/deterministic';
import { storeNodeProperties } from './storage/property-storage';
```

2. **Update mapToNodeRecord function** to use deterministic source_id:
   - Change from: `const sourceId = generateSourceId(dataType, frontmatter);`
   - Change to: Use file path for deterministic ID generation
   - The function signature needs filePath parameter

3. **Modify mapToNodeRecord signature**:
```typescript
export function mapToNodeRecord(parsed: ParsedAltoFile): NodeRecord {
```
Becomes:
```typescript
export function mapToNodeRecord(
  parsed: ParsedAltoFile,
  filePath: string,
  rawFrontmatter: Record<string, unknown>
): NodeRecord {
```
Add `rawFrontmatter` parameter to preserve original frontmatter for property storage.

4. **Update source_id generation in mapToNodeRecord**:
```typescript
// Use deterministic ID based on file path and frontmatter
const sourceId = generateDeterministicSourceId(
  filePath,
  rawFrontmatter,
  'alto-index'
);
```

5. **Update importAltoFiles function** to:
   a. Pass filePath and raw frontmatter to mapToNodeRecord
   b. Call storeNodeProperties after node insertion

   In the import loop, after `db.run(insertSQL, [...])`:
```typescript
// Store unknown frontmatter keys in node_properties
storeNodeProperties(db, node.id, rawFrontmatter);
```

6. **Handle rawFrontmatter preservation**:
   In the import loop, capture raw frontmatter before type casting:
```typescript
const parsed = parseAltoFile(file.content, file.path);
if (!parsed) {
  result.skipped++;
  continue;
}

// Preserve raw frontmatter for property storage
const rawFrontmatter = parsed.frontmatter as unknown as Record<string, unknown>;
```

7. **Update the mapToNodeRecord call**:
```typescript
const node = mapToNodeRecord(parsed, file.path, rawFrontmatter);
```
  </action>
  <verify>
1. Imports from id-generation/deterministic and storage/property-storage present
2. mapToNodeRecord uses generateDeterministicSourceId
3. storeNodeProperties called after node insertion
4. `npm run check:types` passes
5. No breaking changes to importAltoFiles function signature
  </verify>
  <done>alto-importer uses deterministic source_id and stores unknown frontmatter keys in node_properties</done>
</task>

</tasks>

<verification>
After all tasks complete, run comprehensive verification:

1. **TypeScript compiles:**
   ```bash
   npm run check:types
   ```
   No errors.

2. **All new files exist:**
   ```bash
   ls src/etl/storage/property-storage.ts \
      src/etl/parsers/frontmatter.ts \
      src/etl/id-generation/deterministic.ts
   ```

3. **Imports are wired correctly:**
   ```bash
   grep -n "import.*parsers/frontmatter" src/etl/alto-parser.ts
   grep -n "import.*id-generation/deterministic" src/etl/alto-importer.ts
   grep -n "import.*storage/property-storage" src/etl/alto-importer.ts
   ```

4. **storeNodeProperties is called:**
   ```bash
   grep -n "storeNodeProperties" src/etl/alto-importer.ts
   ```
   Should show call in importAltoFiles loop.

5. **Deterministic ID used:**
   ```bash
   grep -n "generateDeterministicSourceId" src/etl/alto-importer.ts
   ```
   Should show call in mapToNodeRecord.

6. **Full lint/type check:**
   ```bash
   npm run check:quick
   ```
</verification>

<success_criteria>
- [x] src/etl/storage/property-storage.ts exists with storeNodeProperties export
- [x] alto-parser.ts imports parseFrontmatter from ./parsers/frontmatter
- [x] Custom parseFrontmatter function removed from alto-parser.ts
- [x] alto-importer.ts imports generateDeterministicSourceId
- [x] alto-importer.ts imports storeNodeProperties
- [x] mapToNodeRecord uses deterministic source_id generation
- [x] importAltoFiles calls storeNodeProperties after node insertion
- [x] `npm run check:types` passes
- [x] `npm run check:quick` passes
</success_criteria>

<output>
After completion, create `.planning/phases/64-etl-pipeline-upgrade/64-02-SUMMARY.md`
</output>
