---
phase: 18-bridge-optimization-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [
  src/utils/bridge-optimization/message-batcher.ts,
  src/utils/bridge-optimization/binary-serializer.ts,
  native/Sources/Isometry/Bridge/Optimization/MessageBatcher.swift,
  native/Sources/Isometry/Bridge/Optimization/BinarySerializer.swift,
  package.json,
  native/Package.swift
]
autonomous: true

must_haves:
  truths:
    - "Bridge message latency consistently under 16ms for 60fps UI responsiveness"
    - "Message payload sizes reduced by 40-60% through binary serialization vs JSON baseline"
  artifacts:
    - path: "src/utils/bridge-optimization/message-batcher.ts"
      provides: "JavaScript message batching with 16ms intervals"
      exports: ["MessageBatcher"]
    - path: "src/utils/bridge-optimization/binary-serializer.ts"
      provides: "MessagePack serialization for JavaScript"
      exports: ["BinarySerializer"]
    - path: "native/Sources/Isometry/Bridge/Optimization/MessageBatcher.swift"
      provides: "Swift message batching actor"
      exports: ["MessageBatcher"]
    - path: "native/Sources/Isometry/Bridge/Optimization/BinarySerializer.swift"
      provides: "MessagePack serialization for Swift"
      exports: ["BinarySerializer"]
  key_links:
    - from: "src/utils/bridge-optimization/message-batcher.ts"
      to: "native bridge"
      via: "WebKit MessageHandler with binary data"
      pattern: "webkit\\.messageHandlers\\..*\\.postMessage"
    - from: "MessagePack serialization"
      to: "bridge transport"
      via: "binary data encoding/decoding"
      pattern: "pack\\(.*\\)|unpack\\(.*\\)"
---

<objective>
Implement core bridge optimization infrastructure with message batching and binary serialization.

Purpose: Establish the foundation for high-performance bridge communication by implementing message batching to maintain 60fps UI responsiveness and MessagePack binary serialization to reduce payload sizes by 40-60% compared to JSON baseline.

Output: Production-ready message batching and binary serialization components for both React and Swift sides of the bridge, ready for integration with existing WebView infrastructure.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-bridge-optimization-foundation/18-RESEARCH.md
@native/Sources/Isometry/WebView/WebViewBridge.swift
@src/utils/webview-bridge.ts
@.planning/codebase/INTEGRATIONS.md
@.planning/codebase/STACK.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install MessagePack dependencies and create JavaScript bridge optimization infrastructure</name>
  <files>package.json, src/utils/bridge-optimization/message-batcher.ts, src/utils/bridge-optimization/binary-serializer.ts</files>
  <action>Install @msgpack/msgpack npm package for JavaScript binary serialization. Create src/utils/bridge-optimization/ directory and implement MessageBatcher class with 16ms batching intervals, queue size limits (1000 messages), and backpressure handling. Implement BinarySerializer class using MessagePack for encode/decode operations with error handling and type safety. Use research patterns from 18-RESEARCH.md including batch timeout management, queue overflow protection, and Promise-based async operations for seamless integration with existing webview-bridge.ts infrastructure.</action>
  <verify>npm list @msgpack/msgpack shows installed package, TypeScript compilation succeeds with no errors, MessageBatcher can queue and flush messages within 16ms intervals</verify>
  <done>@msgpack/msgpack installed, MessageBatcher and BinarySerializer classes exist with full TypeScript types, unit tests can create batches and serialize/deserialize messages</done>
</task>

<task type="auto">
  <name>Task 2: Implement Swift bridge optimization with MessagePack and message batching</name>
  <files>native/Package.swift, native/Sources/Isometry/Bridge/Optimization/MessageBatcher.swift, native/Sources/Isometry/Bridge/Optimization/BinarySerializer.swift</files>
  <action>Add msgpack-swift dependency to native/Package.swift. Create native/Sources/Isometry/Bridge/Optimization/ directory and implement MessageBatcher actor with async/await support, 16ms batch intervals using Timer, and queue management following Swift concurrency patterns. Implement BinarySerializer class using MessagePack with Codable integration for type-safe encoding/decoding. Follow research patterns from 18-RESEARCH.md including proper Swift actor isolation, error handling with Result types, and integration points for WebViewBridge.swift. Use os_signpost for performance measurement during development.</action>
  <verify>Swift Package Manager resolves dependencies without errors, MessageBatcher actor compiles with proper isolation, BinarySerializer can encode/decode Codable types using MessagePack</verify>
  <done>msgpack-swift added to Package.swift, MessageBatcher and BinarySerializer exist with full Swift async/await support, actors can batch messages and serialize data for WebView transport</done>
</task>

</tasks>

<verification>
Message batching works with 16ms intervals on both sides. MessagePack reduces payload sizes compared to JSON baseline. Both React and Swift components integrate cleanly with existing WebView bridge infrastructure without breaking current functionality.
</verification>

<success_criteria>
1. MessageBatcher collects and flushes bridge messages within 16ms intervals
2. BinarySerializer reduces message payload sizes by 40-60% vs JSON baseline
3. Swift and JavaScript implementations use identical MessagePack format for compatibility
4. New optimization layer integrates with existing WebViewBridge without breaking changes
5. Performance measurements confirm <16ms latency for bridge communication
</success_criteria>

<output>
After completion, create `.planning/phases/18-bridge-optimization-foundation/18-01-SUMMARY.md`
</output>