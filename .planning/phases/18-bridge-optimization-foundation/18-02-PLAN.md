---
phase: 18-bridge-optimization-foundation
plan: 02
type: execute
wave: 2
depends_on: ["18-01"]
files_modified: [
  src/utils/bridge-optimization/query-paginator.ts,
  src/utils/bridge-optimization/circuit-breaker.ts,
  native/Sources/Isometry/Bridge/Optimization/QueryPaginator.swift,
  native/Sources/Isometry/Bridge/Reliability/CircuitBreaker.swift,
  native/Package.swift
]
autonomous: true

must_haves:
  truths:
    - "Large query results automatically paginate with maximum 50 records per message"
    - "Bridge maintains zero communication failures under normal operation with circuit breaker recovery"
  artifacts:
    - path: "src/utils/bridge-optimization/query-paginator.ts"
      provides: "Cursor-based pagination for large datasets"
      exports: ["QueryPaginator"]
    - path: "src/utils/bridge-optimization/circuit-breaker.ts"
      provides: "JavaScript circuit breaker for bridge reliability"
      exports: ["CircuitBreaker"]
    - path: "native/Sources/Isometry/Bridge/Optimization/QueryPaginator.swift"
      provides: "Swift cursor-based pagination actor"
      exports: ["QueryPaginator"]
    - path: "native/Sources/Isometry/Bridge/Reliability/CircuitBreaker.swift"
      provides: "Swift circuit breaker actor for reliability"
      exports: ["CircuitBreaker"]
  key_links:
    - from: "QueryPaginator"
      to: "MessageBatcher"
      via: "paginated results sent through batching system"
      pattern: "batcher\\.queue.*paginated.*results"
    - from: "CircuitBreaker"
      to: "bridge operations"
      via: "wrap bridge calls with failure detection"
      pattern: "circuitBreaker\\.execute\\(.*bridge.*\\)"
---

<objective>
Implement advanced bridge features for reliability and large dataset handling.

Purpose: Add query result pagination to handle large datasets efficiently and circuit breaker patterns to ensure bridge reliability with automatic failure recovery, building on the message batching and serialization foundation from Plan 01.

Output: Production-ready pagination and circuit breaker components that integrate with the optimized bridge infrastructure to handle large queries and prevent cascade failures.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-bridge-optimization-foundation/18-RESEARCH.md
@.planning/phases/18-bridge-optimization-foundation/18-01-SUMMARY.md
@native/Sources/Isometry/WebView/WebViewBridge.swift
@src/utils/webview-bridge.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement JavaScript query pagination and circuit breaker components</name>
  <files>src/utils/bridge-optimization/query-paginator.ts, src/utils/bridge-optimization/circuit-breaker.ts</files>
  <action>Create QueryPaginator class implementing cursor-based pagination with 50-record page limits, stable cursor generation using record IDs, and integration with BinarySerializer from Plan 01. Implement CircuitBreaker class with configurable failure thresholds (5 failures), timeout periods (60 seconds), and half-open state management following research patterns from 18-RESEARCH.md. Include Promise-based execute() method that wraps bridge operations, automatic state transitions (closed -> open -> half-open), and error aggregation for monitoring. Both classes must integrate with MessageBatcher for optimized transport.</action>
  <verify>QueryPaginator can split large arrays into 50-record pages with stable cursors, CircuitBreaker properly transitions states based on failure/success patterns</verify>
  <done>QueryPaginator and CircuitBreaker classes exist with full TypeScript support, can handle large datasets and bridge failure scenarios respectively</done>
</task>

<task type="auto">
  <name>Task 2: Implement Swift query pagination and circuit breaker actors</name>
  <files>native/Sources/Isometry/Bridge/Optimization/QueryPaginator.swift, native/Sources/Isometry/Bridge/Reliability/CircuitBreaker.swift, native/Package.swift</files>
  <action>Add CircuitBreaker Swift package dependency to Package.swift. Create QueryPaginator actor with async query execution, cursor-based pagination using SQL LIMIT/OFFSET with stable ordering, and integration with BinarySerializer for efficient transport. Implement CircuitBreaker actor using modern Swift async/await patterns, configurable failure thresholds and timeout logic, and proper actor isolation for thread safety. Follow research patterns including error type definitions, state machine implementation, and integration with WebViewBridge message handlers. Use proper Swift concurrency patterns with @MainActor where needed for UI updates.</action>
  <verify>Swift Package Manager resolves CircuitBreaker dependency, QueryPaginator actor can paginate database query results, CircuitBreaker actor properly manages failure states with async operations</verify>
  <done>QueryPaginator and CircuitBreaker actors exist with full Swift concurrency support, integrate with existing WebViewBridge infrastructure and MessageBatcher from Plan 01</done>
</task>

</tasks>

<verification>
Query pagination automatically splits large results into 50-record pages with stable cursors. Circuit breakers detect bridge failures and automatically recover with exponential backoff. Both components integrate seamlessly with the batching and serialization infrastructure from Plan 01.
</verification>

<success_criteria>
1. QueryPaginator limits all query results to maximum 50 records per message
2. Pagination uses stable cursors that remain valid during concurrent database changes
3. CircuitBreaker prevents cascade failures with automatic state transitions
4. Circuit breaker recovery works with configurable timeout and retry logic
5. Both components use MessageBatcher and BinarySerializer for optimized transport
</success_criteria>

<output>
After completion, create `.planning/phases/18-bridge-optimization-foundation/18-02-SUMMARY.md`
</output>