---
phase: 62-density-filtering
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/d3/grid-rendering/GridRenderingEngine.ts
  - src/d3/SuperGrid.ts
  - src/state/PAFVContext.tsx
autonomous: true

must_haves:
  truths:
    - "Sparse mode (DensityLevel 1) generates placeholder cells for all row×column intersections (Cartesian product)"
    - "Dense mode (DensityLevel 2+) filters to populated-only cells (removes unpopulated intersections)"
    - "User adjusts pan slider and sees cell generation/filtering respond immediately"
    - "Density changes preserve existing selection state"
    - "Headers expand to full dimension range in sparse mode, contract to populated-only in dense mode"
  artifacts:
    - path: "src/d3/grid-rendering/GridRenderingEngine.ts"
      provides: "Density state management, Cartesian grid generation, and card filtering"
      contains: "setDensityState|generateCartesianGrid|filterCardsByDensity|mapDensityLevelToExtent"
    - path: "src/d3/SuperGrid.ts"
      provides: "Density state propagation to rendering engine"
      contains: "setDensityState"
  key_links:
    - from: "src/state/PAFVContext.tsx"
      to: "src/d3/SuperGrid.ts"
      via: "SuperGrid receives densityLevel from PAFVContext, calls GridRenderingEngine.mapDensityLevelToExtent(densityLevel), passes result to constructDensityState(), then calls setDensityState()"
      pattern: "GridRenderingEngine\\.mapDensityLevelToExtent.*densityLevel"
    - from: "src/d3/SuperGrid.ts"
      to: "src/d3/grid-rendering/GridRenderingEngine.ts"
      via: "SuperGrid calls renderingEngine.setDensityState()"
      pattern: "renderingEngine\\.setDensityState"
    - from: "src/d3/grid-rendering/GridRenderingEngine.ts"
      to: "Cartesian grid generation"
      via: "render() generates empty cells for sparse, filters for dense"
      pattern: "generateCartesianGrid|extentDensity.*sparse"
---

<objective>
Wire Janus extent density controls to GridRenderingEngine for sparse/dense cell filtering.

Purpose: Enable users to toggle between sparse mode (full Cartesian grid with empty cells) and dense mode (populated-only cells) using the existing JanusDensityControls UI.

Output: GridRenderingEngine filters cards and headers based on PAFVContext density state, with smooth D3 transitions for cell appearance/disappearance.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/62-density-filtering/62-RESEARCH.md
@.planning/phases/61-view-transitions/61-01-SUMMARY.md

@src/d3/grid-rendering/GridRenderingEngine.ts
@src/d3/SuperGrid.ts
@src/types/density-control.ts
@src/state/PAFVContext.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add density state management and mapping function</name>
  <files>src/d3/grid-rendering/GridRenderingEngine.ts</files>
  <action>
Add density state management to GridRenderingEngine following the Phase 61 selection state pattern:

1. Add import at top:
```typescript
import type { JanusDensityState, ExtentDensityMode } from '../../types/density-control';
```

2. Add private field after `selectedIds`:
```typescript
// Density state for sparse/dense filtering
private densityState: JanusDensityState | null = null;
```

3. Add mapping function (converts PAFVContext number to ExtentDensityMode):
```typescript
/**
 * Map PAFVContext densityLevel (1-4) to ExtentDensityMode
 * Per REQUIREMENTS.md:
 *   - DensityLevel 1: sparse (full Cartesian grid)
 *   - DensityLevel 2+: populated-only (dense mode)
 */
public static mapDensityLevelToExtent(level: number): ExtentDensityMode {
  return level === 1 ? 'sparse' : 'populated-only';
}
```

4. Add public setter method after `setSelectedIds()`:
```typescript
/**
 * Set current density state for extent filtering
 */
public setDensityState(state: JanusDensityState): void {
  this.densityState = state;
  superGridLogger.debug('GridRenderingEngine: density state set', {
    extentDensity: state.extentDensity,
    valueDensity: state.valueDensity,
  });
}
```

5. Add isPopulated helper:
```typescript
/**
 * Check if a card/cell is populated (has meaningful data)
 * Empty placeholders will have _isEmpty: true
 */
private isPopulated(card: unknown): boolean {
  const c = card as Record<string, unknown>;
  if (c._isEmpty) return false;
  return !!(
    (c.name && c.name !== '') ||
    c.folder ||
    c.status ||
    c.priority ||
    c.tags ||
    c.created_at
  );
}
```

Note: Task 2 will add Cartesian grid generation, Task 3 will add filtering.
  </action>
  <verify>
Run `npm run check:types` to verify no TypeScript errors.
Grep for `setDensityState` and `mapDensityLevelToExtent` in GridRenderingEngine.ts.
  </verify>
  <done>
GridRenderingEngine has setDensityState() method and mapDensityLevelToExtent() static function.
JanusDensityState type is imported and used.
  </done>
</task>

<task type="auto">
  <name>Task 2: Generate full Cartesian grid for sparse mode</name>
  <files>src/d3/grid-rendering/GridRenderingEngine.ts</files>
  <action>
Add Cartesian grid generation for sparse mode. This CREATES empty cell placeholders for all row×column intersections.

**Key insight:** Sparse mode = GENERATE (add empty cells), Dense mode = FILTER (remove empty cells).

1. Add method to compute full dimension ranges (min/max for each axis):
```typescript
/**
 * Compute the full range of values for each axis (for sparse mode headers)
 * Returns all possible header values, not just those with data
 */
private computeFullDimensionRange(cards: unknown[]): {
  columns: string[];
  rows: string[];
} {
  // Extract all unique values for column and row axes
  const columnSet = new Set<string>();
  const rowSet = new Set<string>();

  cards.forEach(card => {
    const c = card as Record<string, unknown>;
    if (c._projectedCol != null) columnSet.add(String(c._projectedCol));
    if (c._projectedRow != null) rowSet.add(String(c._projectedRow));
  });

  // Sort for consistent ordering
  return {
    columns: Array.from(columnSet).sort(),
    rows: Array.from(rowSet).sort()
  };
}
```

2. Add Cartesian grid generation method:
```typescript
/**
 * Generate full Cartesian grid with empty cell placeholders
 * For sparse mode: creates cells for ALL row×column intersections
 */
private generateCartesianGrid(
  cards: unknown[],
  columns: string[],
  rows: string[]
): unknown[] {
  // Build lookup map of existing cards by position
  const positionMap = new Map<string, unknown>();
  cards.forEach(card => {
    const c = card as Record<string, unknown>;
    const key = `${c._projectedCol}:${c._projectedRow}`;
    if (!positionMap.has(key)) {
      positionMap.set(key, card);
    }
  });

  // Generate full Cartesian product
  const result: unknown[] = [];
  for (const row of rows) {
    for (const col of columns) {
      const key = `${col}:${row}`;
      const existingCard = positionMap.get(key);
      if (existingCard) {
        result.push(existingCard);
      } else {
        // Create empty placeholder
        result.push({
          _isEmpty: true,
          _projectedCol: col,
          _projectedRow: row,
          id: `empty-${col}-${row}`,
          name: ''
        });
      }
    }
  }

  return result;
}
```

3. Add prepareCardsForDensity method that will be called in render():
```typescript
/**
 * Generate Cartesian grid for sparse mode, pass through for dense mode
 * Called at the start of render() before card positioning
 */
private prepareCardsForDensity(cards: unknown[]): unknown[] {
  const { columns, rows } = this.computeFullDimensionRange(cards);

  if (this.densityState?.extentDensity === 'sparse') {
    // Sparse: generate ALL cells including empty placeholders
    return this.generateCartesianGrid(cards, columns, rows);
  }
  // Dense: filter handled in Task 3
  return cards;
}
```

4. **INTEGRATION POINT: render() method (line ~521)**
   Find the existing code block in render() around line 521:
   ```typescript
   // Compute positions from projection or use simple grid layout
   if (this.currentData.cards) {
     if (this.currentProjection) {
       this.computeAllPositions(this.currentData.cards);
   ```

   Replace with density-aware pipeline:
   ```typescript
   // Compute positions from projection or use simple grid layout
   if (this.currentData.cards) {
     // Step 1: Prepare cards based on density (sparse generates empty cells)
     const preparedCards = this.prepareCardsForDensity(this.currentData.cards);
     // Update currentData with prepared cards for downstream rendering
     this.currentData = { ...this.currentData, cards: preparedCards };

     if (this.currentProjection) {
       this.computeAllPositions(preparedCards);
   ```
  </action>
  <verify>
Run `npm run check:types` to verify no TypeScript errors.
Grep for `generateCartesianGrid` and `computeFullDimensionRange` in GridRenderingEngine.ts.
Grep for `prepareCardsForDensity` in render() method to confirm integration.
  </verify>
  <done>
GridRenderingEngine can generate full Cartesian grid with empty cell placeholders.
computeFullDimensionRange() computes all possible row/column values.
generateCartesianGrid() creates placeholder cells for unpopulated intersections.
prepareCardsForDensity() integrated into render() pipeline at line ~521.
  </done>
</task>

<task type="auto">
  <name>Task 3: Filter to populated-only for dense mode</name>
  <files>src/d3/grid-rendering/GridRenderingEngine.ts</files>
  <action>
Add filtering logic for dense mode. This REMOVES unpopulated cells.

1. Add filterCardsByDensity method:
```typescript
/**
 * Filter cards based on extent density setting
 * Dense mode: only populated cells (removes empty placeholders)
 */
private filterCardsByDensity(cards: unknown[]): unknown[] {
  if (!this.densityState || this.densityState.extentDensity === 'sparse') {
    return cards;
  }
  // Dense mode: filter to populated-only
  return cards.filter(card => this.isPopulated(card));
}
```

2. Add method to compute populated dimensions (for header contraction):
```typescript
/**
 * Compute which row/column values have data (for dense mode header filtering)
 */
private computePopulatedDimensions(cards: unknown[]): {
  columns: Set<string>;
  rows: Set<string>;
} {
  const columns = new Set<string>();
  const rows = new Set<string>();

  cards.forEach(card => {
    const c = card as Record<string, unknown>;
    if (!c._isEmpty) {
      if (c._projectedCol != null) columns.add(String(c._projectedCol));
      if (c._projectedRow != null) rows.add(String(c._projectedRow));
    }
  });

  return { columns, rows };
}
```

3. **INTEGRATION POINT: render() method (line ~521-530)**
   After the prepareCardsForDensity call from Task 2, add filtering step:
   ```typescript
   // Step 1: Prepare cards based on density (sparse generates empty cells)
   const preparedCards = this.prepareCardsForDensity(this.currentData.cards);

   // Step 2: Filter based on density (removes empty in dense mode, no-op in sparse)
   const visibleCards = this.filterCardsByDensity(preparedCards);

   // Update currentData with visible cards for downstream rendering
   this.currentData = { ...this.currentData, cards: visibleCards };

   if (this.currentProjection) {
     this.computeAllPositions(visibleCards);
   ```

4. **INTEGRATION POINT: renderProjectionHeaders() method (line ~805)**
   Add density-based header expansion/contraction at the START of renderProjectionHeaders():
   ```typescript
   private renderProjectionHeaders(): void {
     if (!this.currentProjection) return;

     // Store original cards before any density filtering for header computation
     const originalCards = this.currentData?.cards || [];

     // Density-based header expansion/contraction
     if (this.densityState?.extentDensity === 'sparse') {
       // SPARSE: EXPAND headers to full dimension range (all possible values)
       const fullRange = this.computeFullDimensionRange(originalCards);
       this.currentHeaders = {
         columns: fullRange.columns,
         rows: fullRange.rows
       };
     } else {
       // DENSE: CONTRACT headers to populated-only
       const populated = this.computePopulatedDimensions(originalCards);
       if (this.currentHeaders) {
         this.currentHeaders = {
           columns: this.currentHeaders.columns.filter(h => populated.columns.has(h)),
           rows: this.currentHeaders.rows.filter(h => populated.rows.has(h))
         };
       }
     }

     // Continue with existing header rendering logic...
   ```
  </action>
  <verify>
Run `npm run check:types` to verify no TypeScript errors.
Run `npm run test` to verify automated tests pass (if density tests exist).
Run `npm run dev` and test:
1. Open SuperGrid in sparse mode - verify ALL cells visible including empty
2. Switch to dense mode - verify ONLY populated cells visible
3. Headers should expand/contract with mode switch
  </verify>
  <done>
Dense mode filtering removes unpopulated cells.
filterCardsByDensity() integrated into render() pipeline after prepareCardsForDensity().
Header expansion (sparse) and contraction (dense) integrated into renderProjectionHeaders() at line ~805.
Full pipeline: generate → filter → render with header sync.
  </done>
</task>

<task type="auto">
  <name>Task 4: Wire PAFVContext.densityLevel to SuperGrid via mapping function</name>
  <files>src/d3/SuperGrid.ts</files>
  <action>
Wire PAFVContext.densityLevel (number 1-4) to GridRenderingEngine.setDensityState() using the mapping function.

**Explicit wiring pattern (SuperGrid owns the mapping call):**
1. SuperGrid receives densityLevel from PAFVContext
2. SuperGrid calls `GridRenderingEngine.mapDensityLevelToExtent(densityLevel)` to convert to ExtentDensityMode
3. SuperGrid passes result to `constructDensityState()` to build JanusDensityState
4. SuperGrid calls `renderingEngine.setDensityState()` before rendering

1. Import required types and the mapping function:
```typescript
import type { JanusDensityState } from '../types/density-control';
import { GridRenderingEngine } from './grid-rendering/GridRenderingEngine';
```

2. Find where SuperGrid accesses PAFVContext (likely via usePAFV hook or props).

3. Add density state construction using the mapping function (SuperGrid OWNS this call):
```typescript
/**
 * Construct JanusDensityState from PAFVContext.densityLevel
 * SuperGrid owns the mapping: calls GridRenderingEngine.mapDensityLevelToExtent()
 * then builds the full JanusDensityState and passes to setDensityState()
 */
private constructDensityState(densityLevel: number): JanusDensityState {
  // SuperGrid calls the mapping function - per REQUIREMENTS.md: level 1 = sparse, level 2+ = dense
  const extentDensity = GridRenderingEngine.mapDensityLevelToExtent(densityLevel);

  return {
    valueDensity: 'leaf',
    extentDensity,
    viewDensity: 'spreadsheet',
    regionConfig: [],
    axisGranularity: {},
    aggregationPreferences: {
      defaultFunction: 'count',
      facetAggregations: {},
      preservePrecision: true,
      showAggregationSource: true
    }
  };
}
```

4. Find where SuperGrid calls `renderingEngine.setSelectedIds()` (added in Phase 61).

5. Add density state sync BEFORE render, in same location:
```typescript
// Before rendering, sync density state from PAFVContext
const densityLevel = pafvContext.densityLevel ?? 2; // Default to dense
const densityState = this.constructDensityState(densityLevel);
this.renderingEngine.setDensityState(densityState);
```

6. Add useEffect or equivalent to re-render when densityLevel changes:
```typescript
// React component pattern:
useEffect(() => {
  if (renderingEngine && densityLevel !== undefined) {
    const densityState = constructDensityState(densityLevel);
    renderingEngine.setDensityState(densityState);
    renderingEngine.render(); // Trigger re-render
  }
}, [densityLevel, renderingEngine]);
```

**Key patterns to follow from Phase 61:**
- Look at how SelectionContext was wired to GridRenderingEngine
- Use same pattern for DensityContext/PAFVContext wiring
  </action>
  <verify>
Run `npm run check:types` to verify no TypeScript errors.
Grep for `mapDensityLevelToExtent` in SuperGrid.ts to confirm wiring exists.
Run `npm run dev` and test:
1. Adjust JanusDensityControls pan slider
2. Verify SuperGrid responds to density changes immediately
  </verify>
  <done>
PAFVContext.densityLevel is wired to GridRenderingEngine.setDensityState().
mapDensityLevelToExtent() converts level 1-4 to 'sparse' or 'populated-only'.
Density changes trigger immediate re-render.
  </done>
</task>

<task type="auto">
  <name>Task 5: Preserve selection across density changes</name>
  <files>src/d3/grid-rendering/GridRenderingEngine.ts</files>
  <action>
Ensure selection state is preserved when density changes, following the Phase 61 pattern:

1. In the card rendering logic where `.on('end')` callback applies selection styling (from Phase 61), verify that selection styling works correctly for cards that remain visible after density filtering.

2. The key insight: When switching from sparse to dense mode:
   - Some cards are removed (exit transition)
   - Remaining cards keep their selection state
   - `selectedIds` set is preserved (not cleared)

3. If there's a bug where selection disappears on density change, ensure:
   - `setSelectedIds()` is called BEFORE filtering/rendering
   - The `.on('end')` callback reads from the current `selectedIds` (not stale closure)

Pattern from Phase 61 (verify this is present):
```typescript
.on('end', function (d: CardRecord) {
  const card = d3.select(this);
  const isSelected = selectedIds.has(String(d.id));
  card.classed('selected', isSelected);
  card.select('.card-bg')
    .attr('stroke', isSelected ? '#2563eb' : '#e1e5e9')
    .attr('stroke-width', isSelected ? 2 : 1);
});
```

4. Add debug logging to verify selection persistence:
```typescript
superGridLogger.debug('GridRenderingEngine: render with density filtering', {
  extentDensity: this.densityState?.extentDensity,
  totalCards: this.currentData?.cards?.length,
  visibleCards: visibleCards.length,
  selectedIds: this.selectedIds.size,
});
```

5. Test scenario: Select cards, toggle density, verify selected cards that remain visible keep their selection styling.
  </action>
  <verify>
Run `npm run dev` and test:
1. Open SuperGrid with cards
2. Select some cards (click to select)
3. Toggle density from sparse to dense
4. Verify selected cards that are still visible retain blue selection styling
5. Toggle back to sparse - selection should still be present
  </verify>
  <done>
Selection state is preserved across density changes:
- selectedIds Set not cleared on density change
- Cards that remain visible after filtering retain selection styling
- Transition .on('end') callback applies correct selection state
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Sparse mode GENERATES full grid (DENS-01):**
   - Set density to sparse (via JanusDensityControls, DensityLevel 1)
   - Full Cartesian grid displays including empty cell placeholders
   - ALL row×column intersections shown (even unpopulated ones)
   - Headers show full dimension range (all possible values)

2. **Dense mode FILTERS to populated (DENS-02):**
   - Set density to dense (populated-only, DensityLevel 2+)
   - Only cells with data are visible (empty placeholders removed)
   - Empty rows/columns are hidden
   - Headers contracted to show only populated dimensions

3. **Immediate response (DENS-03):**
   - Density toggle triggers immediate re-render
   - Cards animate in/out with 300ms transitions
   - No lag or stutter during generation/filtering

4. **Selection preserved:**
   - Select cards, change density
   - Selected cards that remain visible keep selection styling
   - Selection count matches visible selected cards

Run: `npm run check` to verify no type errors or lint issues.
</verification>

<success_criteria>
- [ ] `npm run check:types` passes with zero errors
- [ ] GridRenderingEngine has setDensityState(), mapDensityLevelToExtent(), generateCartesianGrid(), and filterCardsByDensity() methods
- [ ] SuperGrid wires PAFVContext.densityLevel to GridRenderingEngine via mapDensityLevelToExtent()
- [ ] Sparse mode GENERATES full Cartesian grid (creates empty cell placeholders)
- [ ] Dense mode FILTERS to populated-only (removes empty cells)
- [ ] Headers EXPAND to full range in sparse mode, CONTRACT to populated-only in dense mode
- [ ] Selection preserved across density changes
- [ ] 300ms transitions for card appearance/disappearance
</success_criteria>

<output>
After completion, create `.planning/phases/62-density-filtering/62-01-SUMMARY.md`
</output>
