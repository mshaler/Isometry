---
phase: 62-density-filtering
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/d3/grid-rendering/GridRenderingEngine.ts
  - src/d3/SuperGrid.ts
  - src/state/PAFVContext.tsx
autonomous: true

must_haves:
  truths:
    - "User sets pan level to sparse and sees full Cartesian grid including empty cells"
    - "User sets pan level to dense and sees only populated cells"
    - "User adjusts pan slider and sees cell filtering respond immediately"
    - "Density changes preserve existing selection state"
  artifacts:
    - path: "src/d3/grid-rendering/GridRenderingEngine.ts"
      provides: "Density state management and card/header filtering"
      contains: "setDensityState|filterCardsByDensity|isPopulated"
    - path: "src/d3/SuperGrid.ts"
      provides: "Density state propagation to rendering engine"
      contains: "setDensityState"
  key_links:
    - from: "src/state/PAFVContext.tsx"
      to: "src/d3/SuperGrid.ts"
      via: "PAFVContext.densityLevel consumed by SuperGrid"
      pattern: "usePAFV.*densityLevel"
    - from: "src/d3/SuperGrid.ts"
      to: "src/d3/grid-rendering/GridRenderingEngine.ts"
      via: "SuperGrid calls renderingEngine.setDensityState()"
      pattern: "renderingEngine\\.setDensityState"
    - from: "src/d3/grid-rendering/GridRenderingEngine.ts"
      to: "card filtering"
      via: "render() filters cards based on extentDensity"
      pattern: "filterCardsByDensity|extentDensity.*populated"
---

<objective>
Wire Janus extent density controls to GridRenderingEngine for sparse/dense cell filtering.

Purpose: Enable users to toggle between sparse mode (full Cartesian grid with empty cells) and dense mode (populated-only cells) using the existing JanusDensityControls UI.

Output: GridRenderingEngine filters cards and headers based on PAFVContext density state, with smooth D3 transitions for cell appearance/disappearance.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/62-density-filtering/62-RESEARCH.md
@.planning/phases/61-view-transitions/61-01-SUMMARY.md

@src/d3/grid-rendering/GridRenderingEngine.ts
@src/d3/SuperGrid.ts
@src/types/density-control.ts
@src/state/PAFVContext.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add density state to GridRenderingEngine</name>
  <files>src/d3/grid-rendering/GridRenderingEngine.ts</files>
  <action>
Add density state management to GridRenderingEngine following the Phase 61 selection state pattern:

1. Add import at top:
```typescript
import type { JanusDensityState, ExtentDensityMode } from '../../types/density-control';
```

2. Add private field after `selectedIds`:
```typescript
// Density state for sparse/dense filtering
private densityState: JanusDensityState | null = null;
```

3. Add public setter method after `setSelectedIds()`:
```typescript
/**
 * Set current density state for extent filtering
 */
public setDensityState(state: JanusDensityState): void {
  this.densityState = state;
  superGridLogger.debug('GridRenderingEngine: density state set', {
    extentDensity: state.extentDensity,
    valueDensity: state.valueDensity,
  });
}
```

4. Add private filtering helper method:
```typescript
/**
 * Filter cards based on extent density setting
 * Sparse mode: show all cells including empty
 * Dense mode: only populated cells (has name or LATCH facet value)
 */
private filterCardsByDensity(cards: unknown[]): unknown[] {
  if (!this.densityState || this.densityState.extentDensity === 'sparse') {
    return cards;
  }
  // Dense mode: filter to populated-only
  return cards.filter(card => this.isPopulated(card));
}

/**
 * Check if a card/cell is populated (has meaningful data)
 */
private isPopulated(card: unknown): boolean {
  const c = card as Record<string, unknown>;
  return !!(
    (c.name && c.name !== '') ||
    c.folder ||
    c.status ||
    c.priority ||
    c.tags ||
    c.created_at
  );
}
```

Note: These methods will be wired to the rendering pipeline in Task 2.
  </action>
  <verify>
Run `npm run check:types` to verify no TypeScript errors.
Grep for `setDensityState` and `filterCardsByDensity` in GridRenderingEngine.ts.
  </verify>
  <done>
GridRenderingEngine has setDensityState() method and filterCardsByDensity() helper.
JanusDensityState type is imported and used.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire density filtering into render pipeline</name>
  <files>src/d3/grid-rendering/GridRenderingEngine.ts, src/d3/SuperGrid.ts</files>
  <action>
Wire density filtering into the card and header rendering pipeline:

**In GridRenderingEngine.ts:**

1. Find the `renderCards()` method (or equivalent card rendering logic).

2. At the start of card rendering, apply density filtering:
```typescript
// Apply density filtering before rendering
const visibleCards = this.filterCardsByDensity(this.currentData?.cards || []);
```

3. Use `visibleCards` instead of raw `this.currentData.cards` for the D3 data binding.

4. For header filtering, add method to compute populated dimensions:
```typescript
/**
 * Compute which row/column values have data (for header filtering)
 */
private computePopulatedDimensions(cards: unknown[]): {
  columns: Set<string>;
  rows: Set<string>;
} {
  const columns = new Set<string>();
  const rows = new Set<string>();

  cards.forEach(card => {
    const c = card as Record<string, unknown>;
    // _projectedCol and _projectedRow are set during projection
    if (c._projectedCol != null) columns.add(String(c._projectedCol));
    if (c._projectedRow != null) rows.add(String(c._projectedRow));
  });

  return { columns, rows };
}
```

5. In header rendering methods (renderProjectionHeaders or similar), filter headers in dense mode:
```typescript
// If dense mode, filter headers to only show populated dimensions
if (this.densityState?.extentDensity === 'populated-only') {
  const populated = this.computePopulatedDimensions(visibleCards);
  visibleColumnHeaders = columnHeaders.filter(h => populated.columns.has(h.value));
  visibleRowHeaders = rowHeaders.filter(h => populated.rows.has(h.value));
}
```

**In SuperGrid.ts:**

1. Import JanusDensityState if not already imported.

2. Find where SuperGrid calls `renderingEngine.setSelectedIds()` (added in Phase 61).

3. Add density state sync in the same location (before render):
```typescript
// Sync density state to rendering engine
const densityState = this.getDensityStateFromContext(); // or from props
if (densityState) {
  this.renderingEngine.setDensityState(densityState);
}
```

4. The density state comes from PAFVContext. Find where SuperGrid accesses PAFVContext (likely in a useEffect or render prop pattern) and extract the densityLevel/densityState.

Note: PAFVContext stores `densityLevel` as a number (1-4). Map this to JanusDensityState:
- Level 1 or 2 with sparse = full Cartesian
- Level 2+ with dense = populated-only

If PAFVContext doesn't have full JanusDensityState, construct a default:
```typescript
const densityState: JanusDensityState = {
  valueDensity: 'leaf',
  extentDensity: densityLevel >= 2 ? 'populated-only' : 'sparse',
  viewDensity: 'spreadsheet',
  regionConfig: [],
  axisGranularity: {},
  aggregationPreferences: {
    defaultFunction: 'count',
    facetAggregations: {},
    preservePrecision: true,
    showAggregationSource: true
  }
};
```
  </action>
  <verify>
Run `npm run check:types` to verify no TypeScript errors.
Run `npm run dev` and test:
1. Open SuperGrid view with cards
2. Use JanusDensityControls to toggle between sparse and dense
3. Verify cards appear/disappear smoothly
4. Verify headers update to match visible cards
  </verify>
  <done>
Density filtering is wired end-to-end:
- PAFVContext.densityLevel flows to SuperGrid
- SuperGrid calls renderingEngine.setDensityState()
- GridRenderingEngine.render() filters cards based on extentDensity
- Headers are filtered to match visible card dimensions
  </done>
</task>

<task type="auto">
  <name>Task 3: Preserve selection across density changes</name>
  <files>src/d3/grid-rendering/GridRenderingEngine.ts</files>
  <action>
Ensure selection state is preserved when density changes, following the Phase 61 pattern:

1. In the card rendering logic where `.on('end')` callback applies selection styling (from Phase 61), verify that selection styling works correctly for cards that remain visible after density filtering.

2. The key insight: When switching from sparse to dense mode:
   - Some cards are removed (exit transition)
   - Remaining cards keep their selection state
   - `selectedIds` set is preserved (not cleared)

3. If there's a bug where selection disappears on density change, ensure:
   - `setSelectedIds()` is called BEFORE filtering/rendering
   - The `.on('end')` callback reads from the current `selectedIds` (not stale closure)

Pattern from Phase 61 (verify this is present):
```typescript
.on('end', function (d: CardRecord) {
  const card = d3.select(this);
  const isSelected = selectedIds.has(String(d.id));
  card.classed('selected', isSelected);
  card.select('.card-bg')
    .attr('stroke', isSelected ? '#2563eb' : '#e1e5e9')
    .attr('stroke-width', isSelected ? 2 : 1);
});
```

4. Add debug logging to verify selection persistence:
```typescript
superGridLogger.debug('GridRenderingEngine: render with density filtering', {
  extentDensity: this.densityState?.extentDensity,
  totalCards: this.currentData?.cards?.length,
  visibleCards: visibleCards.length,
  selectedIds: this.selectedIds.size,
});
```

5. Test scenario: Select cards, toggle density, verify selected cards that remain visible keep their selection styling.
  </action>
  <verify>
Run `npm run dev` and test:
1. Open SuperGrid with cards
2. Select some cards (click to select)
3. Toggle density from sparse to dense
4. Verify selected cards that are still visible retain blue selection styling
5. Toggle back to sparse - selection should still be present
  </verify>
  <done>
Selection state is preserved across density changes:
- selectedIds Set not cleared on density change
- Cards that remain visible after filtering retain selection styling
- Transition .on('end') callback applies correct selection state
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Sparse mode works (DENS-01):**
   - Set density to sparse (via JanusDensityControls)
   - Full Cartesian grid displays including empty cells
   - All possible row/column combinations shown

2. **Dense mode works (DENS-02):**
   - Set density to dense (populated-only)
   - Only cells with data are visible
   - Empty rows/columns are hidden

3. **Immediate response (DENS-03):**
   - Density toggle triggers immediate re-render
   - Cards animate in/out with 300ms transitions
   - No lag or stutter during filtering

4. **Selection preserved:**
   - Select cards, change density
   - Selected cards that remain visible keep selection styling
   - Selection count matches visible selected cards

Run: `npm run check` to verify no type errors or lint issues.
</verification>

<success_criteria>
- [ ] `npm run check:types` passes with zero errors
- [ ] GridRenderingEngine has setDensityState() and filterCardsByDensity() methods
- [ ] SuperGrid wires PAFVContext density to GridRenderingEngine
- [ ] Sparse mode shows full Cartesian grid (empty cells visible)
- [ ] Dense mode hides empty cells, shows only populated
- [ ] Headers filter to match visible card dimensions
- [ ] Selection preserved across density changes
- [ ] 300ms transitions for card appearance/disappearance
</success_criteria>

<output>
After completion, create `.planning/phases/62-density-filtering/62-01-SUMMARY.md`
</output>
