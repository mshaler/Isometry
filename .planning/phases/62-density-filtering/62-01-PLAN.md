---
phase: 62-density-filtering
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/d3/grid-rendering/GridRenderingEngine.ts
  - src/d3/SuperGrid.ts
  - src/state/PAFVContext.tsx
autonomous: true

must_haves:
  truths:
    - "Sparse mode generates placeholder cells for all row×column intersections (Cartesian product)"
    - "Dense mode filters to populated-only cells (removes unpopulated intersections)"
    - "User adjusts pan slider and sees cell generation/filtering respond immediately"
    - "Density changes preserve existing selection state"
    - "Headers expand to full dimension range in sparse mode, contract to populated-only in dense mode"
  artifacts:
    - path: "src/d3/grid-rendering/GridRenderingEngine.ts"
      provides: "Density state management, Cartesian grid generation, and card filtering"
      contains: "setDensityState|generateCartesianGrid|filterCardsByDensity|mapDensityLevelToExtent"
    - path: "src/d3/SuperGrid.ts"
      provides: "Density state propagation to rendering engine"
      contains: "setDensityState"
  key_links:
    - from: "src/state/PAFVContext.tsx"
      to: "src/d3/SuperGrid.ts"
      via: "PAFVContext.densityLevel consumed by SuperGrid via mapDensityLevelToExtent()"
      pattern: "mapDensityLevelToExtent.*densityLevel"
    - from: "src/d3/SuperGrid.ts"
      to: "src/d3/grid-rendering/GridRenderingEngine.ts"
      via: "SuperGrid calls renderingEngine.setDensityState()"
      pattern: "renderingEngine\\.setDensityState"
    - from: "src/d3/grid-rendering/GridRenderingEngine.ts"
      to: "Cartesian grid generation"
      via: "render() generates empty cells for sparse, filters for dense"
      pattern: "generateCartesianGrid|extentDensity.*sparse"
---

<objective>
Wire Janus extent density controls to GridRenderingEngine for sparse/dense cell filtering.

Purpose: Enable users to toggle between sparse mode (full Cartesian grid with empty cells) and dense mode (populated-only cells) using the existing JanusDensityControls UI.

Output: GridRenderingEngine filters cards and headers based on PAFVContext density state, with smooth D3 transitions for cell appearance/disappearance.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/62-density-filtering/62-RESEARCH.md
@.planning/phases/61-view-transitions/61-01-SUMMARY.md

@src/d3/grid-rendering/GridRenderingEngine.ts
@src/d3/SuperGrid.ts
@src/types/density-control.ts
@src/state/PAFVContext.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add density state management and mapping function</name>
  <files>src/d3/grid-rendering/GridRenderingEngine.ts</files>
  <action>
Add density state management to GridRenderingEngine following the Phase 61 selection state pattern:

1. Add import at top:
```typescript
import type { JanusDensityState, ExtentDensityMode } from '../../types/density-control';
```

2. Add private field after `selectedIds`:
```typescript
// Density state for sparse/dense filtering
private densityState: JanusDensityState | null = null;
```

3. Add mapping function (converts PAFVContext number to ExtentDensityMode):
```typescript
/**
 * Map PAFVContext densityLevel (1-4) to ExtentDensityMode
 * Level 1-2: sparse (show full Cartesian grid)
 * Level 3-4: populated-only (dense mode)
 */
public static mapDensityLevelToExtent(level: number): ExtentDensityMode {
  return level <= 2 ? 'sparse' : 'populated-only';
}
```

4. Add public setter method after `setSelectedIds()`:
```typescript
/**
 * Set current density state for extent filtering
 */
public setDensityState(state: JanusDensityState): void {
  this.densityState = state;
  superGridLogger.debug('GridRenderingEngine: density state set', {
    extentDensity: state.extentDensity,
    valueDensity: state.valueDensity,
  });
}
```

5. Add isPopulated helper:
```typescript
/**
 * Check if a card/cell is populated (has meaningful data)
 * Empty placeholders will have _isEmpty: true
 */
private isPopulated(card: unknown): boolean {
  const c = card as Record<string, unknown>;
  if (c._isEmpty) return false;
  return !!(
    (c.name && c.name !== '') ||
    c.folder ||
    c.status ||
    c.priority ||
    c.tags ||
    c.created_at
  );
}
```

Note: Task 2a will add Cartesian grid generation, Task 2b will add filtering.
  </action>
  <verify>
Run `npm run check:types` to verify no TypeScript errors.
Grep for `setDensityState` and `mapDensityLevelToExtent` in GridRenderingEngine.ts.
  </verify>
  <done>
GridRenderingEngine has setDensityState() method and mapDensityLevelToExtent() static function.
JanusDensityState type is imported and used.
  </done>
</task>

<task type="auto">
  <name>Task 2a: Generate full Cartesian grid for sparse mode</name>
  <files>src/d3/grid-rendering/GridRenderingEngine.ts</files>
  <action>
Add Cartesian grid generation for sparse mode. This CREATES empty cell placeholders for all row×column intersections.

**Key insight:** Sparse mode = GENERATE (add empty cells), Dense mode = FILTER (remove empty cells).

1. Add method to compute full dimension ranges (min/max for each axis):
```typescript
/**
 * Compute the full range of values for each axis (for sparse mode headers)
 * Returns all possible header values, not just those with data
 */
private computeFullDimensionRange(cards: unknown[]): {
  columns: string[];
  rows: string[];
} {
  // Extract all unique values for column and row axes
  const columnSet = new Set<string>();
  const rowSet = new Set<string>();

  cards.forEach(card => {
    const c = card as Record<string, unknown>;
    if (c._projectedCol != null) columnSet.add(String(c._projectedCol));
    if (c._projectedRow != null) rowSet.add(String(c._projectedRow));
  });

  // Sort for consistent ordering
  return {
    columns: Array.from(columnSet).sort(),
    rows: Array.from(rowSet).sort()
  };
}
```

2. Add Cartesian grid generation method:
```typescript
/**
 * Generate full Cartesian grid with empty cell placeholders
 * For sparse mode: creates cells for ALL row×column intersections
 */
private generateCartesianGrid(
  cards: unknown[],
  columns: string[],
  rows: string[]
): unknown[] {
  // Build lookup map of existing cards by position
  const positionMap = new Map<string, unknown>();
  cards.forEach(card => {
    const c = card as Record<string, unknown>;
    const key = `${c._projectedCol}:${c._projectedRow}`;
    if (!positionMap.has(key)) {
      positionMap.set(key, card);
    }
  });

  // Generate full Cartesian product
  const result: unknown[] = [];
  for (const row of rows) {
    for (const col of columns) {
      const key = `${col}:${row}`;
      const existingCard = positionMap.get(key);
      if (existingCard) {
        result.push(existingCard);
      } else {
        // Create empty placeholder
        result.push({
          _isEmpty: true,
          _projectedCol: col,
          _projectedRow: row,
          id: `empty-${col}-${row}`,
          name: ''
        });
      }
    }
  }

  return result;
}
```

3. Integrate into render pipeline - find where cards are prepared for rendering and add:
```typescript
// Generate Cartesian grid for sparse mode, pass through for dense mode
private prepareCardsForDensity(cards: unknown[]): unknown[] {
  const { columns, rows } = this.computeFullDimensionRange(cards);

  if (this.densityState?.extentDensity === 'sparse') {
    // Sparse: generate ALL cells including empty placeholders
    return this.generateCartesianGrid(cards, columns, rows);
  }
  // Dense: filter handled in Task 2b
  return cards;
}
```
  </action>
  <verify>
Run `npm run check:types` to verify no TypeScript errors.
Grep for `generateCartesianGrid` and `computeFullDimensionRange` in GridRenderingEngine.ts.
  </verify>
  <done>
GridRenderingEngine can generate full Cartesian grid with empty cell placeholders.
computeFullDimensionRange() computes all possible row/column values.
generateCartesianGrid() creates placeholder cells for unpopulated intersections.
  </done>
</task>

<task type="auto">
  <name>Task 2b: Filter to populated-only for dense mode</name>
  <files>src/d3/grid-rendering/GridRenderingEngine.ts</files>
  <action>
Add filtering logic for dense mode. This REMOVES unpopulated cells.

1. Add filterCardsByDensity method:
```typescript
/**
 * Filter cards based on extent density setting
 * Dense mode: only populated cells (removes empty placeholders)
 */
private filterCardsByDensity(cards: unknown[]): unknown[] {
  if (!this.densityState || this.densityState.extentDensity === 'sparse') {
    return cards;
  }
  // Dense mode: filter to populated-only
  return cards.filter(card => this.isPopulated(card));
}
```

2. Add method to compute populated dimensions (for header contraction):
```typescript
/**
 * Compute which row/column values have data (for dense mode header filtering)
 */
private computePopulatedDimensions(cards: unknown[]): {
  columns: Set<string>;
  rows: Set<string>;
} {
  const columns = new Set<string>();
  const rows = new Set<string>();

  cards.forEach(card => {
    const c = card as Record<string, unknown>;
    if (!c._isEmpty) {
      if (c._projectedCol != null) columns.add(String(c._projectedCol));
      if (c._projectedRow != null) rows.add(String(c._projectedRow));
    }
  });

  return { columns, rows };
}
```

3. Update header rendering for sparse/dense mode switching:
In header rendering methods (renderProjectionHeaders or similar):
```typescript
// Sparse mode: EXPAND headers to full dimension range
// Dense mode: CONTRACT headers to populated-only
if (this.densityState?.extentDensity === 'sparse') {
  // Show ALL possible headers (full range)
  const { columns, rows } = this.computeFullDimensionRange(originalCards);
  visibleColumnHeaders = columns.map(v => ({ value: v, label: v }));
  visibleRowHeaders = rows.map(v => ({ value: v, label: v }));
} else {
  // Show only populated headers
  const populated = this.computePopulatedDimensions(originalCards);
  visibleColumnHeaders = columnHeaders.filter(h => populated.columns.has(h.value));
  visibleRowHeaders = rowHeaders.filter(h => populated.rows.has(h.value));
}
```

4. Combine generation and filtering in the render pipeline:
```typescript
// In render() or renderCards():
// Step 1: Generate grid based on density mode
const preparedCards = this.prepareCardsForDensity(this.currentData?.cards || []);

// Step 2: Filter based on density (removes empty in dense mode, no-op in sparse)
const visibleCards = this.filterCardsByDensity(preparedCards);

// Use visibleCards for D3 data binding
```
  </action>
  <verify>
Run `npm run check:types` to verify no TypeScript errors.
Run `npm run dev` and test:
1. Open SuperGrid in sparse mode - verify ALL cells visible including empty
2. Switch to dense mode - verify ONLY populated cells visible
3. Headers should expand/contract with mode switch
  </verify>
  <done>
Dense mode filtering removes unpopulated cells.
Header expansion (sparse) and contraction (dense) work correctly.
Full pipeline: generate → filter → render.
  </done>
</task>

<task type="auto">
  <name>Task 2c: Wire PAFVContext.densityLevel to SuperGrid via mapping function</name>
  <files>src/d3/SuperGrid.ts</files>
  <action>
Wire PAFVContext.densityLevel (number 1-4) to GridRenderingEngine.setDensityState() using the mapping function.

**This addresses blocker #3:** Missing wiring between PAFVContext.densityLevel and JanusDensityState.

1. Import required types and the mapping function:
```typescript
import type { JanusDensityState } from '../types/density-control';
import { GridRenderingEngine } from './grid-rendering/GridRenderingEngine';
```

2. Find where SuperGrid accesses PAFVContext (likely via usePAFV hook or props).

3. Add density state construction using the mapping function:
```typescript
/**
 * Construct JanusDensityState from PAFVContext.densityLevel
 */
private constructDensityState(densityLevel: number): JanusDensityState {
  const extentDensity = GridRenderingEngine.mapDensityLevelToExtent(densityLevel);

  return {
    valueDensity: 'leaf',
    extentDensity,
    viewDensity: 'spreadsheet',
    regionConfig: [],
    axisGranularity: {},
    aggregationPreferences: {
      defaultFunction: 'count',
      facetAggregations: {},
      preservePrecision: true,
      showAggregationSource: true
    }
  };
}
```

4. Find where SuperGrid calls `renderingEngine.setSelectedIds()` (added in Phase 61).

5. Add density state sync BEFORE render, in same location:
```typescript
// Before rendering, sync density state from PAFVContext
const densityLevel = pafvContext.densityLevel ?? 2; // Default to dense
const densityState = this.constructDensityState(densityLevel);
this.renderingEngine.setDensityState(densityState);
```

6. Add useEffect or equivalent to re-render when densityLevel changes:
```typescript
// React component pattern:
useEffect(() => {
  if (renderingEngine && densityLevel !== undefined) {
    const densityState = constructDensityState(densityLevel);
    renderingEngine.setDensityState(densityState);
    renderingEngine.render(); // Trigger re-render
  }
}, [densityLevel, renderingEngine]);
```

**Key patterns to follow from Phase 61:**
- Look at how SelectionContext was wired to GridRenderingEngine
- Use same pattern for DensityContext/PAFVContext wiring
  </action>
  <verify>
Run `npm run check:types` to verify no TypeScript errors.
Grep for `mapDensityLevelToExtent` in SuperGrid.ts to confirm wiring exists.
Run `npm run dev` and test:
1. Adjust JanusDensityControls pan slider
2. Verify SuperGrid responds to density changes immediately
  </verify>
  <done>
PAFVContext.densityLevel is wired to GridRenderingEngine.setDensityState().
mapDensityLevelToExtent() converts level 1-4 to 'sparse' or 'populated-only'.
Density changes trigger immediate re-render.
  </done>
</task>

<task type="auto">
  <name>Task 3: Preserve selection across density changes</name>
  <files>src/d3/grid-rendering/GridRenderingEngine.ts</files>
  <action>
Ensure selection state is preserved when density changes, following the Phase 61 pattern:

1. In the card rendering logic where `.on('end')` callback applies selection styling (from Phase 61), verify that selection styling works correctly for cards that remain visible after density filtering.

2. The key insight: When switching from sparse to dense mode:
   - Some cards are removed (exit transition)
   - Remaining cards keep their selection state
   - `selectedIds` set is preserved (not cleared)

3. If there's a bug where selection disappears on density change, ensure:
   - `setSelectedIds()` is called BEFORE filtering/rendering
   - The `.on('end')` callback reads from the current `selectedIds` (not stale closure)

Pattern from Phase 61 (verify this is present):
```typescript
.on('end', function (d: CardRecord) {
  const card = d3.select(this);
  const isSelected = selectedIds.has(String(d.id));
  card.classed('selected', isSelected);
  card.select('.card-bg')
    .attr('stroke', isSelected ? '#2563eb' : '#e1e5e9')
    .attr('stroke-width', isSelected ? 2 : 1);
});
```

4. Add debug logging to verify selection persistence:
```typescript
superGridLogger.debug('GridRenderingEngine: render with density filtering', {
  extentDensity: this.densityState?.extentDensity,
  totalCards: this.currentData?.cards?.length,
  visibleCards: visibleCards.length,
  selectedIds: this.selectedIds.size,
});
```

5. Test scenario: Select cards, toggle density, verify selected cards that remain visible keep their selection styling.
  </action>
  <verify>
Run `npm run dev` and test:
1. Open SuperGrid with cards
2. Select some cards (click to select)
3. Toggle density from sparse to dense
4. Verify selected cards that are still visible retain blue selection styling
5. Toggle back to sparse - selection should still be present
  </verify>
  <done>
Selection state is preserved across density changes:
- selectedIds Set not cleared on density change
- Cards that remain visible after filtering retain selection styling
- Transition .on('end') callback applies correct selection state
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Sparse mode GENERATES full grid (DENS-01):**
   - Set density to sparse (via JanusDensityControls, level 1-2)
   - Full Cartesian grid displays including empty cell placeholders
   - ALL row×column intersections shown (even unpopulated ones)
   - Headers show full dimension range (all possible values)

2. **Dense mode FILTERS to populated (DENS-02):**
   - Set density to dense (populated-only, level 3-4)
   - Only cells with data are visible (empty placeholders removed)
   - Empty rows/columns are hidden
   - Headers contracted to show only populated dimensions

3. **Immediate response (DENS-03):**
   - Density toggle triggers immediate re-render
   - Cards animate in/out with 300ms transitions
   - No lag or stutter during generation/filtering

4. **Selection preserved:**
   - Select cards, change density
   - Selected cards that remain visible keep selection styling
   - Selection count matches visible selected cards

Run: `npm run check` to verify no type errors or lint issues.
</verification>

<success_criteria>
- [ ] `npm run check:types` passes with zero errors
- [ ] GridRenderingEngine has setDensityState(), mapDensityLevelToExtent(), generateCartesianGrid(), and filterCardsByDensity() methods
- [ ] SuperGrid wires PAFVContext.densityLevel to GridRenderingEngine via mapDensityLevelToExtent()
- [ ] Sparse mode GENERATES full Cartesian grid (creates empty cell placeholders)
- [ ] Dense mode FILTERS to populated-only (removes empty cells)
- [ ] Headers EXPAND to full range in sparse mode, CONTRACT to populated-only in dense mode
- [ ] Selection preserved across density changes
- [ ] 300ms transitions for card appearance/disappearance
</success_criteria>

<output>
After completion, create `.planning/phases/62-density-filtering/62-01-SUMMARY.md`
</output>
