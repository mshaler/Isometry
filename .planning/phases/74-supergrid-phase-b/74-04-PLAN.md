# Plan 74-04: SuperPosition — Coordinate Tracking

**Phase:** 74 (SuperGrid Phase B)
**Plan:** 04 of 04
**Status:** READY
**Priority:** P1 — Enables view transitions
**Estimated Effort:** 0.5 day

## Goal

Implement logical PAFV coordinate tracking so cards maintain position context across view transitions. This enables the spec's "Janus polymorphic view transitions."

## Requirements Covered

- POS-01: Each card maintains PAFV coordinates (logical, not pixel)
- POS-02: View transitions recompute position from axis mappings
- POS-03: Custom sort orders tracked contextually
- POS-04: Position after filter removal returns to original

## Current State

Cards have pixel positions computed at render time. No logical coordinates stored. No position tracking across views.

## Target State

```
Card PAFV Coordinates:
┌─────────────────────────────────────────┐
│ id: "card-123"                          │
│ position: {                             │
│   x: { axis: "Category", value: "Work" }│
│   y: { axis: "Time", value: "Q1" }      │
│   z: { axis: null, value: null }        │
│ }                                       │
│ customSortIndex: 3  // within group     │
└─────────────────────────────────────────┘

On view transition Grid → Kanban:
- Read card's Category value → place in Kanban column
- Maintain customSortIndex within column
```

## Tasks

### Task 1: Define Position Types

**Files:** `src/d3/SuperGridEngine/types.ts`

**Implementation:**

```typescript
interface PAFVCoordinate {
  axis: LATCHAxis | null;
  facet?: string;
  value: string | number | null;
}

interface CardPosition {
  nodeId: string;
  x: PAFVCoordinate;
  y: PAFVCoordinate;
  z: PAFVCoordinate;
  customSortIndex?: number;  // Manual ordering within group
  lastUpdated: string;       // ISO timestamp
}

interface PositionState {
  positions: Map<string, CardPosition>;
  customSortOrders: Map<string, string[]>;  // groupKey → nodeIds
}
```

**TDD:**
- Test: CardPosition type validates correctly
- Test: PAFVCoordinate handles null axis

### Task 2: Create PositionManager

**Files:** `src/d3/SuperGridEngine/PositionManager.ts` (NEW)

**Implementation:**

```typescript
class PositionManager {
  private positions: Map<string, CardPosition> = new Map();
  private customSortOrders: Map<string, string[]> = new Map();

  // Calculate logical position from cell
  calculatePosition(
    cell: CellDescriptor,
    pafvConfig: PAFVConfiguration
  ): CardPosition;

  // Recompute pixel position from logical coordinates
  resolvePosition(
    position: CardPosition,
    pafvConfig: PAFVConfiguration,
    gridDimensions: GridDimensions
  ): { gridX: number; gridY: number };

  // Track custom sort order
  setCustomOrder(groupKey: string, nodeIds: string[]): void;
  getCustomOrder(groupKey: string): string[] | undefined;

  // Persistence
  serializeState(): string;
  deserializeState(json: string): void;
}
```

**TDD:**
- Test: calculatePosition extracts LATCH values from cell
- Test: resolvePosition returns correct grid coordinates
- Test: Custom order persists across serialize/deserialize

### Task 3: Position Recalculation on View Change

**Files:** `src/d3/SuperGridEngine/PositionManager.ts`

**Implementation:**

```typescript
function recalculateAllPositions(
  nodes: Node[],
  newPafvConfig: PAFVConfiguration,
  positionManager: PositionManager
): CellDescriptor[] {
  const cells: CellDescriptor[] = [];

  for (const node of nodes) {
    // Get or create position
    let position = positionManager.positions.get(node.id);

    if (!position) {
      // First time: derive from node's LATCH properties
      position = derivePositionFromNode(node, newPafvConfig);
      positionManager.positions.set(node.id, position);
    }

    // Resolve to grid coordinates
    const { gridX, gridY } = positionManager.resolvePosition(
      position,
      newPafvConfig,
      gridDimensions
    );

    cells.push({
      id: `cell-${gridX}-${gridY}`,
      gridX,
      gridY,
      xValue: position.x.value?.toString() || '',
      yValue: position.y.value?.toString() || '',
      nodeIds: [node.id],
      nodeCount: 1
    });
  }

  return cells;
}
```

**TDD:**
- Test: New PAFV config produces new grid positions
- Test: Existing positions are reused (not recomputed)
- Test: Custom sort order maintained within groups

### Task 4: Handle Filter Position Restoration

**Files:** `src/d3/SuperGridEngine/PositionManager.ts`

**Implementation:**

```typescript
function handleFilterRemoval(
  positionManager: PositionManager,
  previouslyFilteredIds: string[],
  allCells: CellDescriptor[]
): CellDescriptor[] {
  // Cards that were filtered out should return to their
  // original positions, not new positions

  for (const nodeId of previouslyFilteredIds) {
    const storedPosition = positionManager.positions.get(nodeId);
    if (storedPosition) {
      // Position already known — no drift
      continue;
    }
    // If somehow position was lost, recalculate from node data
  }

  return allCells;
}
```

**TDD:**
- Test: Filtered card returns to same position
- Test: No position drift after filter cycle
- Test: Position preserved across multiple filter changes

### Task 5: Integrate with View Transitions

**Files:** `src/d3/SuperGridEngine/index.ts`, `src/contexts/PAFVContext.tsx`

**Implementation:**

```typescript
// In SuperGridEngine
onPAFVChange(newConfig: PAFVConfiguration) {
  const cells = recalculateAllPositions(
    this.nodes,
    newConfig,
    this.positionManager
  );

  this.render(cells);
}

// Save position state to SQLite on significant changes
onPositionStateChange() {
  const state = this.positionManager.serializeState();
  saveViewState(this.db, this.datasetId, 'LATCH', {
    ...existingState,
    positions: state
  });
}
```

**TDD:**
- Test: PAFV change triggers position recalculation
- Test: Position state saved to SQLite
- Test: Position state restored on load

## Files to Create/Modify

- `src/d3/SuperGridEngine/PositionManager.ts` — NEW
- `src/d3/SuperGridEngine/__tests__/PositionManager.test.ts` — NEW
- `src/d3/SuperGridEngine/types.ts` — Add position types
- `src/d3/SuperGridEngine/index.ts` — Wire PositionManager
- `src/contexts/PAFVContext.tsx` — Trigger position recalc on change

## Commit Sequence

```bash
# Commit 1: Types and manager
feat(supergrid): add PositionManager with PAFV coordinate tracking

# Commit 2: View transition integration
feat(supergrid): recalculate positions on PAFV config change

# Commit 3: Persistence and filter handling
feat(supergrid): persist positions and restore after filter removal
```

## Verification Gates

| Test | Action | Pass Criteria |
|------|--------|---------------|
| Position tracking | Render grid | Each card has PAFV coordinates |
| View transition | Grid → Kanban → Grid | Cards in same positions |
| Custom sort | Reorder within group, transition | Order preserved |
| Filter cycle | Filter → unfilter | No position drift |
| Persistence | Reload page | Positions restored |

## Architecture Note

PositionManager is the foundation for Tier 2 state persistence (Spec Section 5). It enables:
- Grid ↔ Kanban ↔ Calendar transitions within LATCH family
- Custom sort orders that survive view changes
- Position-based undo/redo (future)
