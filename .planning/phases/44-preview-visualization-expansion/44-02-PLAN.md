---
phase: 44-preview-visualization-expansion
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/notebook/preview-tabs/DataInspectorTab.tsx
  - src/hooks/visualization/useDataInspector.ts
  - src/services/query-executor.ts
autonomous: true

must_haves:
  truths:
    - "User can enter SQL query in textarea"
    - "User can execute query and see results in table"
    - "User can sort results by clicking column headers"
    - "User can export results as CSV"
    - "User can export results as JSON"
  artifacts:
    - path: "src/components/notebook/preview-tabs/DataInspectorTab.tsx"
      provides: "SQL query interface with results table and export"
      exports: ["DataInspectorTab"]
    - path: "src/hooks/visualization/useDataInspector.ts"
      provides: "Query execution and results management hook"
      exports: ["useDataInspector"]
    - path: "src/services/query-executor.ts"
      provides: "Safe SQL execution with DDL prevention"
      exports: ["executeQuery", "exportToCSV", "exportToJSON"]
  key_links:
    - from: "src/components/notebook/preview-tabs/DataInspectorTab.tsx"
      to: "src/hooks/visualization/useDataInspector.ts"
      via: "useDataInspector hook"
      pattern: "useDataInspector\\("
    - from: "src/hooks/visualization/useDataInspector.ts"
      to: "src/services/query-executor.ts"
      via: "executeQuery function"
      pattern: "executeQuery\\("
    - from: "src/services/query-executor.ts"
      to: "src/db/SQLiteProvider.tsx"
      via: "useSQLite for database access"
      pattern: "useSQLite|execute\\("
---

<objective>
Implement Data Inspector with SQL query interface, sortable results table, and CSV/JSON export.

Purpose: Enable users to explore the SQLite schema and data directly via SQL queries, with sortable result tables and export capabilities for analysis outside the application.

Output: DataInspectorTab component with SQL textarea, execute button, sortable results table, and export buttons (CSV/JSON).
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/44-preview-visualization-expansion/44-RESEARCH.md

# Reference existing patterns
@src/components/notebook/PreviewComponent.tsx
@src/hooks/database/useSQLiteQuery.ts
@src/db/SQLiteProvider.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create query-executor service with safety checks</name>
  <files>
    src/services/query-executor.ts
  </files>
  <action>
Create a service for safe SQL query execution with DDL prevention and export utilities:

**Safety checks (per research pitfalls):**
```typescript
// DDL regex to prevent data modification
const DDL_REGEX = /^\s*(DROP|ALTER|CREATE|DELETE|UPDATE|INSERT|TRUNCATE)\s/i;

export function validateQuery(sql: string): { valid: boolean; error?: string } {
  if (DDL_REGEX.test(sql)) {
    return { valid: false, error: 'Only SELECT queries allowed in Data Inspector' };
  }
  return { valid: true };
}
```

**Query execution:**
```typescript
export interface QueryResult {
  columns: string[];
  rows: Record<string, unknown>[];
  rowCount: number;
  duration: number;
  truncated: boolean;
}

export function executeQuery(
  db: { execute: (sql: string, params?: unknown[]) => Record<string, unknown>[] },
  sql: string
): QueryResult {
  const validation = validateQuery(sql);
  if (!validation.valid) {
    throw new Error(validation.error);
  }

  // Auto-append LIMIT 1000 if query lacks LIMIT (per research)
  let querySql = sql.trim();
  const hasLimit = /LIMIT\s+\d+/i.test(querySql);
  if (!hasLimit) {
    querySql = querySql.replace(/;?\s*$/, ' LIMIT 1000');
  }

  const start = performance.now();
  const rows = db.execute(querySql);
  const duration = performance.now() - start;

  return {
    columns: rows.length > 0 ? Object.keys(rows[0]) : [],
    rows,
    rowCount: rows.length,
    duration,
    truncated: !hasLimit && rows.length === 1000
  };
}
```

**Export utilities:**
```typescript
export function exportToCSV(result: QueryResult, filename?: string): void {
  const { columns, rows } = result;
  const csv = [
    columns.join(','),
    ...rows.map(row =>
      columns.map(col => {
        const val = row[col];
        // Escape quotes and wrap strings containing commas/newlines
        if (typeof val === 'string' && (val.includes(',') || val.includes('\n') || val.includes('"'))) {
          return `"${val.replace(/"/g, '""')}"`;
        }
        return val === null ? '' : String(val);
      }).join(',')
    )
  ].join('\n');

  downloadBlob(csv, filename || 'query-results.csv', 'text/csv');
}

export function exportToJSON(result: QueryResult, filename?: string): void {
  const json = JSON.stringify({
    query: result.truncated ? '(query was auto-limited to 1000 rows)' : undefined,
    timestamp: new Date().toISOString(),
    columns: result.columns,
    rowCount: result.rowCount,
    duration: result.duration,
    results: result.rows
  }, null, 2);

  downloadBlob(json, filename || 'query-results.json', 'application/json');
}

function downloadBlob(content: string, filename: string, mimeType: string): void {
  const blob = new Blob([content], { type: mimeType });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}
```
  </action>
  <verify>
TypeScript compiles:
```bash
npm run typecheck 2>&1 | grep -E "(error|query-executor)" | head -10
```
Exports exist:
```bash
grep -E "export (function|interface)" src/services/query-executor.ts
```
  </verify>
  <done>
Query executor service validates queries (blocks DDL), auto-appends LIMIT 1000, provides CSV/JSON export via Blob API.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useDataInspector hook</name>
  <files>
    src/hooks/visualization/useDataInspector.ts
  </files>
  <action>
Create React hook that manages Data Inspector state:

```typescript
import { useState, useCallback } from 'react';
import { useSQLite } from '@/db/SQLiteProvider';
import { executeQuery, exportToCSV, exportToJSON, QueryResult } from '@/services/query-executor';

export interface SortConfig {
  column: string;
  direction: 'asc' | 'desc';
}

export function useDataInspector() {
  // useSQLite provides the `execute` function that runs SQL against sql.js
  // This is passed to executeQuery which wraps it with validation and timing
  const { execute, loading: dbLoading, error: dbError } = useSQLite();

  const [sql, setSql] = useState('SELECT * FROM nodes LIMIT 10');
  const [result, setResult] = useState<QueryResult | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [isExecuting, setIsExecuting] = useState(false);
  const [sortConfig, setSortConfig] = useState<SortConfig | null>(null);

  const runQuery = useCallback(() => {
    if (dbLoading) return;

    setIsExecuting(true);
    setError(null);

    try {
      // Pass the useSQLite execute function to executeQuery service
      // executeQuery({ execute }, sql) wraps db.execute with validation and timing
      const queryResult = executeQuery({ execute }, sql);
      setResult(queryResult);
      setSortConfig(null); // Reset sort on new query
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Query failed');
      setResult(null);
    } finally {
      setIsExecuting(false);
    }
  }, [execute, sql, dbLoading]);

  const sortBy = useCallback((column: string) => {
    if (!result) return;

    const newDirection: 'asc' | 'desc' =
      sortConfig?.column === column && sortConfig.direction === 'asc' ? 'desc' : 'asc';

    const sortedRows = [...result.rows].sort((a, b) => {
      const aVal = a[column];
      const bVal = b[column];

      // Handle nulls
      if (aVal === null && bVal === null) return 0;
      if (aVal === null) return newDirection === 'asc' ? 1 : -1;
      if (bVal === null) return newDirection === 'asc' ? -1 : 1;

      // Compare based on type
      if (typeof aVal === 'number' && typeof bVal === 'number') {
        return newDirection === 'asc' ? aVal - bVal : bVal - aVal;
      }

      const aStr = String(aVal);
      const bStr = String(bVal);
      return newDirection === 'asc'
        ? aStr.localeCompare(bStr)
        : bStr.localeCompare(aStr);
    });

    setResult({ ...result, rows: sortedRows });
    setSortConfig({ column, direction: newDirection });
  }, [result, sortConfig]);

  const handleExportCSV = useCallback(() => {
    if (result) exportToCSV(result);
  }, [result]);

  const handleExportJSON = useCallback(() => {
    if (result) exportToJSON(result);
  }, [result]);

  return {
    sql,
    setSql,
    result,
    error: error || (dbError?.message ?? null),
    isExecuting: isExecuting || dbLoading,
    sortConfig,
    runQuery,
    sortBy,
    exportCSV: handleExportCSV,
    exportJSON: handleExportJSON
  };
}
```
  </action>
  <verify>
TypeScript compiles:
```bash
npm run typecheck 2>&1 | grep -E "(error|useDataInspector)" | head -10
```
Hook exports:
```bash
grep "export.*useDataInspector" src/hooks/visualization/useDataInspector.ts
```
  </verify>
  <done>
useDataInspector hook manages SQL input, query execution, sorting, and export state.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create DataInspectorTab component and integrate</name>
  <files>
    src/components/notebook/preview-tabs/DataInspectorTab.tsx
    src/components/notebook/PreviewComponent.tsx
  </files>
  <action>
**DataInspectorTab.tsx:**
Create React component with SQL query interface:

```typescript
interface DataInspectorTabProps {
  className?: string;
}

export function DataInspectorTab({ className }: DataInspectorTabProps) {
  const { theme } = useTheme();
  const {
    sql, setSql, result, error, isExecuting,
    sortConfig, runQuery, sortBy, exportCSV, exportJSON
  } = useDataInspector();

  // Component structure:
  // 1. SQL textarea (monospace font, 4-6 rows)
  // 2. Toolbar: Execute button, Export CSV, Export JSON, status info
  // 3. Results table OR error message OR empty state
  // 4. Status bar: row count, query duration, truncation warning
}
```

**UI elements:**
- Textarea with monospace font, dark theme-aware styling, Ctrl+Enter to execute
- Execute button with loading spinner when executing
- Export buttons (disabled when no results)
- Results table with:
  - Clickable column headers for sorting (show sort indicator arrow)
  - Alternating row colors for readability
  - Truncate long cell content with ellipsis (max 100 chars), title tooltip for full content
  - Fixed height table body with overflow scroll (using flex layout)
- Error display: red border, error message text
- Empty state: "Run a query to see results"
- Truncation warning: "Results limited to 1000 rows. Add explicit LIMIT to override."

**PreviewComponent.tsx updates:**
- Import DataInspectorTab
- Replace the data-inspector tab placeholder (lines ~344-352) with:
  ```tsx
  <DataInspectorTab />
  ```
- Update status bar for data-inspector tab to show result info

**Keyboard shortcuts:**
- Ctrl+Enter (Cmd+Enter on Mac): Execute query
- Tab inside textarea: Insert 2 spaces (prevent focus change)
  </action>
  <verify>
Component renders:
```bash
npm run dev &
sleep 5
curl -s http://localhost:5173 | grep -q "Inspector" && echo "App renders"
kill %1
```
TypeScript compiles:
```bash
npm run typecheck 2>&1 | grep -E "error" | head -10
```
Integration complete:
```bash
grep -l "DataInspectorTab" src/components/notebook/PreviewComponent.tsx
```
  </verify>
  <done>
DataInspectorTab renders SQL textarea, execute button, sortable results table, and export buttons. User can query SQLite, sort results, and export to CSV/JSON.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. **Manual verification in browser:**
   - Navigate to Preview pane, switch to Inspector tab
   - Enter SQL query: `SELECT * FROM nodes LIMIT 5`
   - Click Execute - verify results table appears
   - Click a column header - verify sort applies (arrow indicator)
   - Click Export CSV - verify file downloads
   - Click Export JSON - verify file downloads
   - Enter DDL query: `DROP TABLE nodes` - verify error message
   - Enter query without LIMIT - verify truncation warning

2. **Automated checks:**
```bash
# TypeScript compilation
npm run typecheck

# ESLint
npm run lint -- --max-warnings=700

# Verify files created
ls -la src/services/query-executor.ts
ls -la src/hooks/visualization/useDataInspector.ts
ls -la src/components/notebook/preview-tabs/DataInspectorTab.tsx
```
</verification>

<success_criteria>
- DataInspectorTab renders SQL textarea and results table
- Query execution shows results with column headers
- Clicking column headers sorts results (ascending/descending toggle)
- Export CSV downloads valid CSV file with all columns
- Export JSON downloads valid JSON with metadata
- DDL queries are blocked with error message
- Queries without LIMIT are auto-limited to 1000 with warning
- TypeScript compiles without errors
- ESLint passes within warning budget
</success_criteria>

<output>
After completion, create `.planning/phases/44-preview-visualization-expansion/44-02-SUMMARY.md`
</output>
