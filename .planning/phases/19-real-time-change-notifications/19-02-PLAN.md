---
phase: 19-real-time-change-notifications
plan: 02
type: execute
wave: 2
depends_on: ["19-01"]
files_modified:
  - src/hooks/useOptimisticUpdates.ts
  - src/utils/connection-manager.ts
  - src/context/ConnectionContext.tsx
  - native/Sources/Isometry/Bridge/RealTime/ConflictResolver.swift
  - src/components/shared/ConnectionStatus.tsx
autonomous: false

must_haves:
  truths:
    - "User actions appear instantly with optimistic updates"
    - "Failed operations rollback cleanly with user notification"
    - "Application works offline with clear status indication"
    - "Connection restoration syncs pending changes automatically"
    - "Conflicting changes are detected and resolved appropriately"
  artifacts:
    - path: "src/hooks/useOptimisticUpdates.ts"
      provides: "Optimistic update management with rollback"
      exports: ["useOptimisticUpdates"]
    - path: "src/utils/connection-manager.ts"
      provides: "Connection state monitoring and offline handling"
      exports: ["ConnectionManager"]
    - path: "src/context/ConnectionContext.tsx"
      provides: "Global connection state management"
      exports: ["ConnectionProvider", "useConnection"]
    - path: "native/Sources/Isometry/Bridge/RealTime/ConflictResolver.swift"
      provides: "Server-side conflict detection and resolution"
      exports: ["ConflictResolver"]
    - path: "src/components/shared/ConnectionStatus.tsx"
      provides: "User-facing connection status display"
      exports: ["ConnectionStatus"]
  key_links:
    - from: "useOptimisticUpdates"
      to: "database operations"
      via: "optimistic state + actual operation"
      pattern: "setState.*optimistic.*then.*actualQuery"
    - from: "ConnectionManager"
      to: "WebView bridge"
      via: "connection monitoring"
      pattern: "webView.*postMessage.*heartbeat"
    - from: "ConflictResolver"
      to: "database transactions"
      via: "conflict detection queries"
      pattern: "detectConflicts.*lastModified"
---

<objective>
Complete real-time change notification system with optimistic updates, connection state awareness, and conflict resolution to provide responsive offline-capable user experience with proper error handling.

Purpose: Enable instant UI responsiveness with optimistic updates while maintaining data consistency through proper conflict resolution and offline support.
Output: Production-ready real-time sync system with connection management and conflict handling.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-real-time-change-notifications/19-CONTEXT.md
@.planning/phases/19-real-time-change-notifications/19-01-SUMMARY.md

# Dependencies from Plan 01
@src/hooks/useLiveQuery.ts
@src/context/LiveDataContext.tsx
@native/Sources/Isometry/Bridge/RealTime/ChangeNotificationBridge.swift

# Phase 18 infrastructure
@src/utils/bridge-optimization/performance-monitor.ts
@native/Sources/Isometry/Bridge/Optimization/CircuitBreaker.swift
</context>

<tasks>

<task type="auto">
  <name>Optimistic Updates and Connection Management</name>
  <files>
    src/hooks/useOptimisticUpdates.ts
    src/utils/connection-manager.ts
    src/context/ConnectionContext.tsx
  </files>
  <action>
    Implement optimistic updates with rollback capability and connection state awareness:

    1. Create useOptimisticUpdates hook:
       - Manage optimistic state separate from actual database state
       - Apply optimistic updates immediately for user actions (card edits, property changes)
       - Track pending operations with correlation IDs for debugging
       - Implement rollback mechanism for failed operations with user notification
       - Use merge-first philosophy from Phase 19 context for conflict handling
       - Integrate with useLiveQuery for actual data state reconciliation

    2. Implement ConnectionManager:
       - Monitor WebView bridge connectivity using heartbeat messages
       - Detect online/offline state changes and notify subscribers
       - Implement reconnection logic with exponential backoff (2s, 4s, 8s max)
       - Queue operations during offline periods for sync on reconnection
       - Use Circuit Breaker from Phase 18 for connection failure detection
       - Track connection quality metrics (latency, packet loss patterns)

    3. Create ConnectionContext provider:
       - Global connection state (online/offline/reconnecting/syncing)
       - Pending operations queue for offline scenarios
       - Connection quality indicators and adaptive behavior
       - Integration with LiveDataContext for coordinated state management
       - Provide connection status to components via useConnection hook

    Reference Phase 19 context decisions: instant updates by default, hidden status unless problems, graceful degradation offline.

    Follow established React patterns with proper TypeScript types and error boundaries.
  </action>
  <verify>npm run build && echo "TypeScript compilation successful with optimistic updates and connection management"</verify>
  <done>useOptimisticUpdates provides instant UI updates with rollback, ConnectionManager tracks bridge connectivity, ConnectionContext coordinates global connection state</done>
</task>

<task type="auto">
  <name>Conflict Resolution and Status Display</name>
  <files>
    native/Sources/Isometry/Bridge/RealTime/ConflictResolver.swift
    src/components/shared/ConnectionStatus.tsx
  </files>
  <action>
    Implement conflict detection and resolution with user-facing status display:

    1. Create ConflictResolver Swift actor:
       - Detect conflicts using lastModified timestamps and version vectors
       - Implement dependency-aware ordering from Phase 19 context decisions
       - Use context-aware conflict resolution showing full card/relationship context
       - Provide automatic resolution for simple conflicts (text edits, non-overlapping changes)
       - Defer complex conflicts for user resolution with persistent reminders
       - Maintain full conflict log for debugging and collaboration pattern analysis
       - Integration with ChangeNotificationBridge for conflict event routing

    2. Implement ConnectionStatus React component:
       - Hidden by default, appears only when connection problems occur
       - Subtle loading indicators on affected components during sync
       - Clear offline/online status with adaptive behavior messaging
       - Progress display for background sync when connection restores
       - Alert system integration for connection quality degradation
       - Theme system compatibility (NeXTSTEP/Modern themes)

    3. Integration with existing systems:
       - Connect ConflictResolver to database transaction boundaries
       - Route conflict notifications through ChangeNotificationBridge
       - Update PerformanceMonitor to track conflict resolution metrics
       - Add conflict state to LiveDataContext for component awareness

    Reference Phase 19 context: merge-first philosophy, context-aware conflicts, auto-defer complex conflicts.

    Follow established Swift concurrency patterns and React component conventions.
  </action>
  <verify>swift build && npm run build && echo "Conflict resolution and status display compilation successful"</verify>
  <done>ConflictResolver detects and resolves database conflicts using merge-first approach, ConnectionStatus provides clear user feedback on connection state</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Real-time change notification system with optimistic updates, connection management, and conflict resolution</what-built>
  <how-to-verify>
    1. Start development environment: `npm run dev`
    2. Open browser developer tools to monitor WebView bridge messages
    3. Test live query updates:
       - Create/edit a card in one component
       - Verify immediate optimistic update appears
       - Confirm actual database change propagates to other components within 100ms
    4. Test connection handling:
       - Disable network connection
       - Verify offline status appears and editing still works locally
       - Re-enable connection and confirm background sync occurs
    5. Test conflict scenarios:
       - Simulate concurrent edits (edit same card in multiple places)
       - Verify conflict detection and resolution workflow
    6. Monitor performance dashboard for real-time sync metrics
    Expected behavior: Instant UI updates, sub-100ms change propagation, clear offline/online status, automatic conflict resolution
  </how-to-verify>
  <resume-signal>Type "approved" when real-time sync works as expected, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
End-to-end real-time synchronization verification:
1. Swift compilation confirms ConflictResolver and bridge integration
2. TypeScript compilation confirms optimistic updates and connection management
3. Manual testing validates live query performance and offline capability
4. Performance monitoring shows sub-100ms change notification latency
5. Conflict resolution workflow handles concurrent editing scenarios
</verification>

<success_criteria>
1. UI responds instantly to user actions with optimistic updates and rollback on failure
2. Database changes from any source propagate to UI within 100ms via live queries
3. Application clearly displays connection status and operates fully offline
4. Failed operations automatically rollback with proper state cleanup and user notification
5. Change events arrive in correct chronological order preventing race conditions
</success_criteria>

<output>
After completion, create `.planning/phases/19-real-time-change-notifications/19-02-SUMMARY.md`
</output>