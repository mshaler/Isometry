---
phase: 19-real-time-change-notifications
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - native/Sources/Isometry/Database/IsometryDatabase.swift
  - native/Sources/Isometry/Bridge/RealTime/ChangeNotificationBridge.swift
  - src/hooks/useLiveQuery.ts
  - src/utils/bridge-optimization/change-notifier.ts
  - src/context/LiveDataContext.tsx
autonomous: true

must_haves:
  truths:
    - "User sees immediate UI updates when they edit cards (sub-100ms)"
    - "User receives live updates when database changes from other sources"
    - "Query results automatically refresh without manual reload"
    - "Multiple components stay synchronized with same data"
    - "Change events arrive in correct chronological order preventing race conditions"
  artifacts:
    - path: "native/Sources/Isometry/Database/IsometryDatabase.swift"
      provides: "GRDB ValueObservation setup"
      exports: ["observeQuery", "startChangeNotifications"]
    - path: "native/Sources/Isometry/Bridge/RealTime/ChangeNotificationBridge.swift"
      provides: "Bridge layer for change notifications"
      exports: ["ChangeNotificationBridge"]
    - path: "src/hooks/useLiveQuery.ts"
      provides: "React hook for live database queries"
      exports: ["useLiveQuery"]
    - path: "src/context/LiveDataContext.tsx"
      provides: "Global context for live data state"
      exports: ["LiveDataProvider", "useLiveDataContext"]
  key_links:
    - from: "GRDB ValueObservation"
      to: "ChangeNotificationBridge"
      via: "database change events"
      pattern: "ValueObservation.*onChange"
    - from: "ChangeNotificationBridge"
      to: "useLiveQuery hook"
      via: "WebView message handler"
      pattern: "webView.*messageHandler.*liveData"
    - from: "useLiveQuery"
      to: "React component state"
      via: "useState updates"
      pattern: "setState.*queryResult"
---

<objective>
Implement live database query results using GRDB ValueObservation that automatically update React components when data changes, providing sub-100ms change notifications through the optimized bridge infrastructure.

Purpose: Enable real-time UI updates without manual refresh, creating responsive user experience for data editing and visualization.
Output: Working live query system with React hooks and Swift database change detection.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-real-time-change-notifications/19-CONTEXT.md
@.planning/phases/18-bridge-optimization-foundation/18-01-SUMMARY.md
@.planning/phases/18-bridge-optimization-foundation/18-03-SUMMARY.md

# Existing infrastructure to build upon
@src/utils/bridge-optimization/message-batcher.ts
@src/utils/bridge-optimization/binary-serializer.ts
@src/utils/webview-bridge.ts
@native/Sources/Isometry/Database/IsometryDatabase.swift
@native/Sources/Isometry/WebView/WebViewBridge.swift
</context>

<tasks>

<task type="auto">
  <name>Swift GRDB ValueObservation Implementation</name>
  <files>
    native/Sources/Isometry/Database/IsometryDatabase.swift
    native/Sources/Isometry/Bridge/RealTime/ChangeNotificationBridge.swift
  </files>
  <action>
    Implement GRDB ValueObservation in IsometryDatabase actor for real-time change detection:

    1. Add ValueObservation methods to IsometryDatabase:
       - observeQuery(sql: String, arguments: StatementArguments) -> AsyncThrowingStream<[[String: Any]], Error>
       - startChangeNotifications() to initialize observation infrastructure
       - Use ValueObservation.trackingConstantRegion() for query-specific monitoring
       - Implement proper cancellation and cleanup for observation streams

    2. Create ChangeNotificationBridge actor:
       - Bridge ValueObservation changes to WebView message handler
       - Use MessageBatcher from Phase 18 for efficient change batching (16ms intervals)
       - Integrate BinarySerializer for MessagePack encoding of change events
       - Handle observation lifecycle (start/stop/cleanup)
       - Add error handling for observation failures
       - CRITICAL: Implement sequence number tracking for change events to prevent race conditions (SYNC-05)
       - Add timestamp ordering for chronological event delivery
       - Handle out-of-order event detection and reordering

    3. Integrate with existing WebViewBridge:
       - Add "liveData" message handler type
       - Route change notifications through existing bridge infrastructure
       - Use feature flags for gradual rollout compatibility
       - Maintain backward compatibility with existing query methods

    Reference Phase 18 patterns: MessageBatcher actor isolation, BinarySerializer integration, performance monitoring hooks.

    Follow established Swift concurrency patterns using async/await and proper actor isolation.
  </action>
  <verify>swift build && echo "Swift compilation successful with ValueObservation integration" && node -e "
    const fs = require('fs');
    const path = '/Users/mshaler/Developer/Projects/Isometry/native/Sources/Isometry/Bridge/RealTime/ChangeNotificationBridge.swift';
    if (fs.existsSync(path)) {
      const content = fs.readFileSync(path, 'utf8');
      if (content.includes('sequence') && content.includes('timestamp')) {
        console.log('✓ Event sequencing implementation detected');
      } else {
        console.log('⚠ Event sequencing not implemented');
      }
    }
  "</verify>
  <done>IsometryDatabase provides observeQuery method using GRDB ValueObservation, ChangeNotificationBridge routes changes through optimized WebView bridge with sequence number tracking for race condition prevention</done>
</task>

<task type="auto">
  <name>React Live Query Infrastructure</name>
  <files>
    src/hooks/useLiveQuery.ts
    src/utils/bridge-optimization/change-notifier.ts
    src/context/LiveDataContext.tsx
  </files>
  <action>
    Implement React infrastructure for live database queries with automatic UI updates:

    1. Create useLiveQuery hook:
       - Accept SQL query and arguments, return live query results
       - Use WebView bridge "liveData" messages for real-time updates
       - Implement subscription management (subscribe/unsubscribe on mount/unmount)
       - Handle initial query load + subsequent change notifications
       - Add loading states and error handling
       - Integrate with existing webview-bridge.ts patterns
       - Implement sequence number tracking to match ChangeNotificationBridge ordering

    2. Create ChangeNotifier utility:
       - Manage WebView message subscriptions for live data
       - Route change notifications to appropriate query subscriptions
       - Use BinarySerializer from Phase 18 for MessagePack decoding
       - Handle subscription lifecycle and cleanup
       - Add correlation ID tracking for debugging
       - Implement event ordering verification to prevent race conditions

    3. Create LiveDataContext provider:
       - Global context for live data state and configuration
       - Connection status tracking (connected/disconnected/syncing)
       - Query subscription registry for efficient notification routing
       - Performance metrics integration with Phase 18 PerformanceMonitor
       - Provide useLiveDataContext hook for component access

    Reference Phase 18: webview-bridge.ts patterns, BinarySerializer usage, PerformanceMonitor integration.

    Follow TypeScript best practices with proper type safety and error handling.
  </action>
  <verify>npm run build && echo "TypeScript compilation successful with live query infrastructure" && node -e "
    const fs = require('fs');
    const hookPath = '/Users/mshaler/Developer/Projects/Isometry/src/hooks/useLiveQuery.ts';
    const notifierPath = '/Users/mshaler/Developer/Projects/Isometry/src/utils/bridge-optimization/change-notifier.ts';

    let sequenceCheck = false;
    if (fs.existsSync(hookPath)) {
      const hookContent = fs.readFileSync(hookPath, 'utf8');
      sequenceCheck = hookContent.includes('sequence');
    }
    if (fs.existsSync(notifierPath)) {
      const notifierContent = fs.readFileSync(notifierPath, 'utf8');
      sequenceCheck = sequenceCheck || notifierContent.includes('sequence');
    }

    if (sequenceCheck) {
      console.log('✓ Event sequence tracking implemented in React layer');
    } else {
      console.log('⚠ Event sequence tracking missing in React layer');
    }
  "</verify>
  <done>useLiveQuery hook provides live database results with event ordering, LiveDataContext manages subscription state, ChangeNotifier routes bridge messages to React components with race condition prevention</done>
</task>

</tasks>

<verification>
Test live query functionality with performance validation:
1. Run Swift build to confirm ValueObservation compilation
2. Run TypeScript build to confirm React integration
3. Verify WebView bridge message handling for "liveData" type
4. Confirm integration with Phase 18 optimization infrastructure
5. Test actual change notification latency using performance monitoring dashboard
6. Verify event sequencing prevents race conditions during rapid changes
</verification>

<success_criteria>
1. GRDB ValueObservation monitors database changes and streams results
2. ChangeNotificationBridge routes database changes through WebView bridge using MessagePack with sequence number tracking
3. useLiveQuery React hook provides live database results with automatic UI updates
4. LiveDataContext manages subscription state and connection tracking
5. Integration preserves Phase 18 performance optimizations (16ms batching, binary serialization)
6. Change events arrive in correct chronological order preventing race conditions (SYNC-05)
</success_criteria>

<output>
After completion, create `.planning/phases/19-real-time-change-notifications/19-01-SUMMARY.md`
</output>