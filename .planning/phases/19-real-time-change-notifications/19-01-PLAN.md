---
phase: 19-real-time-change-notifications
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - native/Sources/Isometry/Database/IsometryDatabase.swift
  - native/Sources/Isometry/Bridge/RealTime/ChangeNotificationBridge.swift
  - src/hooks/useLiveQuery.ts
  - src/utils/bridge-optimization/change-notifier.ts
  - src/context/LiveDataContext.tsx
autonomous: true

must_haves:
  truths:
    - "User sees immediate UI updates when they edit cards (sub-100ms)"
    - "User receives live updates when database changes from other sources"
    - "Query results automatically refresh without manual reload"
    - "Multiple components stay synchronized with same data"
  artifacts:
    - path: "native/Sources/Isometry/Database/IsometryDatabase.swift"
      provides: "GRDB ValueObservation setup"
      exports: ["observeQuery", "startChangeNotifications"]
    - path: "native/Sources/Isometry/Bridge/RealTime/ChangeNotificationBridge.swift"
      provides: "Bridge layer for change notifications"
      exports: ["ChangeNotificationBridge"]
    - path: "src/hooks/useLiveQuery.ts"
      provides: "React hook for live database queries"
      exports: ["useLiveQuery"]
    - path: "src/context/LiveDataContext.tsx"
      provides: "Global context for live data state"
      exports: ["LiveDataProvider", "useLiveDataContext"]
  key_links:
    - from: "GRDB ValueObservation"
      to: "ChangeNotificationBridge"
      via: "database change events"
      pattern: "ValueObservation.*onChange"
    - from: "ChangeNotificationBridge"
      to: "useLiveQuery hook"
      via: "WebView message handler"
      pattern: "webView.*messageHandler.*liveData"
    - from: "useLiveQuery"
      to: "React component state"
      via: "useState updates"
      pattern: "setState.*queryResult"
---

<objective>
Implement live database query results using GRDB ValueObservation that automatically update React components when data changes, providing sub-100ms change notifications through the optimized bridge infrastructure.

Purpose: Enable real-time UI updates without manual refresh, creating responsive user experience for data editing and visualization.
Output: Working live query system with React hooks and Swift database change detection.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-real-time-change-notifications/19-CONTEXT.md
@.planning/phases/18-bridge-optimization-foundation/18-01-SUMMARY.md
@.planning/phases/18-bridge-optimization-foundation/18-03-SUMMARY.md

# Existing infrastructure to build upon
@src/utils/bridge-optimization/message-batcher.ts
@src/utils/bridge-optimization/binary-serializer.ts
@src/utils/webview-bridge.ts
@native/Sources/Isometry/Database/IsometryDatabase.swift
@native/Sources/Isometry/WebView/WebViewBridge.swift
</context>

<tasks>

<task type="auto">
  <name>Swift GRDB ValueObservation Implementation</name>
  <files>
    native/Sources/Isometry/Database/IsometryDatabase.swift
    native/Sources/Isometry/Bridge/RealTime/ChangeNotificationBridge.swift
  </files>
  <action>
    Implement GRDB ValueObservation in IsometryDatabase actor for real-time change detection:

    1. Add ValueObservation methods to IsometryDatabase:
       - observeQuery(sql: String, arguments: StatementArguments) -> AsyncThrowingStream<[[String: Any]], Error>
       - startChangeNotifications() to initialize observation infrastructure
       - Use ValueObservation.trackingConstantRegion() for query-specific monitoring
       - Implement proper cancellation and cleanup for observation streams

    2. Create ChangeNotificationBridge actor:
       - Bridge ValueObservation changes to WebView message handler
       - Use MessageBatcher from Phase 18 for efficient change batching (16ms intervals)
       - Integrate BinarySerializer for MessagePack encoding of change events
       - Handle observation lifecycle (start/stop/cleanup)
       - Add error handling for observation failures

    3. Integrate with existing WebViewBridge:
       - Add "liveData" message handler type
       - Route change notifications through existing bridge infrastructure
       - Use feature flags for gradual rollout compatibility
       - Maintain backward compatibility with existing query methods

    Reference Phase 18 patterns: MessageBatcher actor isolation, BinarySerializer integration, performance monitoring hooks.

    Follow established Swift concurrency patterns using async/await and proper actor isolation.
  </action>
  <verify>swift build && echo "Swift compilation successful with ValueObservation integration"</verify>
  <done>IsometryDatabase provides observeQuery method using GRDB ValueObservation, ChangeNotificationBridge routes changes through optimized WebView bridge</done>
</task>

<task type="auto">
  <name>React Live Query Infrastructure</name>
  <files>
    src/hooks/useLiveQuery.ts
    src/utils/bridge-optimization/change-notifier.ts
    src/context/LiveDataContext.tsx
  </files>
  <action>
    Implement React infrastructure for live database queries with automatic UI updates:

    1. Create useLiveQuery hook:
       - Accept SQL query and arguments, return live query results
       - Use WebView bridge "liveData" messages for real-time updates
       - Implement subscription management (subscribe/unsubscribe on mount/unmount)
       - Handle initial query load + subsequent change notifications
       - Add loading states and error handling
       - Integrate with existing webview-bridge.ts patterns

    2. Create ChangeNotifier utility:
       - Manage WebView message subscriptions for live data
       - Route change notifications to appropriate query subscriptions
       - Use BinarySerializer from Phase 18 for MessagePack decoding
       - Handle subscription lifecycle and cleanup
       - Add correlation ID tracking for debugging

    3. Create LiveDataContext provider:
       - Global context for live data state and configuration
       - Connection status tracking (connected/disconnected/syncing)
       - Query subscription registry for efficient notification routing
       - Performance metrics integration with Phase 18 PerformanceMonitor
       - Provide useLiveDataContext hook for component access

    Reference Phase 18: webview-bridge.ts patterns, BinarySerializer usage, PerformanceMonitor integration.

    Follow TypeScript best practices with proper type safety and error handling.
  </action>
  <verify>npm run build && echo "TypeScript compilation successful with live query infrastructure"</verify>
  <done>useLiveQuery hook provides live database results, LiveDataContext manages subscription state, ChangeNotifier routes bridge messages to React components</done>
</task>

</tasks>

<verification>
Test live query functionality:
1. Run Swift build to confirm ValueObservation compilation
2. Run TypeScript build to confirm React integration
3. Verify WebView bridge message handling for "liveData" type
4. Confirm integration with Phase 18 optimization infrastructure
</verification>

<success_criteria>
1. GRDB ValueObservation monitors database changes and streams results
2. ChangeNotificationBridge routes database changes through WebView bridge using MessagePack
3. useLiveQuery React hook provides live database results with automatic UI updates
4. LiveDataContext manages subscription state and connection tracking
5. Integration preserves Phase 18 performance optimizations (16ms batching, binary serialization)
</success_criteria>

<output>
After completion, create `.planning/phases/19-real-time-change-notifications/19-01-SUMMARY.md`
</output>