---
phase: 07.1-api-bridge
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [
  "src/server/native-api-server.ts",
  "native/Sources/Isometry/HTTPServer/IsometryAPIServer.swift",
  "native/Sources/Isometry/HTTPServer/APIEndpoints.swift",
  "native/Package.swift"
]
autonomous: true

must_haves:
  truths:
    - "Native app exposes HTTP API server matching current sql.js database operations"
    - "API server accepts same SQL queries that React components currently use"
    - "Server responds with same JSON structure as DatabaseContext.execute()"
    - "API endpoints handle all CRUD operations for nodes and notebook_cards"
    - "Server runs on localhost with configurable port for development"
  artifacts:
    - path: "native/Sources/Isometry/HTTPServer/IsometryAPIServer.swift"
      provides: "HTTP server actor wrapping IsometryDatabase"
      min_lines: 150
      exports: ["start", "stop", "port"]
    - path: "native/Sources/Isometry/HTTPServer/APIEndpoints.swift"
      provides: "Endpoint handlers matching sql.js operations"
      min_lines: 200
      contains: ["executeSQL", "getNodes", "createNode", "searchNodes"]
    - path: "src/server/native-api-server.ts"
      provides: "Development server launcher for React prototype testing"
      min_lines: 50
      exports: ["startNativeAPIServer", "stopNativeAPIServer"]
  key_links:
    - from: "React DatabaseContext.execute()"
      to: "HTTP POST /api/execute"
      via: "fetch() calls with SQL + params"
      pattern: "fetch.*api/execute.*sql.*params"
    - from: "IsometryAPIServer.swift"
      to: "IsometryDatabase"
      via: "actor method calls"
      pattern: "database\\.(execute|createNode|getNodes)"
---

<objective>
Create native HTTP API server that exposes IsometryDatabase operations through REST endpoints, providing drop-in compatibility for existing React sql.js queries.

Purpose: Establish foundation for migrating from sql.js to native backend while preserving exact same React component interfaces and data flow patterns.

Output: Production-ready API server integrated into native app that can replace sql.js for React prototype development and testing.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/db/DatabaseContext.tsx
@src/db/init.ts
@native/Sources/Isometry/Database/IsometryDatabase.swift
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HTTP API server framework in native app</name>
  <files>
    native/Sources/Isometry/HTTPServer/IsometryAPIServer.swift
    native/Sources/Isometry/HTTPServer/APIEndpoints.swift
    native/Package.swift
  </files>
  <action>
    Add Hummingbird (Swift HTTP server) dependency to native/Package.swift and create IsometryAPIServer actor that wraps IsometryDatabase with HTTP interface.

    Create IsometryAPIServer.swift with:
    - Actor that manages HTTP server lifecycle and database connection
    - start() method accepting port parameter (default 8080)
    - stop() method for clean shutdown
    - Request routing to APIEndpoints handlers
    - CORS headers for React prototype access
    - Error handling with proper HTTP status codes
    - JSON encoding/decoding for all request/response data

    Create APIEndpoints.swift with handlers for:
    - POST /api/execute: Execute raw SQL with parameters (matches DatabaseContext.execute)
    - GET /api/nodes: Get all nodes with optional folder/type filters
    - POST /api/nodes: Create new node
    - GET /api/nodes/:id: Get node by ID
    - PUT /api/nodes/:id: Update existing node
    - DELETE /api/nodes/:id: Soft delete node
    - GET /api/search: Full-text search across nodes and notebook cards
    - All notebook_cards endpoints mirroring nodes structure

    Use existing IsometryDatabase patterns - all operations should be async and use database actor methods. Include comprehensive error handling and validation.
  </action>
  <verify>
    cd native && swift build
    Swift build succeeds with no compilation errors
    swift test shows all existing tests still pass
  </verify>
  <done>
    Native app can start HTTP API server on localhost:8080 and respond to basic health check requests with 200 status
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement SQL execution endpoint with compatibility layer</name>
  <files>
    native/Sources/Isometry/HTTPServer/SQLExecutor.swift
    native/Sources/Isometry/HTTPServer/QueryTranslator.swift
  </files>
  <action>
    Create SQLExecutor.swift that handles raw SQL execution with parameter binding:
    - Parse incoming SQL statements for safety (whitelist allowed operations)
    - Bind parameters using GRDB parameter binding (not string interpolation)
    - Execute queries through IsometryDatabase and return results in sql.js format
    - Handle both SELECT (returns data) and INSERT/UPDATE/DELETE (returns affected rows)
    - Format results to match exact structure from DatabaseContext.execute()

    Create QueryTranslator.swift for common query patterns:
    - Map frequently used React queries to optimized database methods
    - Cache prepared statements for performance
    - Translate sql.js-specific syntax to GRDB where needed
    - Handle FTS5 queries properly for search functionality
    - Support both raw SQL execution and translated method calls

    Result format must match sql.js exactly:
    ```json
    [
      {"id": "uuid", "name": "value", "created_at": "2024-01-01T00:00:00Z"},
      {"id": "uuid2", "name": "value2", "created_at": "2024-01-01T00:01:00Z"}
    ]
    ```

    Include comprehensive input validation and SQL injection prevention.
  </action>
  <verify>
    Create simple test endpoint and verify it returns data in exact same format as current sql.js implementation
    curl -X POST http://localhost:8080/api/execute -d '{"sql":"SELECT * FROM nodes LIMIT 5","params":[]}' returns valid JSON
  </verify>
  <done>
    API server can execute all SQL queries currently used by React components and return results in identical format to sql.js
  </done>
</task>

<task type="auto">
  <name>Task 3: Create development launcher for React prototype testing</name>
  <files>
    src/server/native-api-server.ts
    src/server/launch-native-server.js
    package.json
  </files>
  <action>
    Create native-api-server.ts that launches the native app's HTTP server for development:
    - Use Node.js child_process to spawn native app binary
    - Pass --api-server flag and port configuration
    - Wait for server to be ready before resolving promise
    - Handle graceful shutdown when development server stops
    - Provide TypeScript interfaces matching the native API responses

    Create launch-native-server.js script:
    - Build native app if needed (swift build)
    - Start native API server on available port
    - Export port number for React development server
    - Handle cleanup on process exit

    Update package.json scripts:
    - Add "start:native-api" script to launch native server
    - Modify "dev" script to optionally use native API (environment flag)
    - Add development dependency for cross-platform process management

    Include environment variable REACT_APP_USE_NATIVE_API to toggle between sql.js and native API during development.
  </action>
  <verify>
    npm run start:native-api starts native server successfully
    Server responds to health check at localhost:PORT/health
    npm run dev with REACT_APP_USE_NATIVE_API=true can connect to native server
  </verify>
  <done>
    React prototype can optionally use native API server instead of sql.js for development testing, controlled by environment variable
  </done>
</task>

</tasks>

<verification>
1. Native HTTP server starts on configurable port and handles CORS for React
2. All SQL queries from current React components work through API endpoints
3. Response format exactly matches sql.js DatabaseContext.execute() structure
4. Development workflow allows toggling between sql.js and native API
5. No changes required to existing React components or data flow
</verification>

<success_criteria>
- [ ] Native app exposes HTTP API server with all database operations
- [ ] API endpoints accept same SQL queries as current DatabaseContext.execute()
- [ ] Response format maintains exact compatibility with sql.js output
- [ ] React prototype can connect to native API with zero component changes
- [ ] Development environment supports easy switching between sql.js and native
</success_criteria>

<output>
After completion, create `.planning/phases/07.1-api-bridge/07.1-01-SUMMARY.md`
</output>