---
phase: 07.1-api-bridge
plan: 03
type: execute
wave: 3
depends_on: ["07.1-02"]
files_modified: [
  "src/db/QueryTranslation.ts",
  "src/hooks/useSQLiteQuery.ts",
  "src/hooks/useOptimizedQueries.ts",
  "src/db/PerformanceMonitor.ts"
]
autonomous: true

must_haves:
  truths:
    - "Common React queries use optimized native endpoints instead of raw SQL"
    - "Query translation layer provides sql.js compatibility while improving performance"
    - "Performance monitoring validates native API equals or exceeds sql.js speed"
    - "Caching mechanisms work consistently across both implementations"
    - "Real-world React usage patterns show no regression in responsiveness"
  artifacts:
    - path: "src/db/QueryTranslation.ts"
      provides: "Smart query routing and optimization layer"
      min_lines: 80
      exports: ["translateQuery", "shouldOptimize", "QueryOptimizer"]
    - path: "src/hooks/useOptimizedQueries.ts"
      provides: "Hooks for common data access patterns"
      min_lines: 100
      exports: ["useNodes", "useNotebookCards", "useSearch"]
    - path: "src/db/PerformanceMonitor.ts"
      provides: "Performance comparison and monitoring"
      min_lines: 60
      exports: ["PerformanceMonitor", "logQueryPerformance"]
  key_links:
    - from: "useNodes() hook"
      to: "GET /api/nodes"
      via: "optimized endpoint instead of SELECT * FROM nodes"
      pattern: "fetch.*api/nodes.*filter"
    - from: "QueryTranslation.translateQuery()"
      to: "native API endpoints"
      via: "pattern matching and route optimization"
      pattern: "translateQuery.*sql.*endpoint"
    - from: "PerformanceMonitor"
      to: "both sql.js and native operations"
      via: "timing measurement and comparison"
      pattern: "performance\\.time.*operation.*duration"
---

<objective>
Implement query translation and optimization layer that routes common React queries to optimized native endpoints while maintaining sql.js compatibility for complex queries.

Purpose: Maximize performance benefits of native backend while ensuring 100% compatibility with existing React query patterns and providing performance validation.

Output: Intelligent query layer that optimizes performance while maintaining perfect backward compatibility with comprehensive performance monitoring.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07.1-api-bridge/07.1-01-PLAN.md
@.planning/phases/07.1-api-bridge/07.1-02-PLAN.md
@src/db/DatabaseContext.tsx
@src/hooks/useSQLiteQuery.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create query translation and optimization layer</name>
  <files>
    src/db/QueryTranslation.ts
  </files>
  <action>
    Create QueryTranslation.ts that intelligently routes queries for optimal performance:

    Export QueryOptimizer class:
    - analyzeQuery(sql: string, params?: unknown[]): QueryAnalysis
    - shouldOptimize(analysis: QueryAnalysis): boolean
    - translateToEndpoint(analysis: QueryAnalysis): OptimizedCall | null
    - fallbackToSQL(sql: string, params?: unknown[]): SQLCall

    Query pattern matching for common React operations:
    - "SELECT * FROM nodes WHERE deleted_at IS NULL" → GET /api/nodes
    - "SELECT * FROM nodes WHERE folder = ?" → GET /api/nodes?folder=X
    - "SELECT * FROM notebook_cards WHERE deleted_at IS NULL ORDER BY modified_at DESC" → GET /api/notebook-cards?sort=modified_at
    - "FTS queries with MATCH" → GET /api/search?q=X
    - "INSERT INTO nodes ..." → POST /api/nodes
    - "UPDATE nodes SET ... WHERE id = ?" → PUT /api/nodes/:id

    Export translateQuery function:
    - Accept sql.js-style execute() parameters
    - Return either OptimizedCall or SQLCall
    - Handle parameter binding and URL construction
    - Preserve exact result format compatibility
    - Log translation decisions for performance analysis

    Fallback strategy:
    - Complex queries fall back to raw SQL execution
    - Custom joins and subqueries use SQL endpoint
    - Ensure 100% compatibility for edge cases
    - Maintain performance for both optimized and fallback paths

    Include comprehensive TypeScript interfaces for all query types and responses.
  </action>
  <verify>
    TypeScript compilation succeeds with new query translation types
    translateQuery() correctly identifies and routes common React query patterns
    Fallback mechanism handles complex queries that can't be optimized
  </verify>
  <done>
    Query translation layer intelligently routes common queries to optimized endpoints while maintaining sql.js compatibility for all cases
  </done>
</task>

<task type="auto">
  <name>Task 2: Create optimized hooks for common data patterns</name>
  <files>
    src/hooks/useOptimizedQueries.ts
    src/hooks/useSQLiteQuery.ts
  </files>
  <action>
    Create useOptimizedQueries.ts with high-level hooks for common data access:

    Export useNodes(options?: NodesQueryOptions):
    - Options: { folder?: string, type?: string, deleted?: boolean, limit?: number }
    - Uses GET /api/nodes with query parameters instead of raw SQL
    - Handles loading, error, and caching states
    - Returns same data structure as raw SQL queries
    - Includes optimistic updates for mutations

    Export useNotebookCards(options?: NotebookCardsQueryOptions):
    - Options: { folder?: string, search?: string, sort?: string }
    - Routes to optimized /api/notebook-cards endpoint
    - Supports real-time updates and caching
    - Maintains pagination and filtering capabilities
    - Handles search with FTS5 optimization

    Export useSearch(query: string, options?: SearchOptions):
    - Uses native /api/search endpoint for FTS5 queries
    - Debounces search input automatically
    - Combines results from nodes and notebook_cards
    - Handles empty states and loading indicators
    - Provides result highlighting and ranking

    Update useSQLiteQuery.ts to integrate query translation:
    - Check if query can be optimized before execution
    - Use QueryOptimizer.translateQuery() for routing decisions
    - Maintain existing caching and error handling
    - Preserve backward compatibility with all current usage
    - Add performance timing for comparison

    All hooks must maintain exact same interfaces as current raw SQL usage while providing performance benefits.
  </action>
  <verify>
    Components using useNodes() receive same data as raw SQL queries
    useNotebookCards() works with existing notebook UI components
    useSearch() provides faster FTS5 results than raw SQL approach
  </verify>
  <done>
    Optimized hooks provide better performance for common queries while maintaining identical interfaces to existing SQL-based hooks
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement performance monitoring and validation</name>
  <files>
    src/db/PerformanceMonitor.ts
    src/db/NativeAPIClient.ts
    src/db/DatabaseContext.tsx
  </files>
  <action>
    Create PerformanceMonitor.ts for comprehensive performance validation:

    Export PerformanceMonitor class:
    - measureOperation(name: string, operation: () => Promise<T>): Promise<T>
    - logQueryPerformance(query: string, duration: number, method: 'sql.js' | 'native')
    - getPerformanceReport(): PerformanceReport
    - compareImplementations(sql: string, params?: unknown[]): Promise<ComparisonResult>

    Performance tracking capabilities:
    - Time all database operations with high-precision timestamps
    - Track memory usage during queries (if available)
    - Monitor network latency for native API calls
    - Compare sql.js vs native performance for identical queries
    - Generate performance reports and recommendations

    Update NativeAPIClient.ts:
    - Integrate PerformanceMonitor for all HTTP operations
    - Track request/response times and payload sizes
    - Monitor connection establishment overhead
    - Log network errors and retry attempts
    - Provide performance insights in development mode

    Update DatabaseContext.tsx:
    - Add performance monitoring to both sql.js and native providers
    - Enable side-by-side performance comparison in development
    - Log performance data to console in dev mode
    - Export performance data for analysis and optimization

    Development features:
    - Console warnings for queries slower than thresholds
    - Performance comparison mode (run same query with both providers)
    - Export performance data as JSON for analysis
    - Real-time performance dashboard in dev tools

    Include performance validation that native implementation equals or exceeds sql.js speed for typical operations.
  </action>
  <verify>
    Performance monitoring captures accurate timing data for both implementations
    Console shows performance comparisons in development mode
    Native API performance equals or exceeds sql.js for common operations
  </verify>
  <done>
    Comprehensive performance monitoring validates that native API implementation provides equal or better performance than sql.js with detailed insights
  </done>
</task>

</tasks>

<verification>
1. Query translation optimizes common patterns while maintaining sql.js fallback
2. High-level hooks provide better performance for typical React data access
3. Performance monitoring validates native implementation meets speed requirements
4. All existing React components work without changes using optimized queries
5. Development tools provide insights for performance optimization and validation
</verification>

<success_criteria>
- [ ] Common React queries route to optimized native endpoints automatically
- [ ] Query translation maintains 100% sql.js compatibility for complex queries
- [ ] Performance monitoring shows native API equals or exceeds sql.js speed
- [ ] Optimized hooks provide better performance while maintaining same interfaces
- [ ] Development workflow includes performance validation and comparison tools
</success_criteria>

<output>
After completion, create `.planning/phases/07.1-api-bridge/07.1-03-SUMMARY.md`
</output>