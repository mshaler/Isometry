---
phase: 07.1-api-bridge
plan: 02
type: execute
wave: 2
depends_on: ["07.1-01"]
files_modified: [
  "src/db/NativeDatabaseContext.tsx",
  "src/db/NativeAPIClient.ts",
  "src/db/DatabaseContext.tsx",
  "src/main.tsx"
]
autonomous: true

must_haves:
  truths:
    - "React app can switch between sql.js and native API without component changes"
    - "NativeDatabaseContext provides identical interface to existing DatabaseContext"
    - "All database operations work through native API client"
    - "Error handling maintains same patterns as sql.js implementation"
    - "Performance equals or exceeds sql.js for typical operations"
  artifacts:
    - path: "src/db/NativeDatabaseContext.tsx"
      provides: "React context using native API instead of sql.js"
      min_lines: 120
      exports: ["NativeDatabaseProvider", "useNativeDatabase"]
    - path: "src/db/NativeAPIClient.ts"
      provides: "HTTP client wrapping native API endpoints"
      min_lines: 100
      exports: ["NativeAPIClient", "createClient"]
    - path: "src/db/DatabaseContext.tsx"
      provides: "Updated context with conditional provider selection"
      contains: "REACT_APP_USE_NATIVE_API"
  key_links:
    - from: "NativeAPIClient.execute()"
      to: "HTTP POST localhost:8080/api/execute"
      via: "fetch() with SQL and params"
      pattern: "fetch.*execute.*sql.*params"
    - from: "NativeDatabaseContext"
      to: "NativeAPIClient"
      via: "client instance in context value"
      pattern: "client\\.execute\\(.*sql.*params"
    - from: "React components"
      to: "useNativeDatabase() or useDatabase()"
      via: "identical hook interfaces"
      pattern: "const \\{ execute.*\\} = use.*Database"
---

<objective>
Replace sql.js DatabaseContext with NativeDatabaseContext that connects to native API server, providing identical interface for React components while routing all operations through HTTP endpoints.

Purpose: Enable React prototype to use production GRDB/CloudKit backend while maintaining exact same component code and data access patterns.

Output: Drop-in replacement for sql.js that routes all database operations to native API server with zero breaking changes to React UI layer.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07.1-api-bridge/07.1-01-PLAN.md
@src/db/DatabaseContext.tsx
@src/db/init.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create native API client with HTTP operations</name>
  <files>
    src/db/NativeAPIClient.ts
  </files>
  <action>
    Create NativeAPIClient.ts that wraps native HTTP API endpoints:

    Export class NativeAPIClient with methods:
    - execute<T>(sql: string, params?: unknown[]): Promise<T[]> - matches sql.js interface exactly
    - save(): Promise<void> - no-op for compatibility (native handles persistence)
    - reset(): Promise<void> - calls native reset endpoint
    - isConnected(): boolean - tracks connection status

    HTTP operations:
    - POST /api/execute with {sql: string, params: unknown[]} body
    - GET /api/health for connection testing
    - Handle network errors gracefully with retry logic
    - Parse JSON responses and maintain exact sql.js result format
    - Add request timeout (5 seconds) and connection validation

    Error handling:
    - Wrap HTTP errors in same Error types as sql.js
    - Provide meaningful error messages for network issues
    - Handle server unavailable scenarios gracefully
    - Log errors consistently with existing patterns

    Export createClient() factory function:
    - Accept baseURL parameter (defaults to localhost:8080)
    - Test connection on creation
    - Return configured client instance
    - Handle CORS configuration for development

    Include TypeScript types matching existing DatabaseContextValue interface exactly.
  </action>
  <verify>
    npm run typecheck passes with no TypeScript errors
    Client can connect to native server from previous plan
    execute() method returns data in exact same format as sql.js
  </verify>
  <done>
    Native API client provides identical interface to sql.js with HTTP transport layer handling all database operations
  </done>
</task>

<task type="auto">
  <name>Task 2: Create NativeDatabaseContext with identical interface</name>
  <files>
    src/db/NativeDatabaseContext.tsx
  </files>
  <action>
    Create NativeDatabaseContext.tsx that mirrors existing DatabaseContext exactly:

    Export interface NativeDatabaseContextValue matching DatabaseContextValue:
    - db: NativeAPIClient | null (instead of Database | null)
    - loading: boolean
    - error: Error | null
    - execute: <T = Record<string, unknown>>(sql: string, params?: unknown[]) => Promise<T[]>
    - save: () => Promise<void>
    - reset: () => Promise<void>

    Export NativeDatabaseProvider component:
    - Initialize NativeAPIClient on mount
    - Handle loading/error states identically to DatabaseProvider
    - Use same useEffect patterns and state management
    - Implement async initialization with connection testing
    - Handle reconnection on failures

    Export useNativeDatabase() hook:
    - Return same interface as useDatabase()
    - Throw identical error if used outside provider
    - Provide same TypeScript types and IntelliSense

    Context management:
    - Use same React patterns as existing DatabaseContext
    - Handle client lifecycle (connect/disconnect)
    - Manage loading states during server communication
    - Cache client instance to prevent unnecessary reconnections

    The interface must be 100% compatible - components should work with either provider without any changes.
  </action>
  <verify>
    TypeScript compilation succeeds with NativeDatabaseProvider
    useNativeDatabase() hook returns identical interface to useDatabase()
    Components can import and use NativeDatabaseProvider as drop-in replacement
  </verify>
  <done>
    NativeDatabaseContext provides exact same interface as sql.js DatabaseContext, allowing zero-change component migration
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement conditional database provider selection</name>
  <files>
    src/db/DatabaseContext.tsx
    src/main.tsx
    src/hooks/useSQLiteQuery.ts
  </files>
  <action>
    Update DatabaseContext.tsx to support conditional provider selection:
    - Import NativeDatabaseProvider and NativeDatabaseContext
    - Add environment variable check: process.env.REACT_APP_USE_NATIVE_API
    - Export unified DatabaseProvider that conditionally renders sql.js or native provider
    - Export unified useDatabase() hook that works with both contexts
    - Maintain backward compatibility with existing imports

    Update main.tsx:
    - Use unified DatabaseProvider (automatically selects implementation)
    - Add environment variable documentation in comments
    - Ensure both provider types wrap the app correctly
    - Handle provider switching without breaking app state

    Update useSQLiteQuery.ts hook:
    - Work with both sql.js and native database contexts
    - Maintain same query patterns and caching behavior
    - Handle loading states consistently across implementations
    - Preserve existing error handling and retry logic

    Environment variable behavior:
    - REACT_APP_USE_NATIVE_API=true: Use NativeDatabaseProvider
    - REACT_APP_USE_NATIVE_API=false or undefined: Use sql.js DatabaseProvider
    - Add runtime validation and fallback to sql.js if native fails

    Include development documentation explaining the provider switching mechanism.
  </action>
  <verify>
    REACT_APP_USE_NATIVE_API=false npm run dev uses sql.js (existing behavior)
    REACT_APP_USE_NATIVE_API=true npm run dev uses native API (new behavior)
    All existing components work without modification in both modes
  </verify>
  <done>
    React app supports seamless switching between sql.js and native API via environment variable with zero component changes required
  </done>
</task>

</tasks>

<verification>
1. React components work identically with both sql.js and native providers
2. Database operations maintain same performance and error handling characteristics
3. Environment variable controls provider selection with proper fallbacks
4. TypeScript interfaces remain consistent across both implementations
5. Development workflow supports easy switching for testing and comparison
</verification>

<success_criteria>
- [ ] NativeAPIClient provides identical interface to sql.js Database
- [ ] NativeDatabaseContext mirrors existing DatabaseContext exactly
- [ ] Components require zero changes to work with native provider
- [ ] Environment variable enables seamless provider switching
- [ ] Performance equals or exceeds sql.js for typical React operations
</success_criteria>

<output>
After completion, create `.planning/phases/07.1-api-bridge/07.1-02-SUMMARY.md`
</output>