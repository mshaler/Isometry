---
phase: 84-cards-and-connections
plan: 04
type: execute
wave: 3
depends_on: ["84-03"]
files_modified:
  - src/db/__tests__/cards-integration.test.ts
  - src/db/schema.sql
autonomous: true

must_haves:
  truths:
    - "Full test suite passes (npm run test)"
    - "TypeScript compiles clean (npm run typecheck)"
    - "SuperGrid renders correctly with card data"
    - "FTS5 search returns correct cards"
    - "ETL importers produce valid cards"
    - "Backup tables documented for rollback"
  artifacts:
    - path: "src/db/__tests__/cards-integration.test.ts"
      provides: "Integration tests for cards/connections"
      contains: "describe.*Card"
    - path: ".planning/phases/84-cards-and-connections/84-04-SUMMARY.md"
      provides: "Phase completion summary"
      contains: "COMPLETE"
  key_links:
    - from: "src/db/__tests__/cards-integration.test.ts"
      to: "src/types/card.ts"
      via: "import Card"
      pattern: "import.*Card"
---

<objective>
Verify complete migration, run full test suite, and document cleanup path.

Purpose: Ensure the cards/connections migration is complete and functional. Document the rollback procedure and cleanup steps for backup tables.

Output: Passing test suite, verified SuperGrid/ETL functionality, documented cleanup procedure.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/84-cards-and-connections/84-01-SUMMARY.md
@.planning/phases/84-cards-and-connections/84-02-SUMMARY.md
@.planning/phases/84-cards-and-connections/84-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write integration tests for cards/connections</name>
  <files>src/db/__tests__/cards-integration.test.ts</files>
  <action>
Create comprehensive integration tests at src/db/__tests__/cards-integration.test.ts:

```typescript
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import initSqlJs, { Database } from 'sql.js';
import { readFileSync } from 'fs';
import { join } from 'path';
import { rowToCard, rowToConnection, isNote, isPerson, isEvent, isResource } from '@/types/card';

describe('Cards & Connections Integration', () => {
  let db: Database;

  beforeEach(async () => {
    const SQL = await initSqlJs();
    db = new SQL.Database();

    // Load full schema
    const schema = readFileSync(join(__dirname, '../../schema.sql'), 'utf-8');
    db.run(schema);
  });

  afterEach(() => {
    db.close();
  });

  describe('Card CRUD operations', () => {
    it('creates a note card', () => {
      db.run(`
        INSERT INTO cards (id, card_type, name, content, folder, priority)
        VALUES ('n1', 'note', 'Test Note', 'Content here', 'work', 5)
      `);

      const result = db.exec('SELECT * FROM cards WHERE id = ?', ['n1']);
      const card = rowToCard(rowToObj(result[0]));

      expect(card.id).toBe('n1');
      expect(card.cardType).toBe('note');
      expect(isNote(card)).toBe(true);
      expect(card.name).toBe('Test Note');
      expect(card.folder).toBe('work');
      expect(card.priority).toBe(5);
    });

    it('creates a person card with isCollective', () => {
      db.run(`
        INSERT INTO cards (id, card_type, name, is_collective)
        VALUES ('p1', 'person', 'Acme Corp', 1)
      `);

      const result = db.exec('SELECT * FROM cards WHERE id = ?', ['p1']);
      const card = rowToCard(rowToObj(result[0]));

      expect(card.cardType).toBe('person');
      expect(isPerson(card)).toBe(true);
      if (isPerson(card)) {
        expect(card.isCollective).toBe(true);
      }
    });

    it('creates an event card with time fields', () => {
      db.run(`
        INSERT INTO cards (id, card_type, name, event_start, event_end)
        VALUES ('e1', 'event', 'Meeting', '2024-02-01T10:00:00Z', '2024-02-01T11:00:00Z')
      `);

      const result = db.exec('SELECT * FROM cards WHERE id = ?', ['e1']);
      const card = rowToCard(rowToObj(result[0]));

      expect(card.cardType).toBe('event');
      expect(isEvent(card)).toBe(true);
      expect(card.eventStart).toBe('2024-02-01T10:00:00Z');
      expect(card.eventEnd).toBe('2024-02-01T11:00:00Z');
    });

    it('creates a resource card with url and mimeType', () => {
      db.run(`
        INSERT INTO cards (id, card_type, name, url, mime_type)
        VALUES ('r1', 'resource', 'Document', 'https://example.com/doc.pdf', 'application/pdf')
      `);

      const result = db.exec('SELECT * FROM cards WHERE id = ?', ['r1']);
      const card = rowToCard(rowToObj(result[0]));

      expect(card.cardType).toBe('resource');
      expect(isResource(card)).toBe(true);
      if (isResource(card)) {
        expect(card.url).toBe('https://example.com/doc.pdf');
        expect(card.mimeType).toBe('application/pdf');
      }
    });

    it('rejects invalid card_type', () => {
      expect(() => {
        db.run(`
          INSERT INTO cards (id, card_type, name)
          VALUES ('x1', 'invalid', 'Bad Card')
        `);
      }).toThrow(); // CHECK constraint violation
    });

    it('soft deletes a card', () => {
      db.run(`INSERT INTO cards (id, card_type, name) VALUES ('d1', 'note', 'To Delete')`);
      db.run(`UPDATE cards SET deleted_at = datetime('now') WHERE id = 'd1'`);

      const active = db.exec(`SELECT * FROM cards WHERE deleted_at IS NULL`);
      const deleted = db.exec(`SELECT * FROM cards WHERE deleted_at IS NOT NULL`);

      expect(active[0]?.values.length || 0).toBe(0);
      expect(deleted[0].values.length).toBe(1);
    });

    it('increments version on update', () => {
      db.run(`INSERT INTO cards (id, card_type, name) VALUES ('v1', 'note', 'Version Test')`);

      const before = db.exec(`SELECT version FROM cards WHERE id = 'v1'`);
      expect(before[0].values[0][0]).toBe(1);

      db.run(`UPDATE cards SET content = 'Updated' WHERE id = 'v1'`);

      const after = db.exec(`SELECT version FROM cards WHERE id = 'v1'`);
      expect(after[0].values[0][0]).toBe(2);
    });
  });

  describe('Connection operations', () => {
    beforeEach(() => {
      // Create test cards
      db.run(`INSERT INTO cards (id, card_type, name) VALUES ('c1', 'note', 'Card 1')`);
      db.run(`INSERT INTO cards (id, card_type, name) VALUES ('c2', 'note', 'Card 2')`);
      db.run(`INSERT INTO cards (id, card_type, name) VALUES ('c3', 'note', 'Bridge Card')`);
    });

    it('creates a basic connection', () => {
      db.run(`
        INSERT INTO connections (id, source_id, target_id, label, weight)
        VALUES ('conn1', 'c1', 'c2', 'references', 0.8)
      `);

      const result = db.exec('SELECT * FROM connections WHERE id = ?', ['conn1']);
      const conn = rowToConnection(rowToObj(result[0]));

      expect(conn.sourceId).toBe('c1');
      expect(conn.targetId).toBe('c2');
      expect(conn.label).toBe('references');
      expect(conn.weight).toBe(0.8);
      expect(conn.viaCardId).toBeNull();
    });

    it('creates a connection with via_card_id', () => {
      db.run(`
        INSERT INTO connections (id, source_id, target_id, via_card_id, label)
        VALUES ('conn2', 'c1', 'c2', 'c3', 'linked-through')
      `);

      const result = db.exec('SELECT * FROM connections WHERE id = ?', ['conn2']);
      const conn = rowToConnection(rowToObj(result[0]));

      expect(conn.viaCardId).toBe('c3');
    });

    it('cascades delete when source card deleted', () => {
      db.run(`INSERT INTO connections (id, source_id, target_id) VALUES ('conn3', 'c1', 'c2')`);

      const before = db.exec(`SELECT * FROM connections`);
      expect(before[0].values.length).toBe(1);

      db.run(`DELETE FROM cards WHERE id = 'c1'`);

      const after = db.exec(`SELECT * FROM connections`);
      expect(after[0]?.values.length || 0).toBe(0);
    });

    it('sets via_card_id to NULL when bridge card deleted', () => {
      db.run(`
        INSERT INTO connections (id, source_id, target_id, via_card_id)
        VALUES ('conn4', 'c1', 'c2', 'c3')
      `);

      db.run(`DELETE FROM cards WHERE id = 'c3'`);

      const result = db.exec(`SELECT via_card_id FROM connections WHERE id = 'conn4'`);
      expect(result[0].values[0][0]).toBeNull();
    });

    it('prevents duplicate connections (same source, target, via_card)', () => {
      db.run(`INSERT INTO connections (id, source_id, target_id) VALUES ('conn5', 'c1', 'c2')`);

      expect(() => {
        db.run(`INSERT INTO connections (id, source_id, target_id) VALUES ('conn6', 'c1', 'c2')`);
      }).toThrow(); // UNIQUE constraint
    });
  });

  describe('FTS5 search on cards', () => {
    beforeEach(() => {
      db.run(`INSERT INTO cards (id, card_type, name, content, folder, tags)
              VALUES ('s1', 'note', 'Meeting Notes', 'Discussed quarterly goals', 'work', '["meeting", "q1"]')`);
      db.run(`INSERT INTO cards (id, card_type, name, content, folder)
              VALUES ('s2', 'note', 'Project Plan', 'Timeline and milestones', 'projects', NULL)`);
    });

    it('searches by name', () => {
      const results = db.exec(`
        SELECT c.* FROM cards_fts
        JOIN cards c ON cards_fts.rowid = c.rowid
        WHERE cards_fts MATCH 'Meeting'
      `);

      expect(results[0].values.length).toBe(1);
      expect(results[0].values[0][2]).toBe('Meeting Notes'); // name column
    });

    it('searches by content', () => {
      const results = db.exec(`
        SELECT c.* FROM cards_fts
        JOIN cards c ON cards_fts.rowid = c.rowid
        WHERE cards_fts MATCH 'quarterly'
      `);

      expect(results[0].values.length).toBe(1);
    });

    it('searches by tags', () => {
      const results = db.exec(`
        SELECT c.* FROM cards_fts
        JOIN cards c ON cards_fts.rowid = c.rowid
        WHERE cards_fts MATCH 'meeting'
      `);

      expect(results[0].values.length).toBe(1);
    });

    it('updates FTS index on card update', () => {
      db.run(`UPDATE cards SET name = 'Updated Meeting Notes' WHERE id = 's1'`);

      const results = db.exec(`
        SELECT c.* FROM cards_fts
        JOIN cards c ON cards_fts.rowid = c.rowid
        WHERE cards_fts MATCH 'Updated'
      `);

      expect(results[0].values.length).toBe(1);
    });

    it('removes from FTS index on card delete', () => {
      db.run(`DELETE FROM cards WHERE id = 's1'`);

      const results = db.exec(`
        SELECT c.* FROM cards_fts
        JOIN cards c ON cards_fts.rowid = c.rowid
        WHERE cards_fts MATCH 'Meeting'
      `);

      expect(results[0]?.values.length || 0).toBe(0);
    });
  });

  describe('Graph traversal with connections', () => {
    beforeEach(() => {
      // Create a small graph: g1 -> g2 -> g3 -> g4
      db.run(`INSERT INTO cards (id, card_type, name) VALUES ('g1', 'note', 'Node 1')`);
      db.run(`INSERT INTO cards (id, card_type, name) VALUES ('g2', 'note', 'Node 2')`);
      db.run(`INSERT INTO cards (id, card_type, name) VALUES ('g3', 'note', 'Node 3')`);
      db.run(`INSERT INTO cards (id, card_type, name) VALUES ('g4', 'note', 'Node 4')`);

      db.run(`INSERT INTO connections (id, source_id, target_id) VALUES ('gc1', 'g1', 'g2')`);
      db.run(`INSERT INTO connections (id, source_id, target_id) VALUES ('gc2', 'g2', 'g3')`);
      db.run(`INSERT INTO connections (id, source_id, target_id) VALUES ('gc3', 'g3', 'g4')`);
    });

    it('finds connected cards with recursive CTE', () => {
      const results = db.exec(`
        WITH RECURSIVE reachable(id, depth) AS (
          SELECT 'g1', 0
          UNION ALL
          SELECT c.target_id, r.depth + 1
          FROM reachable r
          JOIN connections c ON c.source_id = r.id
          WHERE r.depth < 3
        )
        SELECT DISTINCT cards.id, cards.name
        FROM reachable
        JOIN cards ON cards.id = reachable.id
        ORDER BY reachable.depth
      `);

      expect(results[0].values.length).toBe(4);
      expect(results[0].values.map(v => v[0])).toEqual(['g1', 'g2', 'g3', 'g4']);
    });
  });
});

// Helper to convert sql.js result to object
function rowToObj(result: { columns: string[]; values: unknown[][] }): Record<string, unknown> {
  if (!result.values.length) return {};
  const row: Record<string, unknown> = {};
  result.columns.forEach((col, i) => {
    row[col] = result.values[0][i];
  });
  return row;
}
```
  </action>
  <verify>npm run test -- src/db/__tests__/cards-integration.test.ts passes</verify>
  <done>Integration tests verify CRUD, FTS5, connections, and graph traversal</done>
</task>

<task type="auto">
  <name>Task 2: Run full test suite and fix failures</name>
  <files>Various test files as needed</files>
  <action>
Run the complete test suite and fix any failures:

1. Run full test suite:
   ```bash
   npm run test:run
   ```

2. If tests fail, categorize failures:
   - **Type errors**: Update test expectations from Node to Card
   - **Query errors**: Update test SQL from nodes to cards
   - **Missing fields**: Update test assertions for removed/added fields

3. Common fixes needed:
   - Update test imports: `import { Node }` -> `import { Card }`
   - Update test assertions: `.nodeType` -> `.cardType`
   - Update SQL in tests: `FROM nodes` -> `FROM cards`
   - Remove assertions for: locationAddress, importance, grid_x/y, sourceUrl
   - Add assertions for: url, mimeType, isCollective, syncStatus

4. Verify typecheck passes:
   ```bash
   npm run typecheck
   ```

5. Document any skipped/todo tests that need deeper fixes.
  </action>
  <verify>npm run test:run passes (or documents known issues), npm run typecheck passes</verify>
  <done>Full test suite passes with all Card/Connection updates</done>
</task>

<task type="auto">
  <name>Task 3: Document cleanup procedure and verify functionality</name>
  <files>.planning/phases/84-cards-and-connections/CLEANUP-PROCEDURE.md</files>
  <action>
Create cleanup documentation at .planning/phases/84-cards-and-connections/CLEANUP-PROCEDURE.md:

```markdown
# Phase 84 Cleanup Procedure

## Current State

After Phase 84 completion:
- `cards` and `connections` tables are active
- `nodes_backup` and `edges_backup` tables exist for rollback
- Old `nodes` and `edges` tables may still exist (can be dropped)
- `node_properties` renamed to `card_properties`

## Rollback Procedure (if needed)

If issues are discovered after migration:

1. Restore from backup:
   ```sql
   -- Drop new tables
   DROP TABLE IF EXISTS connections;
   DROP TABLE IF EXISTS cards_fts;
   DROP TABLE IF EXISTS cards;

   -- Restore from backup
   ALTER TABLE nodes_backup RENAME TO nodes;
   ALTER TABLE edges_backup RENAME TO edges;

   -- Restore node_properties
   ALTER TABLE card_properties RENAME TO node_properties;

   -- Rebuild FTS
   INSERT INTO nodes_fts(nodes_fts) VALUES('rebuild');
   ```

2. Revert code changes (git revert or checkout)

## Cleanup Procedure (after verification period)

After 2 weeks of stable operation:

1. Drop backup tables:
   ```sql
   DROP TABLE IF EXISTS nodes_backup;
   DROP TABLE IF EXISTS edges_backup;
   ```

2. Drop old tables (if not already dropped):
   ```sql
   DROP TABLE IF EXISTS edges;
   DROP TABLE IF EXISTS nodes_fts;
   DROP TABLE IF EXISTS nodes;
   ```

3. Remove deprecated code:
   - Delete `src/types/node.ts` deprecation layer
   - Remove `rowToNode()` from any remaining usages
   - Remove `Node` and `Edge` type imports

## Verification Checklist

Before dropping backups, verify:
- [ ] SuperGrid renders correctly
- [ ] FTS5 search returns correct results
- [ ] ETL imports work (test with a sample file)
- [ ] All 4 card types can be created/edited
- [ ] Connections with via_card_id work
- [ ] Graph traversal queries return correct results
- [ ] No console errors during normal operation
- [ ] Performance is acceptable (compare to before migration)

## Timeline

- **Week 1-2**: Monitor for issues, keep backups
- **Week 3**: Run verification checklist
- **Week 4**: Execute cleanup if all verified
```

Additionally, run manual verification:
1. Start dev server: `npm run dev`
2. Verify SuperGrid loads and displays cards
3. Test FTS5 search in UI
4. Create a new card of each type (if UI supports)
  </action>
  <verify>CLEANUP-PROCEDURE.md exists, npm run dev starts without errors</verify>
  <done>Cleanup procedure documented, functionality manually verified</done>
</task>

</tasks>

<verification>
1. `npm run test:run` - all tests pass
2. `npm run typecheck` - zero TypeScript errors
3. `npm run dev` - application starts without errors
4. Manual: SuperGrid displays cards correctly
5. Manual: FTS5 search returns results
6. `ls .planning/phases/84-cards-and-connections/CLEANUP-PROCEDURE.md` - cleanup docs exist
</verification>

<success_criteria>
- Full test suite passes (npm run test:run)
- TypeScript compiles clean (npm run typecheck)
- SuperGrid renders correctly with card data
- FTS5 search returns correct cards
- ETL importers produce valid cards (tests pass)
- Integration tests cover CRUD, FTS5, connections, graph traversal
- Cleanup procedure documented with rollback steps
- No runtime errors in development mode
</success_criteria>

<output>
After completion, create `.planning/phases/84-cards-and-connections/84-04-SUMMARY.md`
</output>
