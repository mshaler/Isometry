---
phase: 84-cards-and-connections
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/card.ts
  - src/types/node.ts
  - src/types/lpg.ts
  - src/types/index.ts
autonomous: true

must_haves:
  truths:
    - "Card interface exists with discriminated union for card_type"
    - "Connection interface exists with via_card_id field"
    - "Type guards isNote(), isPerson(), isEvent(), isResource() work correctly"
    - "rowToCard() converter function handles all card types"
    - "Legacy Node type marked as deprecated with migration path"
  artifacts:
    - path: "src/types/card.ts"
      provides: "Card and Connection TypeScript types"
      exports: ["Card", "Connection", "CardType", "isNote", "isPerson", "isEvent", "isResource"]
    - path: "src/types/node.ts"
      provides: "Deprecated Node type with re-export"
      contains: "@deprecated"
  key_links:
    - from: "src/types/card.ts"
      to: "src/types/index.ts"
      via: "export"
      pattern: "export.*from.*card"
---

<objective>
Create TypeScript types for the new cards/connections data model with type guards and converters.

Purpose: Provide type safety for the new data model, enabling TypeScript to catch Node->Card migration issues at compile time.

Output: New card.ts with Card/Connection interfaces, type guards, row converters. Updated node.ts with deprecation notices.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@CARDS-AND-CONNECTIONS.md
@.planning/phases/84-cards-and-connections/84-RESEARCH.md
@src/types/node.ts
@src/types/lpg.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Card and Connection interfaces in card.ts</name>
  <files>src/types/card.ts</files>
  <action>
Create new file at src/types/card.ts with:

```typescript
/**
 * Card and Connection types for Isometry v4 data model
 *
 * Cards: The four entity types (note, person, event, resource)
 * Connections: Lightweight relationships with optional via_card bridging
 *
 * Key principles:
 * - A Card is a Card (no node/edge distinction at data level)
 * - Schema stores facts, views create meaning
 * - Connections are rich through what they bridge (via_card_id)
 */

// ============================================
// Card Types
// ============================================

/** The four card types - constrained, no expansion */
export type CardType = 'note' | 'person' | 'event' | 'resource';

/** Task status values (unchanged from prior model) */
export type TaskStatus = 'active' | 'pending' | 'completed' | 'archived' | 'blocked' | 'in_progress';

/** Sync status for offline-first support */
export type SyncStatus = 'pending' | 'synced' | 'conflict' | 'error';

// ============================================
// Base Card Interface
// ============================================

/** Base properties shared by all card types */
interface BaseCard {
  id: string;
  name: string;
  content: string | null;
  summary: string | null;

  // LATCH: Location
  latitude: number | null;
  longitude: number | null;
  locationName: string | null;

  // LATCH: Time
  createdAt: string;
  modifiedAt: string;
  dueAt: string | null;
  completedAt: string | null;
  eventStart: string | null;
  eventEnd: string | null;

  // LATCH: Category
  folder: string | null;
  tags: string[];
  status: TaskStatus | null;

  // LATCH: Hierarchy
  priority: number;
  sortOrder: number;

  // Source tracking
  source: string | null;
  sourceId: string | null;

  // Lifecycle
  deletedAt: string | null;
  version: number;
  syncStatus: SyncStatus;
}

// ============================================
// Discriminated Union Card Types
// ============================================

/** Note card - content carrier, freeform, default type */
export interface NoteCard extends BaseCard {
  cardType: 'note';
  // Notes use base fields only
  url: null;
  mimeType: null;
  isCollective: false;
}

/** Person card - anchor point, thin, positional */
export interface PersonCard extends BaseCard {
  cardType: 'person';
  /** Is this a group/organization (true) or individual (false) */
  isCollective: boolean;
  url: null;
  mimeType: null;
}

/** Event card - anchor point, time-positioned */
export interface EventCard extends BaseCard {
  cardType: 'event';
  /** Event start is required for events (though may be null in DB for tasks) */
  eventStart: string | null;
  eventEnd: string | null;
  url: null;
  mimeType: null;
  isCollective: false;
}

/** Resource card - content carrier, external reference */
export interface ResourceCard extends BaseCard {
  cardType: 'resource';
  /** URL to external resource */
  url: string | null;
  /** MIME type of resource */
  mimeType: string | null;
  isCollective: false;
}

/** Union type: all possible card types */
export type Card = NoteCard | PersonCard | EventCard | ResourceCard;

// ============================================
// Connection Interface
// ============================================

/**
 * Connection between two cards.
 *
 * Unlike the old edges table:
 * - No directed column (direction is view concern)
 * - No edge_type enum (label is user-provided string)
 * - via_card_id enables rich connections through bridge cards
 */
export interface Connection {
  id: string;
  sourceId: string;
  targetId: string;
  /** Optional bridge card that characterizes this connection */
  viaCardId: string | null;
  /** User-provided label (schema-on-read, not an enum) */
  label: string | null;
  /** Weight for graph algorithms (0-1) */
  weight: number;
  createdAt: string;
}

// ============================================
// Type Guards
// ============================================

/** Type guard for NoteCard */
export function isNote(card: Card): card is NoteCard {
  return card.cardType === 'note';
}

/** Type guard for PersonCard */
export function isPerson(card: Card): card is PersonCard {
  return card.cardType === 'person';
}

/** Type guard for EventCard */
export function isEvent(card: Card): card is EventCard {
  return card.cardType === 'event';
}

/** Type guard for ResourceCard */
export function isResource(card: Card): card is ResourceCard {
  return card.cardType === 'resource';
}

/** Check if a card type string is valid */
export function isValidCardType(type: string): type is CardType {
  return ['note', 'person', 'event', 'resource'].includes(type);
}

// ============================================
// Row Converters
// ============================================

/**
 * Convert database row to typed Card object.
 * Handles the discriminated union based on card_type column.
 */
export function rowToCard(row: Record<string, unknown>): Card {
  const cardType = row.card_type as CardType;
  const tags = row.tags ? (typeof row.tags === 'string' ? JSON.parse(row.tags) : row.tags) : [];

  const base: Omit<BaseCard, 'syncStatus'> & { syncStatus: SyncStatus } = {
    id: row.id as string,
    name: row.name as string,
    content: row.content as string | null,
    summary: row.summary as string | null,
    latitude: row.latitude as number | null,
    longitude: row.longitude as number | null,
    locationName: row.location_name as string | null,
    createdAt: row.created_at as string,
    modifiedAt: row.modified_at as string,
    dueAt: row.due_at as string | null,
    completedAt: row.completed_at as string | null,
    eventStart: row.event_start as string | null,
    eventEnd: row.event_end as string | null,
    folder: row.folder as string | null,
    tags,
    status: row.status as TaskStatus | null,
    priority: (row.priority as number) ?? 0,
    sortOrder: (row.sort_order as number) ?? 0,
    source: row.source as string | null,
    sourceId: row.source_id as string | null,
    deletedAt: row.deleted_at as string | null,
    version: (row.version as number) ?? 1,
    syncStatus: (row.sync_status as SyncStatus) ?? 'pending',
  };

  switch (cardType) {
    case 'person':
      return {
        ...base,
        cardType: 'person',
        isCollective: Boolean(row.is_collective),
        url: null,
        mimeType: null,
      };
    case 'event':
      return {
        ...base,
        cardType: 'event',
        url: null,
        mimeType: null,
        isCollective: false,
      };
    case 'resource':
      return {
        ...base,
        cardType: 'resource',
        url: row.url as string | null,
        mimeType: row.mime_type as string | null,
        isCollective: false,
      };
    case 'note':
    default:
      return {
        ...base,
        cardType: 'note',
        url: null,
        mimeType: null,
        isCollective: false,
      };
  }
}

/**
 * Convert database row to Connection object.
 */
export function rowToConnection(row: Record<string, unknown>): Connection {
  return {
    id: row.id as string,
    sourceId: row.source_id as string,
    targetId: row.target_id as string,
    viaCardId: row.via_card_id as string | null,
    label: row.label as string | null,
    weight: (row.weight as number) ?? 1.0,
    createdAt: row.created_at as string,
  };
}

// ============================================
// Card to Row Converter (for inserts/updates)
// ============================================

/**
 * Convert Card object to database row format.
 */
export function cardToRow(card: Card): Record<string, unknown> {
  return {
    id: card.id,
    card_type: card.cardType,
    name: card.name,
    content: card.content,
    summary: card.summary,
    latitude: card.latitude,
    longitude: card.longitude,
    location_name: card.locationName,
    created_at: card.createdAt,
    modified_at: card.modifiedAt,
    due_at: card.dueAt,
    completed_at: card.completedAt,
    event_start: card.eventStart,
    event_end: card.eventEnd,
    folder: card.folder,
    tags: JSON.stringify(card.tags),
    status: card.status,
    priority: card.priority,
    sort_order: card.sortOrder,
    url: isResource(card) ? card.url : null,
    mime_type: isResource(card) ? card.mimeType : null,
    is_collective: isPerson(card) ? (card.isCollective ? 1 : 0) : 0,
    source: card.source,
    source_id: card.sourceId,
    deleted_at: card.deletedAt,
    version: card.version,
    sync_status: card.syncStatus,
  };
}
```
  </action>
  <verify>npm run typecheck shows no errors in src/types/card.ts</verify>
  <done>Card/Connection interfaces with type guards and row converters complete</done>
</task>

<task type="auto">
  <name>Task 2: Update node.ts with deprecation notices and re-exports</name>
  <files>src/types/node.ts</files>
  <action>
Update src/types/node.ts to:

1. Add deprecation notices to existing types
2. Add re-exports from card.ts for migration path
3. Add adapter function for Node -> Card conversion

```typescript
// Node (Card) types
//
// @deprecated This file is being replaced by card.ts in Phase 84.
// Use Card, Connection, and related types from './card' instead.
// Migration: node_type -> card_type, edges -> connections

// Re-export new types for gradual migration
export {
  Card,
  CardType,
  Connection,
  isNote,
  isPerson,
  isEvent,
  isResource,
  rowToCard,
  rowToConnection,
} from './card';

/**
 * @deprecated Use CardType from './card' instead.
 * Maps: task/project/notebook -> 'note', contact -> 'person'
 */
export type NodeType = 'note' | 'task' | 'contact' | 'event' | 'project' | 'resource' | 'notebook';

export type TaskStatus = 'active' | 'pending' | 'completed' | 'archived';

/**
 * @deprecated Use Connection from './card' instead.
 * The new model uses label (string) instead of edge_type (enum).
 */
export type EdgeType = 'LINK' | 'NEST' | 'SEQUENCE' | 'AFFINITY';

/**
 * @deprecated Use Card from './card' instead.
 * This interface will be removed in a future version.
 */
export interface Node {
  id: string;
  nodeType: NodeType;
  name: string;
  content: string | null;
  summary: string | null;

  // LATCH: Location
  latitude: number | null;
  longitude: number | null;
  locationName: string | null;
  /** @deprecated Removed in cards model */
  locationAddress: string | null;

  // LATCH: Time
  createdAt: string;
  modifiedAt: string;
  dueAt: string | null;
  completedAt: string | null;
  eventStart: string | null;
  eventEnd: string | null;

  // LATCH: Category
  folder: string | null;
  tags: string[];
  status: TaskStatus | null;

  // LATCH: Hierarchy
  priority: number;
  /** @deprecated Removed in cards model (redundant with priority) */
  importance: number;
  sortOrder: number;

  // Metadata
  source: string | null;
  sourceId: string | null;
  /** @deprecated Use url field on ResourceCard instead */
  sourceUrl: string | null;
  deletedAt: string | null;
  version: number;
}

/**
 * @deprecated Use Connection from './card' instead.
 */
export interface Edge {
  id: string;
  edgeType: EdgeType;
  sourceId: string;
  targetId: string;
  label: string | null;
  weight: number;
  /** @deprecated Removed in connections model (direction is view concern) */
  directed: boolean;
  /** @deprecated Removed - use sort_order on cards */
  sequenceOrder: number | null;
  /** @deprecated Removed - use via_card */
  channel: string | null;
  /** @deprecated Removed - use via_card's created_at */
  timestamp: string | null;
  /** @deprecated Removed - use via_card's name */
  subject: string | null;
  createdAt: string;
}

/**
 * @deprecated Use rowToCard from './card' instead.
 */
export function rowToNode(row: Record<string, unknown>): Node {
  return {
    id: row.id as string,
    nodeType: row.node_type as NodeType,
    name: row.name as string,
    content: row.content as string | null,
    summary: row.summary as string | null,
    latitude: row.latitude as number | null,
    longitude: row.longitude as number | null,
    locationName: row.location_name as string | null,
    locationAddress: row.location_address as string | null,
    createdAt: row.created_at as string,
    modifiedAt: row.modified_at as string,
    dueAt: row.due_at as string | null,
    completedAt: row.completed_at as string | null,
    eventStart: row.event_start as string | null,
    eventEnd: row.event_end as string | null,
    folder: row.folder as string | null,
    tags: row.tags ? JSON.parse(row.tags as string) : [],
    status: row.status as TaskStatus | null,
    priority: (row.priority as number) ?? 0,
    importance: (row.importance as number) ?? 0,
    sortOrder: (row.sort_order as number) ?? 0,
    source: row.source as string | null,
    sourceId: row.source_id as string | null,
    sourceUrl: row.source_url as string | null,
    deletedAt: row.deleted_at as string | null,
    version: (row.version as number) ?? 1,
  };
}

// ============================================
// Migration Helpers
// ============================================

import type { Card, CardType } from './card';

/**
 * Convert legacy Node to new Card format.
 * Use this during migration period.
 */
export function nodeToCard(node: Node): Card {
  // Map old node_type to new card_type
  const typeMap: Record<NodeType, CardType> = {
    note: 'note',
    task: 'note',
    project: 'note',
    notebook: 'note',
    contact: 'person',
    event: 'event',
    resource: 'resource',
  };

  const cardType = typeMap[node.nodeType] || 'note';

  const base = {
    id: node.id,
    name: node.name,
    content: node.content,
    summary: node.summary,
    latitude: node.latitude,
    longitude: node.longitude,
    locationName: node.locationName,
    createdAt: node.createdAt,
    modifiedAt: node.modifiedAt,
    dueAt: node.dueAt,
    completedAt: node.completedAt,
    eventStart: node.eventStart,
    eventEnd: node.eventEnd,
    folder: node.folder,
    tags: node.tags,
    status: node.status,
    priority: node.priority,
    sortOrder: node.sortOrder,
    source: node.source,
    sourceId: node.sourceId,
    deletedAt: node.deletedAt,
    version: node.version,
    syncStatus: 'pending' as const,
  };

  switch (cardType) {
    case 'person':
      return { ...base, cardType: 'person', isCollective: false, url: null, mimeType: null };
    case 'event':
      return { ...base, cardType: 'event', isCollective: false, url: null, mimeType: null };
    case 'resource':
      return { ...base, cardType: 'resource', url: node.sourceUrl, mimeType: null, isCollective: false };
    default:
      return { ...base, cardType: 'note', isCollective: false, url: null, mimeType: null };
  }
}
```
  </action>
  <verify>npm run typecheck shows no errors, grep "@deprecated" src/types/node.ts shows deprecation notices</verify>
  <done>node.ts updated with deprecation notices and migration helpers</done>
</task>

<task type="auto">
  <name>Task 3: Update types index and write type guard tests</name>
  <files>src/types/index.ts, src/types/__tests__/card.test.ts</files>
  <action>
1. Update src/types/index.ts to export new card types:

Add to exports:
```typescript
// Card types (Phase 84 - new data model)
export type {
  Card,
  CardType,
  NoteCard,
  PersonCard,
  EventCard,
  ResourceCard,
  Connection,
  SyncStatus,
} from './card';

export {
  isNote,
  isPerson,
  isEvent,
  isResource,
  isValidCardType,
  rowToCard,
  rowToConnection,
  cardToRow,
} from './card';
```

2. Create src/types/__tests__/card.test.ts:

```typescript
import { describe, it, expect } from 'vitest';
import {
  isNote,
  isPerson,
  isEvent,
  isResource,
  isValidCardType,
  rowToCard,
  rowToConnection,
  cardToRow,
  type Card,
  type NoteCard,
  type PersonCard,
} from '../card';

describe('Card type guards', () => {
  const noteCard: Card = {
    id: 'n1',
    cardType: 'note',
    name: 'Test Note',
    content: 'Content',
    summary: null,
    latitude: null,
    longitude: null,
    locationName: null,
    createdAt: '2024-01-01',
    modifiedAt: '2024-01-02',
    dueAt: null,
    completedAt: null,
    eventStart: null,
    eventEnd: null,
    folder: 'work',
    tags: ['tag1'],
    status: 'active',
    priority: 5,
    sortOrder: 0,
    source: null,
    sourceId: null,
    deletedAt: null,
    version: 1,
    syncStatus: 'pending',
    url: null,
    mimeType: null,
    isCollective: false,
  };

  const personCard: Card = {
    ...noteCard,
    id: 'p1',
    cardType: 'person',
    name: 'John Doe',
    isCollective: true,
  };

  const eventCard: Card = {
    ...noteCard,
    id: 'e1',
    cardType: 'event',
    name: 'Meeting',
    eventStart: '2024-02-01T10:00:00Z',
    eventEnd: '2024-02-01T11:00:00Z',
    isCollective: false,
  };

  const resourceCard: Card = {
    ...noteCard,
    id: 'r1',
    cardType: 'resource',
    name: 'Document',
    url: 'https://example.com/doc.pdf',
    mimeType: 'application/pdf',
    isCollective: false,
  };

  it('isNote returns true only for note cards', () => {
    expect(isNote(noteCard)).toBe(true);
    expect(isNote(personCard)).toBe(false);
    expect(isNote(eventCard)).toBe(false);
    expect(isNote(resourceCard)).toBe(false);
  });

  it('isPerson returns true only for person cards', () => {
    expect(isPerson(noteCard)).toBe(false);
    expect(isPerson(personCard)).toBe(true);
    expect(isPerson(eventCard)).toBe(false);
    expect(isPerson(resourceCard)).toBe(false);
  });

  it('isEvent returns true only for event cards', () => {
    expect(isEvent(noteCard)).toBe(false);
    expect(isEvent(personCard)).toBe(false);
    expect(isEvent(eventCard)).toBe(true);
    expect(isEvent(resourceCard)).toBe(false);
  });

  it('isResource returns true only for resource cards', () => {
    expect(isResource(noteCard)).toBe(false);
    expect(isResource(personCard)).toBe(false);
    expect(isResource(eventCard)).toBe(false);
    expect(isResource(resourceCard)).toBe(true);
  });

  it('isValidCardType validates card type strings', () => {
    expect(isValidCardType('note')).toBe(true);
    expect(isValidCardType('person')).toBe(true);
    expect(isValidCardType('event')).toBe(true);
    expect(isValidCardType('resource')).toBe(true);
    expect(isValidCardType('task')).toBe(false);
    expect(isValidCardType('project')).toBe(false);
    expect(isValidCardType('invalid')).toBe(false);
  });
});

describe('rowToCard converter', () => {
  it('converts note row correctly', () => {
    const row = {
      id: 'n1',
      card_type: 'note',
      name: 'Test',
      content: 'Content',
      summary: null,
      latitude: null,
      longitude: null,
      location_name: null,
      created_at: '2024-01-01',
      modified_at: '2024-01-02',
      due_at: null,
      completed_at: null,
      event_start: null,
      event_end: null,
      folder: 'work',
      tags: '["tag1", "tag2"]',
      status: 'active',
      priority: 3,
      sort_order: 1,
      source: null,
      source_id: null,
      deleted_at: null,
      version: 1,
      sync_status: 'synced',
      url: null,
      mime_type: null,
      is_collective: 0,
    };

    const card = rowToCard(row);

    expect(card.id).toBe('n1');
    expect(card.cardType).toBe('note');
    expect(card.tags).toEqual(['tag1', 'tag2']);
    expect(isNote(card)).toBe(true);
  });

  it('converts person row with isCollective', () => {
    const row = {
      id: 'p1',
      card_type: 'person',
      name: 'Acme Corp',
      is_collective: 1,
      // ... other fields
      content: null,
      summary: null,
      latitude: null,
      longitude: null,
      location_name: null,
      created_at: '2024-01-01',
      modified_at: '2024-01-02',
      due_at: null,
      completed_at: null,
      event_start: null,
      event_end: null,
      folder: null,
      tags: null,
      status: null,
      priority: 0,
      sort_order: 0,
      source: null,
      source_id: null,
      deleted_at: null,
      version: 1,
      sync_status: 'pending',
    };

    const card = rowToCard(row);

    expect(card.cardType).toBe('person');
    expect(isPerson(card)).toBe(true);
    if (isPerson(card)) {
      expect(card.isCollective).toBe(true);
    }
  });

  it('converts resource row with url and mimeType', () => {
    const row = {
      id: 'r1',
      card_type: 'resource',
      name: 'Document',
      url: 'https://example.com/file.pdf',
      mime_type: 'application/pdf',
      // ... other fields
      content: null,
      summary: null,
      latitude: null,
      longitude: null,
      location_name: null,
      created_at: '2024-01-01',
      modified_at: '2024-01-02',
      due_at: null,
      completed_at: null,
      event_start: null,
      event_end: null,
      folder: null,
      tags: null,
      status: null,
      priority: 0,
      sort_order: 0,
      source: null,
      source_id: null,
      deleted_at: null,
      version: 1,
      sync_status: 'pending',
      is_collective: 0,
    };

    const card = rowToCard(row);

    expect(card.cardType).toBe('resource');
    expect(isResource(card)).toBe(true);
    if (isResource(card)) {
      expect(card.url).toBe('https://example.com/file.pdf');
      expect(card.mimeType).toBe('application/pdf');
    }
  });
});

describe('rowToConnection converter', () => {
  it('converts connection row correctly', () => {
    const row = {
      id: 'c1',
      source_id: 'n1',
      target_id: 'n2',
      via_card_id: 'n3',
      label: 'references',
      weight: 0.8,
      created_at: '2024-01-01',
    };

    const conn = rowToConnection(row);

    expect(conn.id).toBe('c1');
    expect(conn.sourceId).toBe('n1');
    expect(conn.targetId).toBe('n2');
    expect(conn.viaCardId).toBe('n3');
    expect(conn.label).toBe('references');
    expect(conn.weight).toBe(0.8);
  });

  it('handles null via_card_id', () => {
    const row = {
      id: 'c2',
      source_id: 'n1',
      target_id: 'n2',
      via_card_id: null,
      label: 'link',
      weight: 1.0,
      created_at: '2024-01-01',
    };

    const conn = rowToConnection(row);

    expect(conn.viaCardId).toBeNull();
  });
});

describe('cardToRow converter', () => {
  it('converts note card to row format', () => {
    const card: NoteCard = {
      id: 'n1',
      cardType: 'note',
      name: 'Test',
      content: 'Content',
      summary: null,
      latitude: null,
      longitude: null,
      locationName: null,
      createdAt: '2024-01-01',
      modifiedAt: '2024-01-02',
      dueAt: null,
      completedAt: null,
      eventStart: null,
      eventEnd: null,
      folder: 'work',
      tags: ['tag1', 'tag2'],
      status: 'active',
      priority: 3,
      sortOrder: 1,
      source: null,
      sourceId: null,
      deletedAt: null,
      version: 1,
      syncStatus: 'pending',
      url: null,
      mimeType: null,
      isCollective: false,
    };

    const row = cardToRow(card);

    expect(row.id).toBe('n1');
    expect(row.card_type).toBe('note');
    expect(row.tags).toBe('["tag1","tag2"]');
    expect(row.is_collective).toBe(0);
  });

  it('converts person card with isCollective', () => {
    const card: PersonCard = {
      id: 'p1',
      cardType: 'person',
      name: 'Acme Corp',
      isCollective: true,
      content: null,
      summary: null,
      latitude: null,
      longitude: null,
      locationName: null,
      createdAt: '2024-01-01',
      modifiedAt: '2024-01-02',
      dueAt: null,
      completedAt: null,
      eventStart: null,
      eventEnd: null,
      folder: null,
      tags: [],
      status: null,
      priority: 0,
      sortOrder: 0,
      source: null,
      sourceId: null,
      deletedAt: null,
      version: 1,
      syncStatus: 'pending',
      url: null,
      mimeType: null,
    };

    const row = cardToRow(card);

    expect(row.card_type).toBe('person');
    expect(row.is_collective).toBe(1);
  });
});
```
  </action>
  <verify>npm run test -- src/types/__tests__/card.test.ts passes</verify>
  <done>Type guards tested and types exported from index</done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes with zero errors
2. `npm run test -- src/types/__tests__/card.test.ts` all tests pass
3. `grep "isNote\|isPerson\|isEvent\|isResource" src/types/card.ts` shows type guards
4. `grep "@deprecated" src/types/node.ts` shows deprecation notices
5. `grep "Card.*from.*card" src/types/index.ts` shows Card export
</verification>

<success_criteria>
- Card interface with discriminated union (cardType field) for 4 types
- Connection interface with viaCardId field
- Type guards isNote(), isPerson(), isEvent(), isResource() work correctly
- rowToCard() handles all card types with correct field mapping
- cardToRow() produces correct database row format
- Legacy Node/Edge types marked @deprecated with migration path documented
- Types exported from index.ts
- All type guard tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/84-cards-and-connections/84-02-SUMMARY.md`
</output>
