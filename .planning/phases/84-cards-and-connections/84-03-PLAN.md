---
phase: 84-cards-and-connections
plan: 03
type: execute
wave: 2
depends_on: ["84-01", "84-02"]
files_modified:
  - src/hooks/database/useLiveQuery.ts
  - src/hooks/database/useFTS5Search.ts
  - src/etl/database/insertion.ts
  - src/etl/types/canonical.ts
  - src/services/query/nodeQueries.ts
autonomous: true

must_haves:
  truths:
    - "useLiveQuery returns Card[] not Node[]"
    - "FTS5 search queries cards_fts not nodes_fts"
    - "insertCanonicalNodes inserts into cards table"
    - "CanonicalNode maps to Card fields correctly"
    - "All SQL queries use cards/connections not nodes/edges"
  artifacts:
    - path: "src/hooks/database/useLiveQuery.ts"
      provides: "Live query hook for cards"
      contains: "FROM cards"
    - path: "src/etl/database/insertion.ts"
      provides: "ETL insertion into cards table"
      contains: "INSERT INTO cards"
  key_links:
    - from: "src/hooks/database/useLiveQuery.ts"
      to: "src/types/card.ts"
      via: "import Card"
      pattern: "import.*Card.*from"
    - from: "src/etl/database/insertion.ts"
      to: "src/db/schema.sql"
      via: "INSERT INTO cards"
      pattern: "cards\\s*\\("
---

<objective>
Update all database queries, hooks, and ETL services to use cards/connections instead of nodes/edges.

Purpose: Complete the data layer migration so all code paths use the new schema. This is the largest plan as it touches all data access points.

Output: Updated hooks, services, and ETL code using Card/Connection types and querying cards/connections tables.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/84-cards-and-connections/84-01-SUMMARY.md
@.planning/phases/84-cards-and-connections/84-02-SUMMARY.md
@src/types/card.ts
@src/hooks/database/useLiveQuery.ts
@src/etl/database/insertion.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update database hooks to use cards table</name>
  <files>src/hooks/database/useLiveQuery.ts, src/hooks/database/useFTS5Search.ts, src/hooks/database/useLiveQueryCore.ts</files>
  <action>
Update the database hooks to query cards instead of nodes:

1. **useLiveQuery.ts** - Update main query hook:
   - Import Card, rowToCard from '@/types/card'
   - Change return type from Node[] to Card[]
   - Update SQL: `FROM nodes` -> `FROM cards`
   - Update row converter: `rowToNode(row)` -> `rowToCard(row)`
   - Update filter references: `nodes.folder` -> `cards.folder`, etc.

2. **useFTS5Search.ts** - Update FTS5 search:
   - Import Card, rowToCard from '@/types/card'
   - Change return type from Node[] to Card[]
   - Update SQL: `nodes_fts` -> `cards_fts`, `JOIN nodes` -> `JOIN cards`
   - Update row converter

3. **useLiveQueryCore.ts** - If it exists and references nodes:
   - Same pattern: nodes -> cards, Node -> Card

Example changes for useLiveQuery.ts:

```typescript
// Before
import { Node, rowToNode } from '@/types/node';

export function useLiveQuery(filters: LATCHFilters): { data: Node[]; ... }

const sql = `SELECT * FROM nodes WHERE deleted_at IS NULL`;

return rows.map(rowToNode);

// After
import { Card, rowToCard } from '@/types/card';

export function useLiveQuery(filters: LATCHFilters): { data: Card[]; ... }

const sql = `SELECT * FROM cards WHERE deleted_at IS NULL`;

return rows.map(rowToCard);
```

Example changes for useFTS5Search.ts:

```typescript
// Before
const sql = `
  SELECT n.* FROM nodes_fts
  JOIN nodes n ON nodes_fts.rowid = n.rowid
  WHERE nodes_fts MATCH ?
`;

// After
const sql = `
  SELECT c.* FROM cards_fts
  JOIN cards c ON cards_fts.rowid = c.rowid
  WHERE cards_fts MATCH ?
`;
```
  </action>
  <verify>npm run typecheck passes, grep "FROM cards" src/hooks/database/*.ts shows updated queries</verify>
  <done>Database hooks query cards table and return Card types</done>
</task>

<task type="auto">
  <name>Task 2: Update ETL insertion to use cards table</name>
  <files>src/etl/database/insertion.ts, src/etl/types/canonical.ts</files>
  <action>
Update ETL code to insert into cards instead of nodes:

1. **src/etl/database/insertion.ts** - Update insertCanonicalNodes:
   - Rename function to `insertCanonicalCards` (keep old name as deprecated alias)
   - Update INSERT statement: `INSERT INTO nodes` -> `INSERT INTO cards`
   - Update column list to match cards schema:
     - Remove: location_address, importance, grid_x, grid_y, source_url
     - Add: url, mime_type, is_collective, sync_status
   - Map node_type to card_type with type coercion:
     - contact -> person
     - task/project/notebook -> note
   - Update card_properties references (from node_properties)

```typescript
// Key changes to INSERT statement
const insertSQL = `
  INSERT INTO cards (
    id, card_type, name, content, summary,
    latitude, longitude, location_name,
    created_at, modified_at, due_at, completed_at, event_start, event_end,
    folder, tags, status,
    priority, sort_order,
    url, mime_type, is_collective,
    source, source_id, deleted_at, version, sync_status
  ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`;

// Map canonical node_type to card_type
function mapNodeTypeToCardType(nodeType: string): string {
  switch (nodeType) {
    case 'contact': return 'person';
    case 'task':
    case 'project':
    case 'notebook':
      return 'note';
    case 'event': return 'event';
    case 'resource': return 'resource';
    default: return 'note';
  }
}
```

2. **src/etl/types/canonical.ts** - Update CanonicalNode schema:
   - Add comments noting card_type mapping
   - Ensure all fields map correctly to cards table
   - Keep nodeType as-is for backwards compatibility (mapping done at insert time)

3. Update property storage (if using node_properties -> card_properties):
   - Update src/etl/storage/property-storage.ts if it references node_properties
  </action>
  <verify>npm run test -- src/etl/database/__tests__/insertion.test.ts passes</verify>
  <done>ETL inserts into cards table with correct type mapping</done>
</task>

<task type="auto">
  <name>Task 3: Update query services and fix remaining Node references</name>
  <files>src/services/query/nodeQueries.ts, src/d3/SuperGridEngine/index.ts</files>
  <action>
Update remaining services that reference nodes/edges:

1. **src/services/query/nodeQueries.ts** (if exists):
   - Rename to cardQueries.ts or update in place
   - Update all SQL to use cards/connections
   - Update return types to Card/Connection
   - Export as both old and new names for compatibility

2. **src/d3/SuperGridEngine/index.ts** and related D3 files:
   - Update data types from Node to Card
   - Update any direct SQL queries to use cards table
   - The D3 data binding should work the same since Card has same structure

3. Search for remaining "nodes" references in hooks/services:
   ```bash
   grep -r "FROM nodes" src/hooks src/services src/d3 --include="*.ts"
   grep -r "rowToNode" src/hooks src/services src/d3 --include="*.ts"
   ```
   Update any found occurrences.

4. Update edge-related queries to use connections:
   - Change `FROM edges` to `FROM connections`
   - Update edge_type references to use label
   - Remove directed, sequence_order, channel, timestamp, subject references

Example connection query update:
```typescript
// Before
const sql = `
  SELECT e.* FROM edges e
  WHERE e.source_id = ? OR e.target_id = ?
`;

// After
const sql = `
  SELECT c.* FROM connections c
  WHERE c.source_id = ? OR c.target_id = ?
`;
```
  </action>
  <verify>grep -r "FROM nodes" src/ --include="*.ts" returns only backup/test files or deprecated code</verify>
  <done>All query services use cards/connections tables</done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes with zero errors
2. `npm run test` - all existing tests pass (may need updates for new types)
3. `grep -r "FROM cards" src/hooks src/etl src/services --include="*.ts"` shows cards queries
4. `grep -r "FROM connections" src/hooks src/services --include="*.ts"` shows connections queries
5. `grep -r "rowToCard" src/hooks src/services --include="*.ts"` shows Card type usage
</verification>

<success_criteria>
- useLiveQuery returns Card[] and queries cards table
- useFTS5Search queries cards_fts and returns Card[]
- insertCanonicalCards (or updated insertCanonicalNodes) inserts into cards table
- CanonicalNode nodeType correctly maps to card_type (contact->person, task->note, etc.)
- All SQL queries in hooks/services use cards and connections tables
- TypeScript compiles without errors
- Existing ETL tests pass with updated assertions
</success_criteria>

<output>
After completion, create `.planning/phases/84-cards-and-connections/84-03-SUMMARY.md`
</output>
