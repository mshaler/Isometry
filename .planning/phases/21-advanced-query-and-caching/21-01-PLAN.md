---
phase: 21-advanced-query-and-caching
plan: 01
type: execute
wave: 1
depends_on: ["20-02"]
files_modified: [
  "src/hooks/useVirtualizedList.ts",
  "src/components/VirtualizedGrid/index.tsx",
  "src/components/VirtualizedList/index.tsx",
  "src/services/queryClient.ts",
  "src/hooks/useLiveQuery.ts",
  "src/utils/cacheInvalidation.ts",
  "package.json"
]
autonomous: true

must_haves:
  truths:
    - "Large lists scroll smoothly with virtual rendering regardless of dataset size"
    - "Frequently accessed data loads instantly from intelligent cache"
    - "Query results update automatically when underlying data changes"
    - "Cache invalidation happens automatically after mutations"
    - "Virtual scrolling maintains 60fps performance with 10k+ items"
  artifacts:
    - path: "src/hooks/useVirtualizedList.ts"
      provides: "Virtual scrolling hook with TanStack Virtual"
      exports: ["useVirtualizedList"]
    - path: "src/components/VirtualizedGrid/index.tsx"
      provides: "Virtual grid component for large datasets"
      min_lines: 40
    - path: "src/services/queryClient.ts"
      provides: "TanStack Query client configuration"
      contains: "QueryClient"
    - path: "src/hooks/useLiveQuery.ts"
      provides: "Enhanced live query with intelligent caching"
      exports: ["useLiveQuery"]
  key_links:
    - from: "src/components/VirtualizedGrid/index.tsx"
      to: "src/hooks/useVirtualizedList.ts"
      via: "hook usage"
      pattern: "useVirtualizedList"
    - from: "src/hooks/useLiveQuery.ts"
      to: "src/services/queryClient.ts"
      via: "TanStack Query integration"
      pattern: "useQuery"
    - from: "src/utils/cacheInvalidation.ts"
      to: "src/services/queryClient.ts"
      via: "cache invalidation strategies"
      pattern: "invalidateQueries"
---

<objective>
Implement virtual scrolling and intelligent query caching infrastructure for optimal performance with large datasets.

Purpose: Establish TanStack Virtual and TanStack Query as the performance foundation, enabling smooth rendering of massive node/edge lists and instant data access through smart caching.
Output: Production-ready virtual scrolling components and intelligent query cache with automatic invalidation.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-advanced-query-and-caching/21-RESEARCH.md
@.planning/phases/20-transaction-and-sync-management/20-02-SUMMARY.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/STACK.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install TanStack libraries and create virtual scrolling infrastructure</name>
  <files>
    package.json
    src/hooks/useVirtualizedList.ts
    src/components/VirtualizedGrid/index.tsx
    src/components/VirtualizedList/index.tsx
  </files>
  <action>
    Install TanStack Virtual v3 and TanStack Query v5 via npm. Create useVirtualizedList hook following research pattern with proper TypeScript types, overscan configuration (10 items), and dynamic sizing support. Build VirtualizedGrid component for node/edge datasets with row and column virtualization, proper positioning transforms, and responsive design. Build VirtualizedList component for linear datasets with smooth scrolling and proper item sizing estimation. Use research-provided examples as foundation, adapting for Isometry's node/edge data structures.
  </action>
  <verify>npm ls @tanstack/react-virtual @tanstack/react-query shows both installed, TypeScript compilation succeeds without errors, components render without console errors in development</verify>
  <done>Virtual scrolling components exist and can be imported, TanStack libraries are installed and properly typed</done>
</task>

<task type="auto">
  <name>Task 2: Enhance useLiveQuery with TanStack Query intelligent caching</name>
  <files>
    src/services/queryClient.ts
    src/hooks/useLiveQuery.ts
  </files>
  <action>
    Create queryClient.ts with TanStack Query configuration following research patterns: 5-minute staleTime, 10-minute gcTime, refetchOnWindowFocus enabled, smart retry logic (max 3 attempts, skip 404s). Enhance existing useLiveQuery hook to integrate with TanStack Query while preserving existing real-time WebView bridge functionality from Phase 19. Add query key generation based on SQL query hash and parameters. Implement stale-while-revalidate pattern - serve cached data immediately while fetching fresh data in background. Maintain backward compatibility with existing useLiveQuery usage patterns throughout the codebase.
  </action>
  <verify>npm run dev starts without errors, existing components using useLiveQuery continue working, query cache visible in React DevTools with proper TTL behavior</verify>
  <done>useLiveQuery provides instant cached responses while maintaining real-time updates, query cache properly configured with TTL and garbage collection</done>
</task>

<task type="auto">
  <name>Task 3: Implement smart cache invalidation strategies</name>
  <files>
    src/utils/cacheInvalidation.ts
    src/hooks/useLiveQuery.ts
  </files>
  <action>
    Create cacheInvalidation.ts utility module with functions for query key pattern matching and selective invalidation strategies. Implement node-specific invalidation (invalidate queries for specific node IDs), graph-wide invalidation (invalidate all graph queries when structure changes), and relationship invalidation (invalidate edge queries when node relationships change). Enhance useLiveQuery to automatically invalidate related queries on mutation success using TanStack Query's onSuccess callbacks. Follow research pattern for optimistic updates with rollback on error. Add invalidation strategies for common Isometry operations: node creation/update/deletion, edge creation/deletion, bulk operations.
  </action>
  <verify>Node mutations automatically invalidate related query cache, graph queries refresh when data changes, optimistic updates rollback properly on failure</verify>
  <done>Cache invalidation happens automatically and selectively, maintaining data consistency without unnecessary re-fetching</done>
</task>

</tasks>

<verification>
1. Virtual scrolling renders 10k+ items smoothly at 60fps
2. Query cache provides instant responses for frequently accessed data
3. Cache invalidation occurs automatically after mutations
4. Memory usage remains stable during virtual scrolling
5. Integration tests pass with existing real-time functionality
</verification>

<success_criteria>
- Large node/edge lists scroll smoothly regardless of dataset size
- Query response times under 50ms for cached data
- Cache hit rate above 80% for repeated queries
- Zero memory leaks during extended virtual scrolling sessions
- Maintains full backward compatibility with existing useLiveQuery patterns
</success_criteria>

<output>
After completion, create `.planning/phases/21-advanced-query-and-caching/21-01-SUMMARY.md`
</output>