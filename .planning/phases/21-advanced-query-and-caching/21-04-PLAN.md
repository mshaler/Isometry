---
phase: 21-advanced-query-and-caching
plan: 04
type: execute
wave: 2
depends_on: ["21-03"]
files_modified: ["src/components/views/ListView.tsx", "src/components/views/GridView.tsx", "src/components/MVPDemo.tsx"]
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Large lists scroll smoothly with virtual rendering regardless of dataset size"
    - "Virtual scrolling maintains 60fps performance with 10k+ items"
    - "Existing views use virtual components for better performance"
  artifacts:
    - path: "src/components/views/ListView.tsx"
      provides: "Virtual list rendering"
      imports: "VirtualizedList"
    - path: "src/components/views/GridView.tsx"
      provides: "Virtual grid rendering"
      imports: "VirtualizedGrid"
  key_links:
    - from: "src/components/views/ListView.tsx"
      to: "src/components/VirtualizedList"
      via: "component import and usage"
      pattern: "import.*VirtualizedList"
    - from: "src/components/views/GridView.tsx"
      to: "src/components/VirtualizedGrid"
      via: "component import and usage"
      pattern: "import.*VirtualizedGrid"
    - from: "useListData hook"
      to: "VirtualizedList items prop"
      via: "data flow integration"
      pattern: "items={.*flatNodes.*}"
---

<objective>
Integrate virtual scrolling components into actual application views to enable smooth performance with large datasets.

Purpose: Replace existing list/grid rendering with virtual scrolling implementations to achieve the performance targets outlined in Phase 21 goals.
Output: ListView and GridView components using VirtualizedList and VirtualizedGrid for optimal performance
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/21-advanced-query-and-caching/21-01-SUMMARY.md
@.planning/phases/21-advanced-query-and-caching/21-02-SUMMARY.md
@.planning/phases/21-advanced-query-and-caching/21-03-SUMMARY.md
@src/components/VirtualizedList/index.tsx
@src/components/VirtualizedGrid/index.tsx
@src/hooks/useVirtualizedList.ts
@src/components/views/ListView.tsx
@src/components/views/GridView.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace ListView with VirtualizedList implementation</name>
  <files>src/components/views/ListView.tsx</files>
  <action>
    Integrate VirtualizedList component into the existing ListView:

    1. Import VirtualizedList from '../VirtualizedList'
    2. Examine current ListView props and data structure
    3. Replace the existing list rendering logic with VirtualizedList
    4. Wire data flow from useListData hook to VirtualizedList:
       - Pass `listData.flatNodes` as `items` prop to VirtualizedList
       - Use ITEM_HEIGHT constant as `estimateItemSize` prop
       - Pass ListView's `height` calculation to VirtualizedList
       - Forward `onNodeClick` callback as `onItemClick` to VirtualizedList
    5. Create renderItem function that renders ListItem component:
       ```tsx
       const renderItem = useCallback((node: Node, index: number) => (
         <ListItem
           key={node.id}
           node={node}
           selected={selection?.id === node.id}
           onClick={() => {
             select(node);
             onNodeClick?.(node);
           }}
         />
       ), [selection, select, onNodeClick]);
       ```
    6. Maintain existing ListView props interface for backward compatibility
    7. Keep existing ListView styling, search bar, and layout wrapper
    8. Preserve loading and error states by conditionally rendering VirtualizedList

    Key integration points:
    - Preserve existing data fetching patterns (useListData continues to work)
    - Maintain click handlers and selection logic through renderItem callback
    - Keep loading and error states in outer component wrapper
    - Honor existing CSS classes and styling on container

    Gap reason: Virtual components exist but are not used anywhere in the app, preventing large dataset performance optimization.
  </action>
  <verify>ListView renders large datasets smoothly using VirtualizedList internally with proper data flow from useListData</verify>
  <done>ListView uses virtual scrolling while maintaining all existing functionality and data integration</done>
</task>

<task type="auto">
  <name>Task 2: Replace GridView with VirtualizedGrid implementation</name>
  <files>src/components/views/GridView.tsx</files>
  <action>
    Integrate VirtualizedGrid component into the existing GridView:

    1. Import VirtualizedGrid from '../VirtualizedGrid'
    2. Examine current GridView props and layout structure
    3. Replace the existing grid rendering logic with VirtualizedGrid
    4. Wire data flow from data source to VirtualizedGrid:
       - Pass grid data array as `items` prop to VirtualizedGrid
       - Configure `columnCount` from existing responsive logic
       - Set `itemHeight` and `itemWidth` from current grid calculations
       - Forward click handlers as `onItemClick` to VirtualizedGrid
    5. Create renderGridItem function for grid cell rendering:
       ```tsx
       const renderGridItem = useCallback((item: Node, index: number) => (
         <div
           key={item.id}
           className="grid-item"
           onClick={() => onItemClick?.(item, index)}
         >
           {/* existing grid item content */}
         </div>
       ), [onItemClick]);
       ```
    6. Maintain existing GridView props interface for backward compatibility
    7. Keep existing GridView styling and responsive behavior
    8. Preserve loading states by conditionally rendering VirtualizedGrid

    Key integration points:
    - Preserve existing grid layout logic and responsive column calculations
    - Maintain item click handlers and selection through renderGridItem
    - Keep responsive column count behavior (columnCount prop changes)
    - Honor existing CSS grid classes and styling on container

    Gap reason: Virtual components exist but GridView still uses standard rendering, limiting performance with large datasets.
  </action>
  <verify>GridView renders large datasets smoothly using VirtualizedGrid internally with proper data flow and responsive layout</verify>
  <done>GridView uses virtual scrolling while maintaining all existing grid functionality and responsive behavior</done>
</task>

<task type="auto">
  <name>Task 3: Update view imports to use virtualized versions</name>
  <files>src/components/MVPDemo.tsx</files>
  <action>
    Ensure the main application properly imports and uses the updated ListView and GridView components:

    1. Verify MVPDemo imports ListView and GridView from the correct paths
    2. Check that view switching logic works with virtualized components
    3. Ensure no direct imports of old non-virtual components exist
    4. Test that data flow from useLiveQuery to virtual components works correctly:
       - Confirm ListView receives data through useListData hook chain
       - Verify GridView gets data through its configured data source
       - Test that both views handle loading and error states properly
    5. Verify that any other components importing ListView/GridView get the virtualized versions

    If MVPDemo doesn't directly import these components, trace through the component hierarchy to find where ListView/GridView are imported and ensure they're getting the updated virtual versions.

    Gap reason: Need to ensure virtualized components are actually used in the app flow rather than orphaned.
  </action>
  <verify>App uses virtualized ListView/GridView components when switching views and data flows correctly from useLiveQuery</verify>
  <done>Virtual scrolling is operational in the live application interface with complete data integration</done>
</task>

</tasks>

<verification>
- [ ] ListView renders using VirtualizedList component
- [ ] GridView renders using VirtualizedGrid component
- [ ] Large datasets (1000+ items) scroll smoothly at 60fps
- [ ] All existing ListView/GridView functionality preserved
- [ ] Data flows correctly from useLiveQuery through useListData to VirtualizedList
- [ ] No performance degradation in app startup
- [ ] View switching continues to work correctly
</verification>

<success_criteria>
- ListView and GridView use virtual scrolling for large datasets
- Virtual scrolling maintains 60fps performance with 10k+ items
- All existing view functionality preserved (selection, clicking, styling)
- Application properly routes to virtualized components
- Data integration works: useLiveQuery -> useListData -> VirtualizedList
- Memory usage remains stable during extended scrolling
</success_criteria>

<output>
After completion, create `.planning/phases/21-advanced-query-and-caching/21-04-SUMMARY.md`
</output>