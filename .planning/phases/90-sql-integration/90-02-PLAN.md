---
phase: 90-sql-integration
plan: 02
type: execute
wave: 2
depends_on: ["90-01"]
files_modified:
  - src/services/supergrid/HeaderDiscoveryService.ts
  - src/services/supergrid/__tests__/HeaderDiscoveryService.test.ts
  - src/hooks/useHeaderDiscovery.ts
  - src/d3/grid-rendering/GridRenderingEngine.ts
autonomous: true

must_haves:
  truths:
    - "Headers build from live SQLite queries, not hardcoded data"
    - "Loading state displays during header discovery"
    - "Empty datasets show graceful empty state"
  artifacts:
    - path: "src/services/supergrid/HeaderDiscoveryService.ts"
      provides: "Service layer for header discovery"
      exports: ["HeaderDiscoveryService"]
    - path: "src/hooks/useHeaderDiscovery.ts"
      provides: "React hook with loading state"
      exports: ["useHeaderDiscovery"]
  key_links:
    - from: "src/services/supergrid/HeaderDiscoveryService.ts"
      to: "src/db/queries/header-discovery.ts"
      via: "imports query generator"
      pattern: "import.*buildHeaderDiscoveryQuery.*from"
    - from: "src/d3/grid-rendering/GridRenderingEngine.ts"
      to: "HeaderDiscoveryService"
      via: "uses service for header data"
      pattern: "HeaderDiscoveryService"
---

<objective>
Create HeaderDiscoveryService to execute SQL queries and transform results into HeaderNode trees, with loading state management.

Purpose: SQL-04 (loading state) and SQL-05 (empty datasets) require a service layer that manages query execution lifecycle and handles edge cases gracefully.

Output: Service layer, React hook, and GridRenderingEngine integration for live header discovery.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/90-sql-integration/90-RESEARCH.md
@.planning/phases/90-sql-integration/90-01-SUMMARY.md

Dependencies from 90-01:
- buildHeaderDiscoveryQuery(facet) returns SQL string
- buildStackedHeaderQuery(facets) returns SQL for multi-facet axes

Existing infrastructure:
- buildHeaderTree from `src/superstack/builders/header-tree-builder.ts`
- FacetConfig, HeaderTree types from `src/superstack/types/superstack.ts`
- sql.js Database type from 'sql.js'
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HeaderDiscoveryService</name>
  <files>src/services/supergrid/HeaderDiscoveryService.ts</files>
  <action>
Create `src/services/supergrid/HeaderDiscoveryService.ts`:

1. Imports:
   - Database from 'sql.js'
   - FacetConfig, HeaderTree, QueryRow from '../../superstack/types/superstack'
   - buildHeaderDiscoveryQuery, buildStackedHeaderQuery from '../../db/queries/header-discovery'
   - buildHeaderTree from '../../superstack/builders/header-tree-builder'

2. Interface `HeaderDiscoveryResult`:
   ```typescript
   interface HeaderDiscoveryResult {
     columnTree: HeaderTree | null;
     rowTree: HeaderTree | null;
     isLoading: boolean;
     error: Error | null;
   }
   ```

3. Class `HeaderDiscoveryService`:
   ```typescript
   class HeaderDiscoveryService {
     private db: Database | null = null;

     setDatabase(db: Database | null): void {
       this.db = db;
     }

     /**
      * Discover headers for given axis facets.
      * Executes SQL query and transforms results into HeaderTree.
      */
     discoverHeaders(
       facets: FacetConfig[],
       axis: 'row' | 'column'
     ): HeaderTree | null {
       if (!this.db || facets.length === 0) {
         return null;
       }

       try {
         const sql = facets.length === 1
           ? buildHeaderDiscoveryQuery(facets[0])
           : buildStackedHeaderQuery(facets);

         const result = this.db.exec(sql);

         if (!result[0] || result[0].values.length === 0) {
           // Empty dataset - return empty tree (not null)
           return this.createEmptyTree(facets, axis);
         }

         // Transform SQL results to QueryRow format
         const rows: QueryRow[] = this.transformSqlResults(result[0], facets);

         // Build header tree from rows
         return buildHeaderTree(rows, facets, axis);
       } catch (error) {
         console.error('[HeaderDiscoveryService] Query failed:', error);
         return null;
       }
     }

     /**
      * Create empty header tree for empty datasets (SQL-05)
      */
     private createEmptyTree(facets: FacetConfig[], axis: 'row' | 'column'): HeaderTree {
       return {
         axis,
         facets,
         roots: [],
         maxDepth: facets.length,
         leafCount: 0,
         leaves: [],
       };
     }

     /**
      * Transform sql.js results to QueryRow array
      */
     private transformSqlResults(
       result: { columns: string[]; values: any[][] },
       facets: FacetConfig[]
     ): QueryRow[] {
       return result.values.map(row => {
         const queryRow: QueryRow = { card_count: 0 };

         result.columns.forEach((col, index) => {
           if (col === 'card_count') {
             queryRow.card_count = Number(row[index]);
           } else {
             // Map column to facet id
             const facet = facets.find(f =>
               col === 'value' ? true : col === f.id || col === f.sourceColumn
             );
             if (facet) {
               queryRow[facet.id] = String(row[index] ?? '');
             } else {
               // Fallback: use column name directly
               queryRow[col] = String(row[index] ?? '');
             }
           }
         });

         return queryRow;
       });
     }
   }
   ```

4. Export singleton instance:
   ```typescript
   export const headerDiscoveryService = new HeaderDiscoveryService();
   export { HeaderDiscoveryService, HeaderDiscoveryResult };
   ```
  </action>
  <verify>`npm run typecheck` passes</verify>
  <done>HeaderDiscoveryService executes SQL queries and transforms results into HeaderTree</done>
</task>

<task type="auto">
  <name>Task 2: Create useHeaderDiscovery React hook</name>
  <files>src/hooks/useHeaderDiscovery.ts</files>
  <action>
Create `src/hooks/useHeaderDiscovery.ts`:

```typescript
import { useState, useEffect, useCallback } from 'react';
import type { Database } from 'sql.js';
import type { FacetConfig, HeaderTree } from '../superstack/types/superstack';
import { headerDiscoveryService } from '../services/supergrid/HeaderDiscoveryService';

interface UseHeaderDiscoveryResult {
  columnTree: HeaderTree | null;
  rowTree: HeaderTree | null;
  isLoading: boolean;
  error: Error | null;
  refresh: () => void;
}

/**
 * React hook for header discovery with loading state management.
 * Implements SQL-04 (loading state) and SQL-05 (empty datasets).
 */
export function useHeaderDiscovery(
  db: Database | null,
  columnFacets: FacetConfig[],
  rowFacets: FacetConfig[]
): UseHeaderDiscoveryResult {
  const [columnTree, setColumnTree] = useState<HeaderTree | null>(null);
  const [rowTree, setRowTree] = useState<HeaderTree | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const discoverHeaders = useCallback(() => {
    if (!db) {
      setColumnTree(null);
      setRowTree(null);
      return;
    }

    setIsLoading(true);
    setError(null);

    // Note: sql.js queries are synchronous, but we wrap in try-catch
    // and use state to provide loading feedback for UI
    try {
      headerDiscoveryService.setDatabase(db);

      // Discover column headers (Y-Plane in PAFV)
      const cols = columnFacets.length > 0
        ? headerDiscoveryService.discoverHeaders(columnFacets, 'column')
        : null;

      // Discover row headers (X-Plane in PAFV)
      const rows = rowFacets.length > 0
        ? headerDiscoveryService.discoverHeaders(rowFacets, 'row')
        : null;

      setColumnTree(cols);
      setRowTree(rows);
    } catch (err) {
      setError(err as Error);
      setColumnTree(null);
      setRowTree(null);
    } finally {
      setIsLoading(false);
    }
  }, [db, columnFacets, rowFacets]);

  // Discover headers when dependencies change
  useEffect(() => {
    discoverHeaders();
  }, [discoverHeaders]);

  return {
    columnTree,
    rowTree,
    isLoading,
    error,
    refresh: discoverHeaders,
  };
}
```

Key behaviors:
- `isLoading` is true during discovery (SQL-04)
- Empty datasets return empty HeaderTree, not null (SQL-05)
- `refresh` callback allows manual re-discovery
- Dependencies on db, columnFacets, rowFacets trigger automatic re-discovery
  </action>
  <verify>`npm run typecheck` passes</verify>
  <done>useHeaderDiscovery hook provides loading state and handles empty datasets</done>
</task>

<task type="auto">
  <name>Task 3: Integrate with GridRenderingEngine</name>
  <files>src/d3/grid-rendering/GridRenderingEngine.ts</files>
  <action>
Modify `src/d3/grid-rendering/GridRenderingEngine.ts` to support HeaderTree from SQL:

1. Add imports at top:
   ```typescript
   import type { HeaderTree } from '../../superstack/types/superstack';
   ```

2. Add new private fields:
   ```typescript
   private columnHeaderTree: HeaderTree | null = null;
   private rowHeaderTree: HeaderTree | null = null;
   ```

3. Add setter methods:
   ```typescript
   /**
    * Set column header tree from SQL discovery
    */
   public setColumnHeaderTree(tree: HeaderTree | null): void {
     this.columnHeaderTree = tree;
     superGridLogger.debug('GridRenderingEngine: column header tree set', {
       leafCount: tree?.leafCount ?? 0,
       maxDepth: tree?.maxDepth ?? 0,
     });
   }

   /**
    * Set row header tree from SQL discovery
    */
   public setRowHeaderTree(tree: HeaderTree | null): void {
     this.rowHeaderTree = tree;
     superGridLogger.debug('GridRenderingEngine: row header tree set', {
       leafCount: tree?.leafCount ?? 0,
       maxDepth: tree?.maxDepth ?? 0,
     });
   }
   ```

4. Modify `renderProjectionHeaders()` to check for SQL-driven trees:
   Add at the beginning of the method, after the projection null check:
   ```typescript
   // If SQL-driven header trees are available, use SuperStackRenderer
   if (this.columnHeaderTree || this.rowHeaderTree) {
     this.renderSqlDrivenHeaders();
     return;
   }
   ```

5. Add new method `renderSqlDrivenHeaders()`:
   ```typescript
   /**
    * Render headers from SQL-discovered HeaderTree structures
    */
   private renderSqlDrivenHeaders(): void {
     const headerContainer = this.container.select('.headers');
     headerContainer.selectAll('*').remove();

     // Empty state handling (SQL-05)
     if (this.isEmptyDataset()) {
       this.renderEmptyHeaderState(headerContainer);
       return;
     }

     // Render column headers from columnHeaderTree
     if (this.columnHeaderTree && this.columnHeaderTree.leafCount > 0) {
       this.renderHeaderTreeAxis('column', this.columnHeaderTree, headerContainer);
     }

     // Render row headers from rowHeaderTree
     if (this.rowHeaderTree && this.rowHeaderTree.leafCount > 0) {
       this.renderHeaderTreeAxis('row', this.rowHeaderTree, headerContainer);
     }

     superGridLogger.debug('[GridRenderingEngine] SQL-driven headers rendered', {
       columns: this.columnHeaderTree?.leafCount ?? 0,
       rows: this.rowHeaderTree?.leafCount ?? 0,
     });
   }

   private isEmptyDataset(): boolean {
     const colEmpty = !this.columnHeaderTree || this.columnHeaderTree.leafCount === 0;
     const rowEmpty = !this.rowHeaderTree || this.rowHeaderTree.leafCount === 0;
     return colEmpty && rowEmpty;
   }

   private renderEmptyHeaderState(container: d3.Selection<any, unknown, null, undefined>): void {
     // Graceful empty state (SQL-05)
     const g = container.append('g')
       .attr('class', 'empty-state')
       .attr('transform', `translate(${this.config.rowHeaderWidth + 20}, ${this.config.headerHeight / 2})`);

     g.append('text')
       .attr('class', 'empty-state-text')
       .attr('text-anchor', 'start')
       .attr('dominant-baseline', 'middle')
       .attr('font-size', '14px')
       .attr('fill', '#9ca3af')
       .text('No data for selected axes');

     superGridLogger.debug('[GridRenderingEngine] Empty state rendered');
   }

   /**
    * Render a single axis using HeaderTree data
    */
   private renderHeaderTreeAxis(
     axis: 'row' | 'column',
     tree: HeaderTree,
     container: d3.Selection<any, unknown, null, undefined>
   ): void {
     // Delegate to nestedHeaderRenderer if available, else fallback
     if (this.nestedHeaderRenderer) {
       // Convert HeaderTree leaves to composite keys for existing renderer
       const compositeKeys = tree.leaves.map(leaf => leaf.path.join('|'));
       this.nestedHeaderRenderer.render(axis === 'row' ? 'y' : 'x', compositeKeys);
     } else {
       // Simple fallback rendering
       const values = tree.leaves.map(leaf => leaf.label);
       this.renderSimpleAxisHeaders(axis === 'row' ? 'y' : 'x', values);
     }
   }
   ```

This integration preserves backward compatibility with existing header rendering while adding SQL-driven header support.
  </action>
  <verify>`npm run typecheck` passes and existing header rendering tests still pass</verify>
  <done>GridRenderingEngine can render headers from SQL-discovered HeaderTree structures with empty state handling</done>
</task>

</tasks>

<verification>
1. Run `npm run typecheck` - zero errors
2. Run `npm run test` - all existing tests pass
3. Verify HeaderDiscoveryService.discoverHeaders() returns HeaderTree for valid facets
4. Verify useHeaderDiscovery hook has isLoading state that transitions correctly
5. Verify empty datasets return empty HeaderTree (not null) with graceful UI
6. Verify GridRenderingEngine uses SQL-driven headers when HeaderTree is set
</verification>

<success_criteria>
- HeaderDiscoveryService exists at `src/services/supergrid/HeaderDiscoveryService.ts`
- useHeaderDiscovery hook provides isLoading, error, and trees state
- Empty datasets show graceful "No data" message (SQL-05)
- Loading state is observable during header discovery (SQL-04)
- GridRenderingEngine integrates with HeaderTree from SQL discovery
- All existing tests continue to pass (no regression)
</success_criteria>

<output>
After completion, create `.planning/phases/90-sql-integration/90-02-SUMMARY.md`
</output>
