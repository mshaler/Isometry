---
phase: 90-sql-integration
plan: 02
type: execute
wave: 2
depends_on: ["90-01"]
files_modified:
  - src/services/supergrid/HeaderDiscoveryService.ts
  - src/services/supergrid/__tests__/HeaderDiscoveryService.test.ts
  - src/hooks/useHeaderDiscovery.ts
  - src/d3/grid-rendering/GridSqlHeaderAdapter.ts
  - src/components/supergrid/SuperGrid.tsx
autonomous: true

must_haves:
  truths:
    - "Headers build from live SQLite queries, not hardcoded data"
    - "Loading state displays during header discovery"
    - "Empty datasets show 'No data for selected axes' message in header area"
  artifacts:
    - path: "src/services/supergrid/HeaderDiscoveryService.ts"
      provides: "Service layer for header discovery"
      exports: ["HeaderDiscoveryService"]
    - path: "src/hooks/useHeaderDiscovery.ts"
      provides: "React hook with loading state"
      exports: ["useHeaderDiscovery"]
  key_links:
    - from: "src/services/supergrid/HeaderDiscoveryService.ts"
      to: "src/db/queries/header-discovery.ts"
      via: "imports query generator"
      pattern: "import.*buildHeaderDiscoveryQuery.*from"
    - from: "src/d3/grid-rendering/GridSqlHeaderAdapter.ts"
      to: "src/d3/grid-rendering/NestedHeaderRenderer.ts"
      via: "uses NestedHeaderRenderer directly (exported class)"
      pattern: "import.*NestedHeaderRenderer.*from"
    - from: "src/components/supergrid/SuperGrid.tsx"
      to: "src/hooks/useHeaderDiscovery.ts"
      via: "uses hook for header state"
      pattern: "useHeaderDiscovery"
    - from: "src/components/supergrid/SuperGrid.tsx"
      to: "src/db/SQLiteProvider.tsx"
      via: "uses useSQLite for db access"
      pattern: "useSQLite"
---

<objective>
Create HeaderDiscoveryService to execute SQL queries and transform results into HeaderNode trees, with loading state management.

Purpose: SQL-04 (loading state) and SQL-05 (empty datasets) require a service layer that manages query execution lifecycle and handles edge cases gracefully.

Output: Service layer, React hook, and GridRenderingEngine integration for live header discovery.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/90-sql-integration/90-RESEARCH.md
@.planning/phases/90-sql-integration/90-01-SUMMARY.md

Dependencies from 90-01:
- buildHeaderDiscoveryQuery(facet) returns SQL string
- buildStackedHeaderQuery(facets) returns SQL for multi-facet axes

Existing infrastructure:
- buildHeaderTree from `src/superstack/builders/header-tree-builder.ts`
- FacetConfig, HeaderTree types from `src/superstack/types/superstack.ts`
- sql.js Database type from 'sql.js'
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HeaderDiscoveryService</name>
  <files>src/services/supergrid/HeaderDiscoveryService.ts</files>
  <action>
Create `src/services/supergrid/HeaderDiscoveryService.ts`:

1. Imports:
   - Database from 'sql.js'
   - FacetConfig, HeaderTree, QueryRow from '../../superstack/types/superstack'
   - buildHeaderDiscoveryQuery, buildStackedHeaderQuery from '../../db/queries/header-discovery'
   - buildHeaderTree from '../../superstack/builders/header-tree-builder'

2. Interface `HeaderDiscoveryResult`:
   ```typescript
   interface HeaderDiscoveryResult {
     columnTree: HeaderTree | null;
     rowTree: HeaderTree | null;
     isLoading: boolean;
     error: Error | null;
   }
   ```

3. Class `HeaderDiscoveryService`:
   ```typescript
   class HeaderDiscoveryService {
     private db: Database | null = null;

     setDatabase(db: Database | null): void {
       this.db = db;
     }

     /**
      * Discover headers for given axis facets.
      * Executes SQL query and transforms results into HeaderTree.
      */
     discoverHeaders(
       facets: FacetConfig[],
       axis: 'row' | 'column'
     ): HeaderTree | null {
       if (!this.db || facets.length === 0) {
         return null;
       }

       try {
         const sql = facets.length === 1
           ? buildHeaderDiscoveryQuery(facets[0])
           : buildStackedHeaderQuery(facets);

         const result = this.db.exec(sql);

         if (!result[0] || result[0].values.length === 0) {
           // Empty dataset - return empty tree (not null)
           return this.createEmptyTree(facets, axis);
         }

         // Transform SQL results to QueryRow format
         const rows: QueryRow[] = this.transformSqlResults(result[0], facets);

         // Build header tree from rows
         return buildHeaderTree(rows, facets, axis);
       } catch (error) {
         console.error('[HeaderDiscoveryService] Query failed:', error);
         return null;
       }
     }

     /**
      * Create empty header tree for empty datasets (SQL-05)
      */
     private createEmptyTree(facets: FacetConfig[], axis: 'row' | 'column'): HeaderTree {
       return {
         axis,
         facets,
         roots: [],
         maxDepth: facets.length,
         leafCount: 0,
         leaves: [],
       };
     }

     /**
      * Transform sql.js results to QueryRow array
      */
     private transformSqlResults(
       result: { columns: string[]; values: any[][] },
       facets: FacetConfig[]
     ): QueryRow[] {
       return result.values.map(row => {
         const queryRow: QueryRow = { card_count: 0 };

         result.columns.forEach((col, index) => {
           if (col === 'card_count') {
             queryRow.card_count = Number(row[index]);
           } else {
             // Map column to facet id
             const facet = facets.find(f =>
               col === 'value' ? true : col === f.id || col === f.sourceColumn
             );
             if (facet) {
               queryRow[facet.id] = String(row[index] ?? '');
             } else {
               // Fallback: use column name directly
               queryRow[col] = String(row[index] ?? '');
             }
           }
         });

         return queryRow;
       });
     }
   }
   ```

4. Export singleton instance:
   ```typescript
   export const headerDiscoveryService = new HeaderDiscoveryService();
   export { HeaderDiscoveryService, HeaderDiscoveryResult };
   ```
  </action>
  <verify>`npm run typecheck` passes</verify>
  <done>HeaderDiscoveryService executes SQL queries and transforms results into HeaderTree</done>
</task>

<task type="auto">
  <name>Task 2: Create useHeaderDiscovery React hook</name>
  <files>src/hooks/useHeaderDiscovery.ts</files>
  <action>
Create `src/hooks/useHeaderDiscovery.ts`:

```typescript
import { useState, useEffect, useCallback } from 'react';
import type { Database } from 'sql.js';
import type { FacetConfig, HeaderTree } from '../superstack/types/superstack';
import { headerDiscoveryService } from '../services/supergrid/HeaderDiscoveryService';

interface UseHeaderDiscoveryResult {
  columnTree: HeaderTree | null;
  rowTree: HeaderTree | null;
  isLoading: boolean;
  error: Error | null;
  refresh: () => void;
}

/**
 * React hook for header discovery with loading state management.
 * Implements SQL-04 (loading state) and SQL-05 (empty datasets).
 */
export function useHeaderDiscovery(
  db: Database | null,
  columnFacets: FacetConfig[],
  rowFacets: FacetConfig[]
): UseHeaderDiscoveryResult {
  const [columnTree, setColumnTree] = useState<HeaderTree | null>(null);
  const [rowTree, setRowTree] = useState<HeaderTree | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const discoverHeaders = useCallback(() => {
    if (!db) {
      setColumnTree(null);
      setRowTree(null);
      return;
    }

    setIsLoading(true);
    setError(null);

    // Note: sql.js queries are synchronous, but we wrap in try-catch
    // and use state to provide loading feedback for UI
    try {
      headerDiscoveryService.setDatabase(db);

      // Discover column headers (Y-Plane in PAFV)
      const cols = columnFacets.length > 0
        ? headerDiscoveryService.discoverHeaders(columnFacets, 'column')
        : null;

      // Discover row headers (X-Plane in PAFV)
      const rows = rowFacets.length > 0
        ? headerDiscoveryService.discoverHeaders(rowFacets, 'row')
        : null;

      setColumnTree(cols);
      setRowTree(rows);
    } catch (err) {
      setError(err as Error);
      setColumnTree(null);
      setRowTree(null);
    } finally {
      setIsLoading(false);
    }
  }, [db, columnFacets, rowFacets]);

  // Discover headers when dependencies change
  useEffect(() => {
    discoverHeaders();
  }, [discoverHeaders]);

  return {
    columnTree,
    rowTree,
    isLoading,
    error,
    refresh: discoverHeaders,
  };
}
```

Key behaviors:
- `isLoading` is true during discovery (SQL-04)
- Empty datasets return empty HeaderTree, not null (SQL-05)
- `refresh` callback allows manual re-discovery
- Dependencies on db, columnFacets, rowFacets trigger automatic re-discovery
  </action>
  <verify>`npm run typecheck` passes</verify>
  <done>useHeaderDiscovery hook provides loading state and handles empty datasets</done>
</task>

<task type="auto">
  <name>Task 3: Create GridSqlHeaderAdapter (uses NestedHeaderRenderer directly)</name>
  <files>src/d3/grid-rendering/GridSqlHeaderAdapter.ts</files>
  <action>
Create NEW file `src/d3/grid-rendering/GridSqlHeaderAdapter.ts` to coordinate SQL-driven headers.

**Why new file:** GridRenderingEngine.ts is 2014 lines (exceeds 500-line structural limit). The `renderNestedAxisHeaders` method is PRIVATE. Instead of modifying the oversized engine to expose a public wrapper, use the NestedHeaderRenderer class directly (it is exported).

```typescript
/**
 * GridSqlHeaderAdapter - Coordinates SQL-driven header rendering
 *
 * This adapter bridges the HeaderDiscoveryService (SQL data) with the existing
 * NestedHeaderRenderer (D3 rendering) without modifying the oversized GridRenderingEngine.
 * Uses NestedHeaderRenderer directly since GridRenderingEngine.renderNestedAxisHeaders is private.
 */

import type { HeaderTree } from '../../superstack/types/superstack';
import { NestedHeaderRenderer } from './NestedHeaderRenderer';
import { superGridLogger } from '../../utils/dev-logger';
import * as d3 from 'd3';

export interface SqlHeaderAdapterConfig {
  rowHeaderWidth: number;
  headerHeight: number;
  cellWidth: number;
  cellHeight: number;
}

export class GridSqlHeaderAdapter {
  private nestedHeaderRenderer: NestedHeaderRenderer;
  private container: d3.Selection<SVGElement, unknown, null, undefined>;
  private config: SqlHeaderAdapterConfig;

  private columnHeaderTree: HeaderTree | null = null;
  private rowHeaderTree: HeaderTree | null = null;

  constructor(
    container: d3.Selection<SVGElement, unknown, null, undefined>,
    config: SqlHeaderAdapterConfig
  ) {
    this.container = container;
    this.config = config;
    // Instantiate NestedHeaderRenderer directly (exported class)
    this.nestedHeaderRenderer = new NestedHeaderRenderer(container, {
      rowHeaderWidth: config.rowHeaderWidth,
      headerHeight: config.headerHeight,
      cellWidth: config.cellWidth,
      cellHeight: config.cellHeight,
    });
  }

  /**
   * Set column header tree from SQL discovery
   */
  public setColumnHeaderTree(tree: HeaderTree | null): void {
    this.columnHeaderTree = tree;
    superGridLogger.debug('GridSqlHeaderAdapter: column header tree set', {
      leafCount: tree?.leafCount ?? 0,
      maxDepth: tree?.maxDepth ?? 0,
    });
  }

  /**
   * Set row header tree from SQL discovery
   */
  public setRowHeaderTree(tree: HeaderTree | null): void {
    this.rowHeaderTree = tree;
    superGridLogger.debug('GridSqlHeaderAdapter: row header tree set', {
      leafCount: tree?.leafCount ?? 0,
      maxDepth: tree?.maxDepth ?? 0,
    });
  }

  /**
   * Check if SQL-driven header trees are available
   */
  public hasSqlDrivenHeaders(): boolean {
    return this.columnHeaderTree !== null || this.rowHeaderTree !== null;
  }

  /**
   * Render SQL-driven headers (called by SuperGrid component)
   */
  public renderSqlDrivenHeaders(): void {
    const headerContainer = this.container.select('.headers');
    headerContainer.selectAll('*').remove();

    // Empty state handling (SQL-05)
    if (this.isEmptyDataset()) {
      this.renderEmptyHeaderState(headerContainer);
      return;
    }

    // Use NestedHeaderRenderer directly (not engine's private method)
    if (this.columnHeaderTree && this.columnHeaderTree.leafCount > 0) {
      const compositeKeys = this.columnHeaderTree.leaves.map(leaf => leaf.path.join('|'));
      this.nestedHeaderRenderer.renderNestedHeaders('x', compositeKeys);
    }

    if (this.rowHeaderTree && this.rowHeaderTree.leafCount > 0) {
      const compositeKeys = this.rowHeaderTree.leaves.map(leaf => leaf.path.join('|'));
      this.nestedHeaderRenderer.renderNestedHeaders('y', compositeKeys);
    }

    superGridLogger.debug('[GridSqlHeaderAdapter] SQL-driven headers rendered', {
      columns: this.columnHeaderTree?.leafCount ?? 0,
      rows: this.rowHeaderTree?.leafCount ?? 0,
    });
  }

  private isEmptyDataset(): boolean {
    const colEmpty = !this.columnHeaderTree || this.columnHeaderTree.leafCount === 0;
    const rowEmpty = !this.rowHeaderTree || this.rowHeaderTree.leafCount === 0;
    return colEmpty && rowEmpty;
  }

  private renderEmptyHeaderState(container: d3.Selection<any, unknown, null, undefined>): void {
    const g = container.append('g')
      .attr('class', 'empty-state')
      .attr('transform', `translate(${this.config.rowHeaderWidth + 20}, ${this.config.headerHeight / 2})`);

    g.append('text')
      .attr('class', 'empty-state-text')
      .attr('text-anchor', 'start')
      .attr('dominant-baseline', 'middle')
      .attr('font-size', '14px')
      .attr('fill', '#9ca3af')
      .text('No data for selected axes');

    superGridLogger.debug('[GridSqlHeaderAdapter] Empty state rendered');
  }
}
```

**Note:** NestedHeaderRenderer is exported from `./NestedHeaderRenderer.ts` and has a public `renderNestedHeaders(axis, compositeKeys)` method. This avoids needing to modify GridRenderingEngine.
  </action>
  <verify>`npm run typecheck` passes</verify>
  <done>GridSqlHeaderAdapter created using NestedHeaderRenderer directly (not modifying oversized engine or assuming non-existent public method)</done>
</task>

<task type="auto">
  <name>Task 4: Wire useHeaderDiscovery to SuperGrid component</name>
  <files>src/components/supergrid/SuperGrid.tsx</files>
  <action>
Modify `src/components/supergrid/SuperGrid.tsx` to connect the useHeaderDiscovery hook to the grid.

**IMPORTANT:** SuperGrid.tsx already uses:
- `useSQLiteQuery` hook which internally uses `useSQLite()` for db access
- `usePAFV()` hook which provides axis mappings

Do NOT add new props (db, columnFacets, rowFacets). Instead, derive them from existing hooks.

1. Add imports at top:
   ```typescript
   import { useHeaderDiscovery } from '../../hooks/useHeaderDiscovery';
   import { GridSqlHeaderAdapter } from '../../d3/grid-rendering/GridSqlHeaderAdapter';
   import { useSQLite } from '../../db/SQLiteProvider';
   import { mapPAFVToFacetConfig } from '../../superstack/utils/facet-mapper'; // Create if needed
   ```

2. Get db from SQLiteProvider (useSQLite already available via hooks/index):
   ```typescript
   // Access db from SQLiteProvider (already used by useSQLiteQuery internally)
   const { db } = useSQLite();
   ```

3. Derive FacetConfig arrays from PAFV mappings:
   ```typescript
   // usePAFV is already used in SuperGrid.tsx at line 84
   // const { state: pafvState } = usePAFV();

   // Convert PAFV mappings to FacetConfig arrays
   // X-axis mapping -> columnFacets, Y-axis mapping -> rowFacets
   const columnFacets = useMemo(() => {
     const xMapping = pafvState.mappings.find(m => m.plane === 'x');
     return xMapping ? [mapAxisMappingToFacetConfig(xMapping)] : [];
   }, [pafvState.mappings]);

   const rowFacets = useMemo(() => {
     const yMapping = pafvState.mappings.find(m => m.plane === 'y');
     return yMapping ? [mapAxisMappingToFacetConfig(yMapping)] : [];
   }, [pafvState.mappings]);
   ```

4. Add helper function (or import from utils) to map AxisMapping to FacetConfig:
   ```typescript
   function mapAxisMappingToFacetConfig(mapping: AxisMapping): FacetConfig {
     // Map LATCH dimension to FacetConfig dataType
     const dataTypeMap: Record<LATCHDimension, string> = {
       time: 'date',
       category: 'select',
       hierarchy: 'select',
       alphabet: 'text',
       location: 'text',
     };
     return {
       id: mapping.field,
       name: mapping.field,
       sourceColumn: mapping.field,
       dataType: dataTypeMap[mapping.dimension] || 'text',
       timeFormat: mapping.dimension === 'time' ? '%Y' : undefined, // Default to year
     };
   }
   ```

5. Use header discovery hook:
   ```typescript
   const {
     columnTree,
     rowTree,
     isLoading: headersLoading,
     error: headerError,
     refresh: refreshHeaders,
   } = useHeaderDiscovery(db, columnFacets, rowFacets);
   ```

6. Create adapter ref and initialize:
   ```typescript
   const sqlHeaderAdapterRef = useRef<GridSqlHeaderAdapter | null>(null);

   useEffect(() => {
     if (svgRef.current) {
       sqlHeaderAdapterRef.current = new GridSqlHeaderAdapter(
         d3.select(svgRef.current),
         {
           rowHeaderWidth: config.rowHeaderWidth,
           headerHeight: config.headerHeight,
           cellWidth: config.cellWidth,
           cellHeight: config.cellHeight,
         }
       );
     }
   }, [config.rowHeaderWidth, config.headerHeight, config.cellWidth, config.cellHeight]);
   ```

7. Update adapter when trees change:
   ```typescript
   useEffect(() => {
     if (sqlHeaderAdapterRef.current) {
       sqlHeaderAdapterRef.current.setColumnHeaderTree(columnTree);
       sqlHeaderAdapterRef.current.setRowHeaderTree(rowTree);
       if (sqlHeaderAdapterRef.current.hasSqlDrivenHeaders()) {
         sqlHeaderAdapterRef.current.renderSqlDrivenHeaders();
       }
     }
   }, [columnTree, rowTree]);
   ```

8. Add loading/error indicators in JSX:
   ```typescript
   {headersLoading && (
     <div className="absolute top-2 right-2 text-sm text-gray-500">
       Discovering headers...
     </div>
   )}
   {headerError && (
     <div className="absolute top-2 right-2 text-sm text-red-500">
       Header discovery failed: {headerError.message}
     </div>
   )}
   ```
  </action>
  <verify>`npm run typecheck` passes and manual test shows header loading state</verify>
  <done>SuperGrid component uses existing hooks (useSQLite, usePAFV) to derive db and facets, wired to useHeaderDiscovery and GridSqlHeaderAdapter</done>
</task>

</tasks>

<verification>
1. Run `npm run typecheck` - zero errors
2. Run `npm run test` - all existing tests pass
3. Verify HeaderDiscoveryService.discoverHeaders() returns HeaderTree for valid facets
4. Verify useHeaderDiscovery hook has isLoading state that transitions correctly
5. Verify empty datasets return empty HeaderTree (not null) with graceful UI
6. Verify GridSqlHeaderAdapter coordinates SQL-driven headers with GridRenderingEngine
7. Verify SuperGrid component wires useHeaderDiscovery to adapter (loading indicator visible)
</verification>

<success_criteria>
- HeaderDiscoveryService exists at `src/services/supergrid/HeaderDiscoveryService.ts`
- useHeaderDiscovery hook provides isLoading, error, and trees state
- Empty datasets show graceful "No data" message (SQL-05)
- Loading state is observable during header discovery (SQL-04)
- GridSqlHeaderAdapter coordinates HeaderTree with GridRenderingEngine (separate module, not engine modification)
- SuperGrid component wires useHeaderDiscovery hook to GridSqlHeaderAdapter
- All existing tests continue to pass (no regression)
</success_criteria>

<output>
After completion, create `.planning/phases/90-sql-integration/90-02-SUMMARY.md`
</output>
