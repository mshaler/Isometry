---
phase: 90-sql-integration
plan: 02
type: execute
wave: 2
depends_on: ["90-01"]
files_modified:
  - src/services/supergrid/HeaderDiscoveryService.ts
  - src/services/supergrid/__tests__/HeaderDiscoveryService.test.ts
  - src/hooks/useHeaderDiscovery.ts
  - src/d3/grid-rendering/GridSqlHeaderAdapter.ts
  - src/components/SuperGrid.tsx
autonomous: true

must_haves:
  truths:
    - "Headers build from live SQLite queries, not hardcoded data"
    - "Loading state displays during header discovery"
    - "Empty datasets show graceful empty state"
  artifacts:
    - path: "src/services/supergrid/HeaderDiscoveryService.ts"
      provides: "Service layer for header discovery"
      exports: ["HeaderDiscoveryService"]
    - path: "src/hooks/useHeaderDiscovery.ts"
      provides: "React hook with loading state"
      exports: ["useHeaderDiscovery"]
  key_links:
    - from: "src/services/supergrid/HeaderDiscoveryService.ts"
      to: "src/db/queries/header-discovery.ts"
      via: "imports query generator"
      pattern: "import.*buildHeaderDiscoveryQuery.*from"
    - from: "src/d3/grid-rendering/GridSqlHeaderAdapter.ts"
      to: "GridRenderingEngine"
      via: "coordinates header rendering"
      pattern: "GridRenderingEngine"
    - from: "src/components/SuperGrid.tsx"
      to: "src/hooks/useHeaderDiscovery.ts"
      via: "uses hook for header state"
      pattern: "useHeaderDiscovery"
---

<objective>
Create HeaderDiscoveryService to execute SQL queries and transform results into HeaderNode trees, with loading state management.

Purpose: SQL-04 (loading state) and SQL-05 (empty datasets) require a service layer that manages query execution lifecycle and handles edge cases gracefully.

Output: Service layer, React hook, and GridRenderingEngine integration for live header discovery.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/90-sql-integration/90-RESEARCH.md
@.planning/phases/90-sql-integration/90-01-SUMMARY.md

Dependencies from 90-01:
- buildHeaderDiscoveryQuery(facet) returns SQL string
- buildStackedHeaderQuery(facets) returns SQL for multi-facet axes

Existing infrastructure:
- buildHeaderTree from `src/superstack/builders/header-tree-builder.ts`
- FacetConfig, HeaderTree types from `src/superstack/types/superstack.ts`
- sql.js Database type from 'sql.js'
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HeaderDiscoveryService</name>
  <files>src/services/supergrid/HeaderDiscoveryService.ts</files>
  <action>
Create `src/services/supergrid/HeaderDiscoveryService.ts`:

1. Imports:
   - Database from 'sql.js'
   - FacetConfig, HeaderTree, QueryRow from '../../superstack/types/superstack'
   - buildHeaderDiscoveryQuery, buildStackedHeaderQuery from '../../db/queries/header-discovery'
   - buildHeaderTree from '../../superstack/builders/header-tree-builder'

2. Interface `HeaderDiscoveryResult`:
   ```typescript
   interface HeaderDiscoveryResult {
     columnTree: HeaderTree | null;
     rowTree: HeaderTree | null;
     isLoading: boolean;
     error: Error | null;
   }
   ```

3. Class `HeaderDiscoveryService`:
   ```typescript
   class HeaderDiscoveryService {
     private db: Database | null = null;

     setDatabase(db: Database | null): void {
       this.db = db;
     }

     /**
      * Discover headers for given axis facets.
      * Executes SQL query and transforms results into HeaderTree.
      */
     discoverHeaders(
       facets: FacetConfig[],
       axis: 'row' | 'column'
     ): HeaderTree | null {
       if (!this.db || facets.length === 0) {
         return null;
       }

       try {
         const sql = facets.length === 1
           ? buildHeaderDiscoveryQuery(facets[0])
           : buildStackedHeaderQuery(facets);

         const result = this.db.exec(sql);

         if (!result[0] || result[0].values.length === 0) {
           // Empty dataset - return empty tree (not null)
           return this.createEmptyTree(facets, axis);
         }

         // Transform SQL results to QueryRow format
         const rows: QueryRow[] = this.transformSqlResults(result[0], facets);

         // Build header tree from rows
         return buildHeaderTree(rows, facets, axis);
       } catch (error) {
         console.error('[HeaderDiscoveryService] Query failed:', error);
         return null;
       }
     }

     /**
      * Create empty header tree for empty datasets (SQL-05)
      */
     private createEmptyTree(facets: FacetConfig[], axis: 'row' | 'column'): HeaderTree {
       return {
         axis,
         facets,
         roots: [],
         maxDepth: facets.length,
         leafCount: 0,
         leaves: [],
       };
     }

     /**
      * Transform sql.js results to QueryRow array
      */
     private transformSqlResults(
       result: { columns: string[]; values: any[][] },
       facets: FacetConfig[]
     ): QueryRow[] {
       return result.values.map(row => {
         const queryRow: QueryRow = { card_count: 0 };

         result.columns.forEach((col, index) => {
           if (col === 'card_count') {
             queryRow.card_count = Number(row[index]);
           } else {
             // Map column to facet id
             const facet = facets.find(f =>
               col === 'value' ? true : col === f.id || col === f.sourceColumn
             );
             if (facet) {
               queryRow[facet.id] = String(row[index] ?? '');
             } else {
               // Fallback: use column name directly
               queryRow[col] = String(row[index] ?? '');
             }
           }
         });

         return queryRow;
       });
     }
   }
   ```

4. Export singleton instance:
   ```typescript
   export const headerDiscoveryService = new HeaderDiscoveryService();
   export { HeaderDiscoveryService, HeaderDiscoveryResult };
   ```
  </action>
  <verify>`npm run typecheck` passes</verify>
  <done>HeaderDiscoveryService executes SQL queries and transforms results into HeaderTree</done>
</task>

<task type="auto">
  <name>Task 2: Create useHeaderDiscovery React hook</name>
  <files>src/hooks/useHeaderDiscovery.ts</files>
  <action>
Create `src/hooks/useHeaderDiscovery.ts`:

```typescript
import { useState, useEffect, useCallback } from 'react';
import type { Database } from 'sql.js';
import type { FacetConfig, HeaderTree } from '../superstack/types/superstack';
import { headerDiscoveryService } from '../services/supergrid/HeaderDiscoveryService';

interface UseHeaderDiscoveryResult {
  columnTree: HeaderTree | null;
  rowTree: HeaderTree | null;
  isLoading: boolean;
  error: Error | null;
  refresh: () => void;
}

/**
 * React hook for header discovery with loading state management.
 * Implements SQL-04 (loading state) and SQL-05 (empty datasets).
 */
export function useHeaderDiscovery(
  db: Database | null,
  columnFacets: FacetConfig[],
  rowFacets: FacetConfig[]
): UseHeaderDiscoveryResult {
  const [columnTree, setColumnTree] = useState<HeaderTree | null>(null);
  const [rowTree, setRowTree] = useState<HeaderTree | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const discoverHeaders = useCallback(() => {
    if (!db) {
      setColumnTree(null);
      setRowTree(null);
      return;
    }

    setIsLoading(true);
    setError(null);

    // Note: sql.js queries are synchronous, but we wrap in try-catch
    // and use state to provide loading feedback for UI
    try {
      headerDiscoveryService.setDatabase(db);

      // Discover column headers (Y-Plane in PAFV)
      const cols = columnFacets.length > 0
        ? headerDiscoveryService.discoverHeaders(columnFacets, 'column')
        : null;

      // Discover row headers (X-Plane in PAFV)
      const rows = rowFacets.length > 0
        ? headerDiscoveryService.discoverHeaders(rowFacets, 'row')
        : null;

      setColumnTree(cols);
      setRowTree(rows);
    } catch (err) {
      setError(err as Error);
      setColumnTree(null);
      setRowTree(null);
    } finally {
      setIsLoading(false);
    }
  }, [db, columnFacets, rowFacets]);

  // Discover headers when dependencies change
  useEffect(() => {
    discoverHeaders();
  }, [discoverHeaders]);

  return {
    columnTree,
    rowTree,
    isLoading,
    error,
    refresh: discoverHeaders,
  };
}
```

Key behaviors:
- `isLoading` is true during discovery (SQL-04)
- Empty datasets return empty HeaderTree, not null (SQL-05)
- `refresh` callback allows manual re-discovery
- Dependencies on db, columnFacets, rowFacets trigger automatic re-discovery
  </action>
  <verify>`npm run typecheck` passes</verify>
  <done>useHeaderDiscovery hook provides loading state and handles empty datasets</done>
</task>

<task type="auto">
  <name>Task 3: Create GridSqlHeaderAdapter (avoids modifying oversized engine)</name>
  <files>src/d3/grid-rendering/GridSqlHeaderAdapter.ts</files>
  <action>
Create NEW file `src/d3/grid-rendering/GridSqlHeaderAdapter.ts` to coordinate SQL-driven headers with GridRenderingEngine.

**Why new file:** GridRenderingEngine.ts is 2014 lines (exceeds 500-line structural limit). Instead of adding ~160 more lines, create an adapter that wraps and coordinates.

```typescript
/**
 * GridSqlHeaderAdapter - Coordinates SQL-driven header rendering with GridRenderingEngine
 *
 * This adapter bridges the HeaderDiscoveryService (SQL data) with the existing
 * GridRenderingEngine (D3 rendering) without modifying the oversized engine.
 * Follows composition over modification principle.
 */

import type { HeaderTree } from '../../superstack/types/superstack';
import type { GridRenderingEngine } from './GridRenderingEngine';
import { superGridLogger } from '../../utils/dev-logger';
import * as d3 from 'd3';

export interface SqlHeaderAdapterConfig {
  rowHeaderWidth: number;
  headerHeight: number;
}

export class GridSqlHeaderAdapter {
  private engine: GridRenderingEngine;
  private container: d3.Selection<SVGElement, unknown, null, undefined>;
  private config: SqlHeaderAdapterConfig;

  private columnHeaderTree: HeaderTree | null = null;
  private rowHeaderTree: HeaderTree | null = null;

  constructor(
    engine: GridRenderingEngine,
    container: d3.Selection<SVGElement, unknown, null, undefined>,
    config: SqlHeaderAdapterConfig
  ) {
    this.engine = engine;
    this.container = container;
    this.config = config;
  }

  /**
   * Set column header tree from SQL discovery
   */
  public setColumnHeaderTree(tree: HeaderTree | null): void {
    this.columnHeaderTree = tree;
    superGridLogger.debug('GridSqlHeaderAdapter: column header tree set', {
      leafCount: tree?.leafCount ?? 0,
      maxDepth: tree?.maxDepth ?? 0,
    });
  }

  /**
   * Set row header tree from SQL discovery
   */
  public setRowHeaderTree(tree: HeaderTree | null): void {
    this.rowHeaderTree = tree;
    superGridLogger.debug('GridSqlHeaderAdapter: row header tree set', {
      leafCount: tree?.leafCount ?? 0,
      maxDepth: tree?.maxDepth ?? 0,
    });
  }

  /**
   * Check if SQL-driven header trees are available
   */
  public hasSqlDrivenHeaders(): boolean {
    return this.columnHeaderTree !== null || this.rowHeaderTree !== null;
  }

  /**
   * Render SQL-driven headers (called by SuperGrid component)
   */
  public renderSqlDrivenHeaders(): void {
    const headerContainer = this.container.select('.headers');
    headerContainer.selectAll('*').remove();

    // Empty state handling (SQL-05)
    if (this.isEmptyDataset()) {
      this.renderEmptyHeaderState(headerContainer);
      return;
    }

    // Delegate to engine's nested header renderer via public API
    if (this.columnHeaderTree && this.columnHeaderTree.leafCount > 0) {
      const compositeKeys = this.columnHeaderTree.leaves.map(leaf => leaf.path.join('|'));
      // Engine exposes nestedHeaderRenderer via getter (add if needed)
      this.engine.renderNestedHeaders('x', compositeKeys);
    }

    if (this.rowHeaderTree && this.rowHeaderTree.leafCount > 0) {
      const compositeKeys = this.rowHeaderTree.leaves.map(leaf => leaf.path.join('|'));
      this.engine.renderNestedHeaders('y', compositeKeys);
    }

    superGridLogger.debug('[GridSqlHeaderAdapter] SQL-driven headers rendered', {
      columns: this.columnHeaderTree?.leafCount ?? 0,
      rows: this.rowHeaderTree?.leafCount ?? 0,
    });
  }

  private isEmptyDataset(): boolean {
    const colEmpty = !this.columnHeaderTree || this.columnHeaderTree.leafCount === 0;
    const rowEmpty = !this.rowHeaderTree || this.rowHeaderTree.leafCount === 0;
    return colEmpty && rowEmpty;
  }

  private renderEmptyHeaderState(container: d3.Selection<any, unknown, null, undefined>): void {
    const g = container.append('g')
      .attr('class', 'empty-state')
      .attr('transform', `translate(${this.config.rowHeaderWidth + 20}, ${this.config.headerHeight / 2})`);

    g.append('text')
      .attr('class', 'empty-state-text')
      .attr('text-anchor', 'start')
      .attr('dominant-baseline', 'middle')
      .attr('font-size', '14px')
      .attr('fill', '#9ca3af')
      .text('No data for selected axes');

    superGridLogger.debug('[GridSqlHeaderAdapter] Empty state rendered');
  }
}
```

**Note:** If GridRenderingEngine does not have `renderNestedHeaders(axis, keys)` public method, add a minimal public wrapper method (3 lines) that delegates to the existing nestedHeaderRenderer. This avoids large changes to the engine.
  </action>
  <verify>`npm run typecheck` passes</verify>
  <done>GridSqlHeaderAdapter created as separate module (not modifying oversized engine) to coordinate SQL-driven header rendering</done>
</task>

<task type="auto">
  <name>Task 4: Wire useHeaderDiscovery to SuperGrid component</name>
  <files>src/components/SuperGrid.tsx</files>
  <action>
Modify `src/components/SuperGrid.tsx` to connect the useHeaderDiscovery hook to the grid:

1. Add import at top:
   ```typescript
   import { useHeaderDiscovery } from '../hooks/useHeaderDiscovery';
   import { GridSqlHeaderAdapter } from '../d3/grid-rendering/GridSqlHeaderAdapter';
   ```

2. Inside SuperGrid component, add hook usage after existing hooks:
   ```typescript
   // SQL-driven header discovery (Phase 90)
   const {
     columnTree,
     rowTree,
     isLoading: headersLoading,
     error: headerError,
     refresh: refreshHeaders,
   } = useHeaderDiscovery(db, columnFacets, rowFacets);
   ```

3. Create adapter ref and initialize with engine:
   ```typescript
   const sqlHeaderAdapterRef = useRef<GridSqlHeaderAdapter | null>(null);

   useEffect(() => {
     if (gridEngine && svgRef.current) {
       sqlHeaderAdapterRef.current = new GridSqlHeaderAdapter(
         gridEngine,
         d3.select(svgRef.current),
         { rowHeaderWidth: config.rowHeaderWidth, headerHeight: config.headerHeight }
       );
     }
   }, [gridEngine, config.rowHeaderWidth, config.headerHeight]);
   ```

4. When header trees change, update adapter and trigger render:
   ```typescript
   useEffect(() => {
     if (sqlHeaderAdapterRef.current) {
       sqlHeaderAdapterRef.current.setColumnHeaderTree(columnTree);
       sqlHeaderAdapterRef.current.setRowHeaderTree(rowTree);

       if (sqlHeaderAdapterRef.current.hasSqlDrivenHeaders()) {
         sqlHeaderAdapterRef.current.renderSqlDrivenHeaders();
       }
     }
   }, [columnTree, rowTree]);
   ```

5. Display loading state when headers are loading (SQL-04):
   ```typescript
   // In the return JSX, add loading indicator
   {headersLoading && (
     <div className="absolute top-2 right-2 text-sm text-gray-500">
       Discovering headers...
     </div>
   )}
   ```

6. Handle header errors gracefully:
   ```typescript
   {headerError && (
     <div className="absolute top-2 right-2 text-sm text-red-500">
       Header discovery failed: {headerError.message}
     </div>
   )}
   ```

Note: `db`, `columnFacets`, `rowFacets` should come from existing SuperGrid props or context. If not present, add them to SuperGridProps interface.
  </action>
  <verify>`npm run typecheck` passes and manual test shows header loading state</verify>
  <done>SuperGrid component uses useHeaderDiscovery hook and connects to GridSqlHeaderAdapter for SQL-driven header rendering</done>
</task>

</tasks>

<verification>
1. Run `npm run typecheck` - zero errors
2. Run `npm run test` - all existing tests pass
3. Verify HeaderDiscoveryService.discoverHeaders() returns HeaderTree for valid facets
4. Verify useHeaderDiscovery hook has isLoading state that transitions correctly
5. Verify empty datasets return empty HeaderTree (not null) with graceful UI
6. Verify GridSqlHeaderAdapter coordinates SQL-driven headers with GridRenderingEngine
7. Verify SuperGrid component wires useHeaderDiscovery to adapter (loading indicator visible)
</verification>

<success_criteria>
- HeaderDiscoveryService exists at `src/services/supergrid/HeaderDiscoveryService.ts`
- useHeaderDiscovery hook provides isLoading, error, and trees state
- Empty datasets show graceful "No data" message (SQL-05)
- Loading state is observable during header discovery (SQL-04)
- GridSqlHeaderAdapter coordinates HeaderTree with GridRenderingEngine (separate module, not engine modification)
- SuperGrid component wires useHeaderDiscovery hook to GridSqlHeaderAdapter
- All existing tests continue to pass (no regression)
</success_criteria>

<output>
After completion, create `.planning/phases/90-sql-integration/90-02-SUMMARY.md`
</output>
