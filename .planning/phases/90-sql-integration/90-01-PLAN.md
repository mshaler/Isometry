---
phase: 90-sql-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/queries/header-discovery.ts
  - src/db/queries/__tests__/header-discovery.test.ts
autonomous: true

must_haves:
  truths:
    - "Header discovery query returns unique facet values with counts"
    - "Time facets extract year/quarter/month via strftime"
    - "Multi-select facets (tags) explode via json_each"
  artifacts:
    - path: "src/db/queries/header-discovery.ts"
      provides: "Query generator for header discovery"
      exports: ["buildHeaderDiscoveryQuery", "buildStackedHeaderQuery"]
    - path: "src/db/queries/__tests__/header-discovery.test.ts"
      provides: "Unit tests for query generation"
      min_lines: 50
  key_links:
    - from: "src/db/queries/header-discovery.ts"
      to: "FacetConfig"
      via: "imports superstack types"
      pattern: "import.*FacetConfig.*from.*superstack"
---

<objective>
Create SQL query generator for header discovery that builds GROUP BY queries based on facet type.

Purpose: SQL-01, SQL-02, SQL-03 require dynamic query generation that dispatches on facet type (time, multi_select, simple) to build appropriate header discovery queries.

Output: Query generator module with full test coverage for all facet types.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/90-sql-integration/90-RESEARCH.md

Key patterns from research:
- Existing pattern in `src/db/queries/facet-aggregates.ts` (GROUP BY with COUNT)
- strftime() for year/quarter/month extraction
- json_each() for tags array explosion
- FacetConfig type defined in `src/superstack/types/superstack.ts`
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create header discovery query generator</name>
  <files>src/db/queries/header-discovery.ts</files>
  <action>
Create `src/db/queries/header-discovery.ts` with:

1. Import FacetConfig from `../../superstack/types/superstack`
2. `buildHeaderDiscoveryQuery(facet: FacetConfig): string` function that dispatches on facet.dataType:

**Error handling:**
- Throw `TypeError('Unsupported dataType: ${facet.dataType}')` for unknown dataTypes
- Throw `TypeError('Missing timeFormat for date facet')` when dataType is 'date' but timeFormat is undefined
- Return empty result (not error) for empty sourceColumn (defensive)
   - For `date` type with timeFormat:
     - '%Y' (year): `SELECT strftime('%Y', {column}) as value, COUNT(*) as card_count FROM nodes WHERE deleted_at IS NULL AND {column} IS NOT NULL GROUP BY value ORDER BY value DESC`
     - '%Q' (quarter): Use formula `'Q' || ((CAST(strftime('%m', {column}) AS INTEGER) - 1) / 3 + 1)`
     - '%B' (month name): `strftime('%B', {column})` with numeric ORDER BY `strftime('%m', {column})`
     - '%W' (week): `strftime('%W', {column})` for ISO week number
   - For `multi_select` type (tags):
     ```sql
     SELECT json_each.value, COUNT(*) as card_count
     FROM nodes, json_each(nodes.{column})
     WHERE nodes.deleted_at IS NULL AND nodes.{column} IS NOT NULL AND nodes.{column} != '[]'
     GROUP BY json_each.value
     ORDER BY card_count DESC
     ```
   - For `text`, `select` types (simple):
     ```sql
     SELECT COALESCE({column}, 'Unassigned') as value, COUNT(*) as card_count
     FROM nodes
     WHERE deleted_at IS NULL
     GROUP BY value
     ORDER BY card_count DESC
     ```

3. `buildStackedHeaderQuery(facets: FacetConfig[]): string` function for multi-facet axes:
   - Build SELECT clause with all facet columns using appropriate extraction (strftime for dates)
   - Build GROUP BY clause with same columns
   - Include card_count aggregate
   - Handle up to 3 facet levels (year > quarter > month or folder > status > priority)

4. Helper function `buildFacetSelect(facet: FacetConfig): string` to generate SQL fragment for a single facet:
   - Returns `strftime('{format}', {column}) as {alias}` for date facets
   - Returns `json_each.value as {alias}` for multi_select (note: requires special handling in FROM clause)
   - Returns `COALESCE({column}, 'Unassigned') as {alias}` for simple facets

Follow existing pattern from `src/db/queries/facet-aggregates.ts` for module structure.
  </action>
  <verify>`npm run typecheck` passes with zero errors</verify>
  <done>Query generator dispatches on facet.dataType and returns correct SQL for time, multi_select, and simple facets</done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for query generator</name>
  <files>src/db/queries/__tests__/header-discovery.test.ts</files>
  <action>
Create `src/db/queries/__tests__/header-discovery.test.ts` with Vitest tests:

1. Test setup:
   - Import buildHeaderDiscoveryQuery, buildStackedHeaderQuery from '../header-discovery'
   - Import FacetConfig from '../../../superstack/types/superstack'
   - Create mock FacetConfig objects for each facet type

2. Test cases for `buildHeaderDiscoveryQuery`:
   - **Year facet**: Verify SQL contains `strftime('%Y', created_at)` and `GROUP BY value`
   - **Quarter facet**: Verify SQL contains quarter calculation formula
   - **Month facet**: Verify SQL contains `strftime('%B', {column})` with numeric ORDER BY
   - **Week facet**: Verify SQL contains `strftime('%W', {column})`
   - **Tags facet**: Verify SQL contains `json_each` and `GROUP BY json_each.value`
   - **Simple facet (folder)**: Verify SQL contains `COALESCE(folder, 'Unassigned')`
   - **All queries**: Verify `deleted_at IS NULL` filter present
   - **Error handling**: Verify `TypeError` thrown for unsupported dataType
   - **Error handling**: Verify `TypeError` thrown for date facet without timeFormat

3. **Performance benchmark test (MANDATORY - SQL performance target):**
   - **Setup:**
     - Import initSqlJs from 'sql.js'
     - Initialize in-memory database: `const SQL = await initSqlJs(); const db = new SQL.Database();`
     - Create nodes table: `db.run('CREATE TABLE nodes (...)')`
     - Generate 10,000 mock nodes using a loop: `for (let i = 0; i < 10000; i++) { db.run('INSERT INTO nodes ...') }`
     - Ensure varied values for status, priority, tags (JSON array), created_at (dates across 3 years)
   - **Test cases:**
     - Execute buildHeaderDiscoveryQuery for simple facet (folder) → db.exec(sql)
     - Execute buildHeaderDiscoveryQuery for date facet (year extraction) → db.exec(sql)
     - Execute buildHeaderDiscoveryQuery for multi_select facet (tags) → db.exec(sql)
   - **Assertions (MUST PASS):**
     - Each query completes in <100ms (using `performance.now()` before/after)
     - Results contain expected structure (values array, columns array)
   - This is a **mandatory** test case, not optional. If it fails, the plan fails.

4. Test cases for `buildStackedHeaderQuery`:
   - **Year > Quarter > Month**: Verify all three extractions in SELECT and GROUP BY
   - **Folder > Status**: Verify both columns in SELECT and GROUP BY
   - **Single facet fallback**: Verify works with single-element array

5. Snapshot tests (optional but recommended):
   - Snapshot generated SQL for each facet type to catch unintended changes

Run: `npm run test -- src/db/queries/__tests__/header-discovery.test.ts`
  </action>
  <verify>`npm run test -- src/db/queries/__tests__/header-discovery.test.ts` shows all tests passing</verify>
  <done>All unit tests pass covering year, quarter, month, week, tags, simple facets, error handling, and performance benchmark</done>
</task>

</tasks>

<verification>
1. Run `npm run typecheck` - zero errors
2. Run `npm run test -- src/db/queries/__tests__/header-discovery.test.ts` - all tests pass
3. Verify `buildHeaderDiscoveryQuery` handles all facet types from FacetConfig.dataType
4. Verify SQL output matches patterns from 90-RESEARCH.md
5. **Performance benchmark test passes** - all queries complete in <100ms for 10K nodes
</verification>

<success_criteria>
- Query generator module exists at `src/db/queries/header-discovery.ts`
- All facet types (date with timeFormat, multi_select, text, select) generate valid SQL
- Time facets use strftime() correctly
- Multi-select facets use json_each() correctly
- All queries include `deleted_at IS NULL` filter
- Unit tests cover all facet type combinations
</success_criteria>

<output>
After completion, create `.planning/phases/90-sql-integration/90-01-SUMMARY.md`
</output>
