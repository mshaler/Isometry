---
phase: 26-virtual-scrolling-performance-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [
  "src/hooks/useVirtualLiveQuery.ts",
  "src/components/VirtualizedGrid/index.tsx",
  "src/components/VirtualizedList/index.tsx",
  "src/components/views/GridView.tsx",
  "src/components/views/ListView.tsx",
  "src/utils/bridge-optimization/performance-monitor.ts"
]
autonomous: true

must_haves:
  truths:
    - "VirtualizedGrid renders live data from useLiveQuery instead of static props"
    - "VirtualizedList renders live data from useLiveQuery instead of static props"
    - "Large datasets (10k+ items) scroll smoothly with real-time database updates"
    - "Cache invalidation properly updates virtual scrolling rendered items"
    - "Performance gains are measurable: cache hits >80%, scroll frame rate 60fps"
    - "Large dataset navigation responds instantly from cached data"
  artifacts:
    - path: "src/hooks/useVirtualLiveQuery.ts"
      provides: "Unified hook combining useLiveQuery with virtual scrolling optimization"
      exports: ["useVirtualLiveQuery"]
    - path: "src/components/VirtualizedGrid/index.tsx"
      provides: "Enhanced VirtualizedGrid with live data support"
      contains: "useVirtualLiveQuery"
    - path: "src/components/VirtualizedList/index.tsx"
      provides: "Enhanced VirtualizedList with live data support"
      contains: "useVirtualLiveQuery"
    - path: "src/components/views/GridView.tsx"
      provides: "GridView using SQL queries instead of static data"
      contains: "sql prop"
    - path: "src/components/views/ListView.tsx"
      provides: "ListView using SQL queries instead of static data"
      contains: "sql prop"
    - path: "src/utils/bridge-optimization/performance-monitor.ts"
      provides: "Extended performance metrics for virtual scrolling"
      contains: "VirtualScrollingMetrics"
  key_links:
    - from: "src/components/views/GridView.tsx"
      to: "src/hooks/useVirtualLiveQuery.ts"
      via: "useVirtualLiveQuery hook import and call"
      pattern: "useVirtualLiveQuery\\("
    - from: "src/hooks/useVirtualLiveQuery.ts"
      to: "src/hooks/useLiveQuery.ts"
      via: "live query data integration"
      pattern: "useLiveQuery\\("
    - from: "src/components/VirtualizedGrid/index.tsx"
      to: "src/hooks/useVirtualLiveQuery.ts"
      via: "virtual live data hook"
      pattern: "useVirtualLiveQuery\\("
    - from: "src/utils/bridge-optimization/performance-monitor.ts"
      to: "src/hooks/useVirtualLiveQuery.ts"
      via: "performance metrics integration"
      pattern: "VirtualScrollingMetrics"
---

<objective>
Integrate VirtualizedGrid/List components with useLiveQuery for live data and caching benefits, replacing static data props with SQL queries for real-time database synchronization.

Purpose: Close the final gap in the v3.1 milestone by connecting virtual scrolling performance infrastructure with live query capabilities, enabling 60fps scrolling with 10k+ items and >80% cache hit rates.

Output: Production-ready virtual scrolling components that render live database data with intelligent caching and real-time updates.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-virtual-scrolling-performance-integration/26-RESEARCH.md
@src/hooks/useLiveQuery.ts
@src/hooks/useVirtualizedList.ts
@src/components/VirtualizedGrid/index.tsx
@src/components/views/GridView.tsx
@src/utils/bridge-optimization/performance-monitor.ts
</context>

<tasks>

<task type="auto">
  <name>Create useVirtualLiveQuery Hook</name>
  <files>src/hooks/useVirtualLiveQuery.ts</files>
  <action>
    Create a new hook that combines useLiveQuery with virtual scrolling optimization. This hook should:
    - Accept SQL query and params instead of static data array
    - Integrate useLiveQuery for real-time data and caching
    - Add virtual scrolling specific options (estimateItemSize, overscan, enableDynamicSizing)
    - Include performance monitoring for frame rate and cache efficiency
    - Support batch updates to prevent excessive re-renders during live updates
    - Provide cache synchronization between TanStack Query and virtual scrolling
    - Return both live query result and virtual scrolling utilities

    Interface should include:
    ```typescript
    interface VirtualLiveQueryOptions extends LiveQueryOptions {
      estimateItemSize?: number;
      overscan?: number;
      enableDynamicSizing?: boolean;
      enableVirtualCaching?: boolean;
      updateBatchingMs?: number;
      performanceMonitoring?: boolean;
    }

    interface VirtualLiveQueryResult<T> extends LiveQueryResult<T> {
      virtualItems: VirtualItem[];
      totalSize: number;
      scrollToIndex: (index: number) => void;
      scrollToOffset: (offset: number) => void;
      isScrolling: boolean;
      performanceMetrics?: VirtualScrollingMetrics;
    }
    ```

    Implement cache synchronization layer that monitors TanStack Query updates and efficiently propagates changes to virtual scrolling without causing full re-renders.
  </action>
  <verify>Check that hook exports useVirtualLiveQuery function with proper TypeScript types and integrates both useLiveQuery and useVirtualizedList functionality</verify>
  <done>useVirtualLiveQuery hook combines live database queries with virtual scrolling optimization and performance monitoring</done>
</task>

<task type="auto">
  <name>Enhanced Virtual Components with Live Data</name>
  <files>src/components/VirtualizedGrid/index.tsx, src/components/VirtualizedList/index.tsx</files>
  <action>
    Update VirtualizedGrid and VirtualizedList components to support live data through SQL queries:

    **VirtualizedGrid Changes:**
    - Add optional `sql` and `queryParams` props
    - When sql prop provided, use useVirtualLiveQuery instead of static items
    - Connect sql prop to useVirtualLiveQuery with proper loading/error state handling: { data, loading, error } = useVirtualLiveQuery(sql, queryParams)
    - Maintain backward compatibility by keeping items prop for static data
    - Add loading states for live data fetching (loading skeleton, error boundary)
    - Include error boundaries for database query failures
    - Support performance monitoring integration via performanceMetrics prop

    **VirtualizedList Changes:**
    - Apply same pattern as VirtualizedGrid for sql/useVirtualLiveQuery integration
    - Add sql/queryParams props with useVirtualLiveQuery integration
    - Maintain backward compatibility with items prop
    - Include proper loading and error states (loading overlay, error fallback)
    - Wire performance monitoring pipeline: useVirtualLiveQuery → performance-monitor.ts

    **Component Interface Updates:**
    ```typescript
    interface VirtualizedGridProps<T> {
      // Existing static data props (for backward compatibility)
      items?: T[];

      // New live data props
      sql?: string;
      queryParams?: unknown[];
      liveOptions?: VirtualLiveQueryOptions;

      // Existing props remain unchanged
      height: number;
      width: number;
      // ... rest of existing interface
    }
    ```

    Ensure components gracefully handle transitions between loading, error, and data states when using live queries.
  </action>
  <verify>Check that VirtualizedGrid and VirtualizedList can render live data from SQL queries while maintaining backward compatibility with static data props</verify>
  <done>Virtual scrolling components support both static data and live SQL queries with proper loading/error states</done>
</task>

<task type="auto">
  <name>Update View Components for Live Data</name>
  <files>src/components/views/GridView.tsx, src/components/views/ListView.tsx</files>
  <action>
    Update GridView and ListView to use SQL queries instead of static data props:

    **GridView Updates:**
    - Replace `data: Node[]` prop with `sql: string` and optional `queryParams: unknown[]`
    - Remove static data passing to VirtualizedGrid
    - Use VirtualizedGrid's new sql prop instead of items prop
    - Remove data.length checks and empty state logic (handled by VirtualizedGrid live data)
    - Maintain existing network-aware performance optimizations
    - Keep existing node rendering and click handling logic
    - Update prop interface and component call sites

    **ListView Updates:**
    - Apply same pattern as GridView
    - Replace static data props with sql query props
    - Use VirtualizedList's live data capabilities
    - Maintain existing performance optimizations and styling

    **Example Interface Change:**
    ```typescript
    // Old
    interface GridViewProps {
      data: Node[];
      onNodeClick?: (node: Node) => void;
    }

    // New
    interface GridViewProps {
      sql: string;
      queryParams?: unknown[];
      onNodeClick?: (node: Node) => void;
      liveOptions?: VirtualLiveQueryOptions;
    }
    ```

    Ensure network-aware configurations still apply to live data queries and virtual scrolling performance.
  </action>
  <verify>Check that GridView and ListView accept SQL queries and properly delegate to VirtualizedGrid/List with live data support</verify>
  <done>View components use SQL queries for live data instead of requiring pre-fetched static arrays</done>
</task>

<task type="auto">
  <name>Extend Performance Monitoring</name>
  <files>src/utils/bridge-optimization/performance-monitor.ts</files>
  <action>
    Extend the existing PerformanceMonitor to include virtual scrolling metrics that integrate with the live query performance pipeline:

    **Add Virtual Scrolling Metrics Interface:**
    ```typescript
    interface VirtualScrollingMetrics {
      frameRate: number;
      viewportUtilization: number;
      cacheEfficiency: {
        virtualItemHitRate: number;
        queryHitRate: number;
        combinedEfficiency: number;
      };
      updateLatency: {
        queryToVirtual: number;
        renderToScreen: number;
        totalPipeline: number;
      };
      memoryUsage: {
        virtualItemCount: number;
        renderedItemCount: number;
        memoryEfficiency: number;
      };
    }
    ```

    **Integration Methods:**
    - `trackVirtualScrollingFrame(frameTime: number)` - Monitor scroll performance
    - `trackCacheEfficiency(virtualHits: number, queryHits: number, total: number)` - Cache metrics
    - `trackUpdateLatency(queryTime: number, virtualTime: number, renderTime: number)` - Pipeline timing
    - `getVirtualScrollingMetrics(): VirtualScrollingMetrics` - Aggregate metrics
    - `getIntegratedPerformanceScore(): number` - Combined live query + virtual scrolling score

    Add integration points with existing bridge performance monitoring to provide unified metrics dashboard showing both live data and virtual scrolling performance.

    Ensure metrics collection has minimal performance impact and can be enabled/disabled for production builds.
  </action>
  <verify>Check that performance monitoring includes virtual scrolling metrics and integrates with existing bridge optimization monitoring</verify>
  <done>Performance monitoring system tracks virtual scrolling metrics and provides unified performance score for live data + virtual scrolling integration</done>
</task>

</task>

<task type="auto">
  <name>Real-Time Update Propagation Integration</name>
  <files>src/hooks/useVirtualLiveQuery.ts, src/utils/bridge-optimization/performance-monitor.ts</files>
  <action>
    Ensure real-time database changes propagate to virtual scrolling components within 100ms through proper integration of the performance monitoring pipeline:

    **useVirtualLiveQuery Real-Time Integration:**
    - Wire useLiveQuery change notifications to virtual scrolling updates
    - Implement debounced virtual component re-rendering (max 100ms delay)
    - Add update latency tracking: database change → virtual component render
    - Ensure TanStack Query cache invalidation triggers virtual item refresh
    - Monitor and log real-time update performance metrics

    **Performance Pipeline Wiring:**
    - useLiveQuery detects database changes → triggers cache invalidation
    - useVirtualLiveQuery receives cache update → schedules virtual component update
    - performance-monitor.ts tracks full pipeline: database → cache → virtual → render
    - Track updateLatency.queryToVirtual and updateLatency.renderToScreen metrics
    - Log performance warnings if updates exceed 100ms threshold

    **Integration Verification:**
    - Add performance assertions: updateLatency.totalPipeline < 100ms
    - Implement circuit breaker pattern for slow update propagation
    - Provide fallback to static data mode if real-time updates fail repeatedly

    This ensures VLS-03 compliance for real-time update propagation within performance requirements.
  </action>
  <verify>Check that database changes appear in virtual scrolling components within 100ms and performance monitoring tracks the full update pipeline</verify>
  <done>Real-time database changes propagate to virtual components within 100ms with full performance monitoring coverage</done>
</task>

</tasks>

<verification>
1. useVirtualLiveQuery hook successfully combines live database queries with virtual scrolling
2. VirtualizedGrid and VirtualizedList support both static data (backward compatibility) and live SQL queries
3. GridView and ListView accept SQL queries and delegate to virtual components with live data
4. Performance monitoring tracks virtual scrolling metrics integrated with live query performance
5. Large datasets (10k+ items) render with 60fps scrolling and >80% cache hit rates
6. Real-time database updates properly propagate to virtual scrolling components within 100ms
7. Performance monitoring pipeline tracks: useLiveQuery → useVirtualLiveQuery → performance-monitor.ts
8. Memory management prevents leaks during virtual scrolling with live data updates
</verification>

<success_criteria>
1. **Live Data Integration**: VirtualizedGrid/List render live database results instead of static arrays
2. **Performance Targets Met**: 60fps scrolling sustained, >80% cache hit rate achieved
3. **Real-Time Updates**: Database changes appear in virtual scrolling components within 100ms
4. **Large Dataset Support**: Smooth operation with 10k+ items without performance degradation
5. **Backward Compatibility**: Existing static data usage continues to work unchanged
6. **Cache Coordination**: TanStack Query and virtual item caches work together efficiently
7. **Performance Monitoring**: useLiveQuery → useVirtualLiveQuery → performance-monitor.ts pipeline tracks integrated metrics
8. **Memory Efficiency**: No memory leaks during extended scrolling with live data updates
</success_criteria>

<output>
After completion, create `.planning/phases/26-virtual-scrolling-performance-integration/26-01-SUMMARY.md`
</output>