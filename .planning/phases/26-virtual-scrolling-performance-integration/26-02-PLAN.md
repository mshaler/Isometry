---
phase: 26-virtual-scrolling-performance-integration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [
  "src/hooks/useVirtualLiveQuery.ts"
]
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Performance gains are measurable: cache hits >80%, scroll frame rate 60fps"
    - "Large dataset navigation responds instantly from cached data"
  artifacts:
    - path: "src/hooks/useVirtualLiveQuery.ts"
      provides: "Integrated performance monitoring with PerformanceMonitor class"
      contains: "import.*PerformanceMonitor"
  key_links:
    - from: "src/hooks/useVirtualLiveQuery.ts"
      to: "src/utils/bridge-optimization/performance-monitor.ts"
      via: "PerformanceMonitor method calls"
      pattern: "trackVirtualScrollingFrame|trackCacheEfficiency|trackUpdateLatency"
---

<objective>
Complete the performance monitoring integration by wiring PerformanceMonitor into useVirtualLiveQuery, enabling system-wide virtual scrolling metrics tracking and large dataset optimization.

Purpose: Close the final gaps in Phase 26 by integrating the existing PerformanceMonitor class with useVirtualLiveQuery to enable measurable performance gains and support for large dataset navigation.

Output: Fully integrated performance monitoring pipeline that tracks virtual scrolling metrics and provides cache optimization for large datasets.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-virtual-scrolling-performance-integration/26-01-VERIFICATION.md
@src/hooks/useVirtualLiveQuery.ts
@src/utils/bridge-optimization/performance-monitor.ts
</context>

<tasks>

<task type="auto">
  <name>Wire Performance Monitoring Integration</name>
  <files>src/hooks/useVirtualLiveQuery.ts</files>
  <action>
    Integrate PerformanceMonitor into useVirtualLiveQuery to close the performance monitoring gap:

    **Import PerformanceMonitor:**
    - Add import: `import { PerformanceMonitor } from '../utils/bridge-optimization/performance-monitor';`
    - Create performance monitor instance for virtual scrolling metrics

    **Track Virtual Scrolling Frame Performance:**
    - Call `trackVirtualScrollingFrame(frameTime)` during scroll events
    - Measure frame time in the virtualizer scroll handler
    - Track when isScrolling state changes to measure frame rate

    **Track Cache Efficiency:**
    - Call `trackCacheEfficiency(virtualHits, queryHits, total)` when cache metrics are calculated
    - Integrate with existing cache efficiency calculations around lines 280-295
    - Pass virtualItemHitRate, queryHitRate, and total requests to the method

    **Track Update Latency:**
    - Call `trackUpdateLatency(queryTime, virtualTime, renderTime)` in the performance pipeline
    - Track when useLiveQuery data changes trigger virtual component updates
    - Measure timing from query change → virtual item update → render completion
    - Add timing measurements to the useEffect that handles data updates

    **Large Dataset Cache Optimization:**
    - Add cache size limits for virtual item metadata when dealing with 10k+ items
    - Implement sliding window cache strategy for virtual item positioning
    - Optimize memory usage with virtual item recycling for large datasets
    - Add performance assertions for large dataset scenarios (>10k items)

    Reference existing work:
    - PerformanceMonitor class has trackVirtualScrollingFrame, trackCacheEfficiency, trackUpdateLatency methods (lines 326-390)
    - useVirtualLiveQuery already calculates local performance metrics around lines 280-295
    - Current implementation has VirtualScrollingMetrics interface but doesn't wire it to global monitoring

    Gap reason: "Performance monitoring integration is incomplete - PerformanceMonitor not wired to useVirtualLiveQuery" and "No evidence of large dataset testing or cache optimization for 10k+ items"
  </action>
  <verify>Check that useVirtualLiveQuery imports PerformanceMonitor and calls trackVirtualScrollingFrame(), trackCacheEfficiency(), and trackUpdateLatency() methods with appropriate timing</verify>
  <done>PerformanceMonitor is integrated with useVirtualLiveQuery providing system-wide virtual scrolling metrics and large dataset optimization</done>
</task>

</tasks>

<verification>
1. PerformanceMonitor is imported in useVirtualLiveQuery
2. trackVirtualScrollingFrame() is called during scroll events with frame timing
3. trackCacheEfficiency() is called with virtual and query cache hit rates
4. trackUpdateLatency() is called for the full update pipeline timing
5. Large dataset cache optimization strategies are implemented
6. Performance monitoring integration provides measurable cache hits >80% and 60fps scrolling
</verification>

<success_criteria>
1. **Performance Monitoring Integration**: PerformanceMonitor methods are called from useVirtualLiveQuery
2. **Measurable Performance Gains**: System can track and report cache hits >80% and 60fps scrolling
3. **Large Dataset Optimization**: Cache strategies optimize performance for 10k+ items
4. **System-Wide Metrics**: Virtual scrolling performance integrates with global performance monitoring
5. **Gap Closure**: Both failed verification truths are addressed through integration
</success_criteria>

<output>
After completion, create `.planning/phases/26-virtual-scrolling-performance-integration/26-02-SUMMARY.md`
</output>