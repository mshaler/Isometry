---
phase: 70-integration
plan: 01
type: execute
wave: 1
depends_on: ["69"]
files_modified:
  - src/etl/database/insertion.ts
  - src/etl/database/__tests__/insertion.test.ts
  - src/etl/bridge/window-export.ts
  - src/types/global.d.ts
autonomous: true

must_haves:
  truths:
    - "insertCanonicalNodes() inserts CanonicalNode[] into sql.js with proper field mapping"
    - "Tags array serialized as JSON string for SQL storage"
    - "Properties stored directly to node_properties table using same pattern as property-storage.ts"
    - "window.isometryETL.importFile() exposes ETL API"
  artifacts:
    - path: "src/etl/database/insertion.ts"
      provides: "insertCanonicalNodes() utility"
      exports: ["insertCanonicalNodes", "InsertResult"]
    - path: "src/etl/bridge/window-export.ts"
      provides: "Window API bridge module"
      exports: ["initializeETLBridge"]
    - path: "src/types/global.d.ts"
      provides: "Window interface extension"
      contains: "isometryETL"
  key_links:
    - from: "src/etl/database/insertion.ts"
      to: "src/etl/types/canonical.ts"
      via: "toSQLRecord() import for column mapping"
      pattern: "import.*toSQLRecord.*from.*canonical"
    - from: "src/etl/bridge/window-export.ts"
      to: "src/etl/coordinator/ImportCoordinator.ts"
      via: "importFile delegation"
      pattern: "ImportCoordinator"
---

<objective>
Create database insertion utilities and window API for ETL bridge.

Purpose: Enable Swift bridge to call JavaScript ETL functions and insert CanonicalNode arrays into sql.js.
Output: insertCanonicalNodes() utility, window.isometryETL.importFile() API.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/etl/types/canonical.ts
@src/etl/coordinator/ImportCoordinator.ts
@src/etl/storage/property-storage.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create insertCanonicalNodes() database utility</name>
  <files>src/etl/database/insertion.ts</files>
  <action>
Create new file with database insertion utilities:

1. Import dependencies:
   ```typescript
   import type { Database } from 'sql.js';
   import { CanonicalNode, toSQLRecord, SQL_COLUMN_MAP } from '../types/canonical';
   ```

   Note: toSQLRecord is exported from canonical.ts and handles the camelCase->snake_case
   mapping internally. Do NOT import `run` from db/operations.ts - use db.run() directly
   like property-storage.ts does.

2. Define InsertResult interface:
   ```typescript
   export interface InsertResult {
     inserted: number;
     failed: number;
     errors: Array<{ node: CanonicalNode; error: string }>;
   }
   ```

3. Implement insertCanonicalNodes():
   ```typescript
   export async function insertCanonicalNodes(
     db: Database,
     nodes: CanonicalNode[],
     options?: { transaction?: boolean }
   ): Promise<InsertResult>
   ```

   Implementation:
   - Start transaction if options.transaction !== false (default true)
   - For each node:
     a. Convert to SQL record via toSQLRecord(node) - returns snake_case keys
     b. Build INSERT using buildInsertSQL(record)
     c. Execute INSERT using db.run(sql, params) directly (NOT a run() wrapper)
     d. Store properties directly to node_properties table (don't use storeNodeProperties
        since it expects frontmatter and filters KNOWN_KEYS - we have already-filtered
        node.properties). Use same db.run() pattern:
        ```typescript
        if (node.properties && Object.keys(node.properties).length > 0) {
          for (const [key, value] of Object.entries(node.properties)) {
            const valueType = Array.isArray(value) ? 'array'
              : value === null ? 'null'
              : typeof value;
            const propId = `prop-${node.id}-${key}`;
            db.run(`
              INSERT OR REPLACE INTO node_properties (id, node_id, key, value, value_type)
              VALUES (?, ?, ?, ?, ?)
            `, [propId, node.id, key, JSON.stringify(value), valueType]);
          }
        }
        ```
     e. Track success/failure counts
   - Commit transaction on success, rollback on any failure
   - Return InsertResult

4. Add helper for building parameterized INSERT:
   ```typescript
   function buildInsertSQL(record: Record<string, unknown>): { sql: string; params: unknown[] }
   ```
   - Column order: Use Object.keys(SQL_COLUMN_MAP).map(k => SQL_COLUMN_MAP[k]) for deterministic ordering
   - This matches the order defined in canonical.ts: id, node_type, name, content, ...
   - Generate placeholders: ?, ?, ?, ... (one per column)
   - Return { sql: "INSERT INTO nodes (col1, col2, ...) VALUES (?, ?, ...)", params: [...] }

5. Export all public functions and types.
  </action>
  <verify>
npm run typecheck (zero errors)
File exists: src/etl/database/insertion.ts
  </verify>
  <done>
insertCanonicalNodes() utility created with transaction support, toSQLRecord mapping, direct property insertion
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tests for insertion utility</name>
  <files>src/etl/database/__tests__/insertion.test.ts</files>
  <action>
Create test file for insertion utilities:

1. Test "insertCanonicalNodes inserts single node":
   - Create minimal valid CanonicalNode
   - Call insertCanonicalNodes(db, [node])
   - Verify node exists in database with correct fields
   - Verify result.inserted = 1, result.failed = 0

2. Test "insertCanonicalNodes handles batch insertion":
   - Create array of 5 CanonicalNodes
   - Insert with transaction: true
   - Verify all 5 exist in database
   - Verify result.inserted = 5

3. Test "insertCanonicalNodes serializes tags as JSON":
   - Create node with tags: ['tag1', 'tag2']
   - Insert and query back
   - Verify tags column contains '["tag1","tag2"]'

4. Test "insertCanonicalNodes stores properties via EAV":
   - Create node with properties: { custom_key: 'value' }
   - Insert
   - Query node_properties table for node_id
   - Verify key='custom_key', value='"value"' (JSON-stringified) exists

5. Test "insertCanonicalNodes rolls back on error":
   - Insert first node successfully
   - Second node with duplicate id (should fail)
   - Verify first node NOT in database (rollback)
   - Verify result.failed > 0

Use test database setup patterns from existing tests.
  </action>
  <verify>
npm run test -- insertion --run (all tests pass)
  </verify>
  <done>
Test coverage for single insert, batch, tags serialization, properties EAV, and rollback
  </done>
</task>

<task type="auto">
  <name>Task 3: Create window.isometryETL bridge module</name>
  <files>src/etl/bridge/window-export.ts, src/types/global.d.ts</files>
  <action>
1. Extend Window interface in src/types/global.d.ts:
   ```typescript
   interface IsometryETL {
     importFile(
       filename: string,
       content: string | ArrayBuffer,
       options?: { format?: string }
     ): Promise<{ success: boolean; nodeCount: number; errors?: string[] }>;

     getDatabase(): Database | null;
   }

   declare global {
     interface Window {
       isometryETL?: IsometryETL;
     }
   }
   ```

2. Create src/etl/bridge/window-export.ts:
   ```typescript
   import { ImportCoordinator } from '../coordinator/ImportCoordinator';
   import { insertCanonicalNodes } from '../database/insertion';
   import type { Database } from 'sql.js';

   let coordinator: ImportCoordinator | null = null;
   let db: Database | null = null;

   /**
    * Initialize the ETL bridge and expose window.isometryETL API.
    *
    * Call this from SQLiteProvider (after database is ready) or App.tsx
    * when the sql.js database has been initialized.
    *
    * @param database - Initialized sql.js Database instance
    */
   export function initializeETLBridge(database: Database): void {
     db = database;
     coordinator = new ImportCoordinator();

     window.isometryETL = {
       async importFile(filename, content, options) {
         if (!coordinator || !db) {
           return { success: false, nodeCount: 0, errors: ['ETL not initialized'] };
         }

         try {
           // Use coordinator's detectFormat (not duplicate function)
           const format = options?.format || coordinator.detectFormat(filename);

           // Import via coordinator - returns CanonicalNode[]
           const contentStr = typeof content === 'string'
             ? content
             : new TextDecoder().decode(content);
           const nodes = await coordinator.importFile({
             filename,
             content: contentStr,
           });

           // Insert into database
           const result = await insertCanonicalNodes(db, nodes);

           return {
             success: result.failed === 0,
             nodeCount: result.inserted,
             errors: result.errors.map(e => e.error)
           };
         } catch (error) {
           return {
             success: false,
             nodeCount: 0,
             errors: [error instanceof Error ? error.message : String(error)]
           };
         }
       },

       getDatabase() {
         return db;
       }
     };
   }
   ```

   Key points:
   - Uses coordinator.detectFormat() instead of creating duplicate detectFormat() function
   - initializeETLBridge should be called from SQLiteProvider or App.tsx when database ready

3. Export initializeETLBridge from src/etl/index.ts (create if needed).
  </action>
  <verify>
npm run typecheck (zero errors)
File exists: src/etl/bridge/window-export.ts
File contains: window.isometryETL
grep "coordinator.detectFormat" src/etl/bridge/window-export.ts (confirms using coordinator's method)
  </verify>
  <done>
window.isometryETL.importFile() API created with coordinator delegation and database insertion
  </done>
</task>

</tasks>

<verification>
1. Run typecheck: `npm run typecheck`
2. Run tests: `npm run test -- insertion --run`
3. Verify window API: Check that initializeETLBridge can be called without errors
4. Integration check: Verify ImportCoordinator.importFile returns CanonicalNode[]
</verification>

<success_criteria>
- insertCanonicalNodes() inserts CanonicalNode arrays with proper mapping
- Tags serialized as JSON, properties stored via direct EAV insertion
- Transaction rollback on failure
- window.isometryETL.importFile() exposed for Swift bridge
- Uses coordinator.detectFormat() instead of duplicate function
- All tests pass, zero TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/70-integration/70-01-SUMMARY.md`
</output>
