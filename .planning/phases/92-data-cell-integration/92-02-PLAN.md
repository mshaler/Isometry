---
phase: 92-data-cell-integration
plan: 02
type: execute
wave: 2
depends_on: ["92-01"]
files_modified:
  - src/d3/grid-rendering/DataCellRenderer.ts
  - src/services/supergrid/CellDataService.ts
  - src/hooks/useDataCellRenderer.ts
  - src/components/supergrid/SuperGrid.tsx
autonomous: true

must_haves:
  truths:
    - "Density level affects cell rendering (counts vs card chips)"
    - "Dense mode shows count badges instead of individual cards"
    - "Leaf mode shows individual card text"
  artifacts:
    - path: "src/d3/grid-rendering/DataCellRenderer.ts"
      provides: "Density-aware cell rendering"
      contains: "valueDensity === 'collapsed'"
    - path: "src/services/supergrid/CellDataService.ts"
      provides: "Cell aggregation for dense mode"
      exports: ["aggregateCellsByPosition"]
    - path: "src/hooks/useDataCellRenderer.ts"
      provides: "React hook connecting density state to renderer"
      exports: ["useDataCellRenderer"]
  key_links:
    - from: "src/hooks/useDataCellRenderer.ts"
      to: "src/d3/grid-rendering/DataCellRenderer.ts"
      via: "useEffect for rendering"
      pattern: "renderer\\.render"
    - from: "src/d3/grid-rendering/DataCellRenderer.ts"
      to: "src/types/density-control.ts"
      via: "JanusDensityState import"
      pattern: "JanusDensityState"
    - from: "src/components/supergrid/SuperGrid.tsx"
      to: "src/hooks/useDataCellRenderer.ts"
      via: "hook integration"
      pattern: "useDataCellRenderer"
---

<objective>
Add density-aware rendering to data cells (CELL-03)

Purpose: Implement the Janus density model for data cells - when valueDensity is 'leaf', show individual card text; when 'collapsed', aggregate cells at the same position and show count badges (chips).

Output: Updated DataCellRenderer with density modes, cell aggregation in CellDataService, and useDataCellRenderer hook for React integration.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/92-data-cell-integration/92-RESEARCH.md
@.planning/phases/92-data-cell-integration/92-01-SUMMARY.md

# Key existing files to reference
@src/types/density-control.ts
@src/d3/SuperDensityRenderer/RenderModes.ts
@src/contexts/SuperGridContext.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add cell aggregation to CellDataService</name>
  <files>src/services/supergrid/CellDataService.ts</files>
  <action>
Extend CellDataService to support cell aggregation for dense mode.

Add new function:
```typescript
/**
 * Aggregate cells at the same (logicalX, logicalY) position
 * Used when valueDensity === 'collapsed'
 */
export function aggregateCellsByPosition(cells: DataCellData[]): DataCellData[] {
  // Group by position key
  const grouped = d3.group(cells, d => `${d.logicalX},${d.logicalY}`);

  // Transform each group into a single aggregated cell
  return Array.from(grouped.values()).map(group => ({
    ...group[0],  // Use first cell as template
    id: `agg-${group[0].logicalX}-${group[0].logicalY}`,
    aggregationCount: group.length,
    value: `${group.length}`,  // Show count as value for badge display
    sourceNodes: group.map(c => c.node),  // Keep references for drill-down
  }));
}
```

Also extend DataCellData type locally or in src/types/grid.ts to include:
- `aggregationCount?: number` - number of cards aggregated (1 for single cards)
- `sourceNodes?: Node[]` - all nodes aggregated into this cell

The aggregation function should use d3.group() (import from 'd3').
  </action>
  <verify>npm run check:types passes; aggregateCellsByPosition is exported</verify>
  <done>CellDataService aggregates cells by position for dense mode with count and sourceNodes</done>
</task>

<task type="auto">
  <name>Task 2: Add density-aware rendering to DataCellRenderer</name>
  <files>src/d3/grid-rendering/DataCellRenderer.ts</files>
  <action>
Extend DataCellRenderer to support density-based rendering.

Modify the render method to accept JanusDensityState and switch rendering mode:
```typescript
render(
  container: d3.Selection<SVGGElement, unknown, null, undefined>,
  cells: DataCellData[],
  options: {
    onCellClick?: (node: Node) => void,
    densityState?: JanusDensityState
  }
): void {
  const isCollapsed = options.densityState?.valueDensity === 'collapsed';

  // Aggregate if in collapsed mode
  const displayCells = isCollapsed
    ? aggregateCellsByPosition(cells)
    : cells;

  // D3 data binding
  const cellGroups = container
    .selectAll('.data-cell')
    .data(displayCells, d => d.id)
    .join('g')
    .attr('class', 'data-cell');

  // Render based on mode
  if (isCollapsed) {
    this.renderCollapsedCells(cellGroups);  // Circles with count badges
  } else {
    this.renderLeafCells(cellGroups);  // Rectangles with text
  }
}

private renderLeafCells(cellGroups: Selection): void {
  // Existing rect + text rendering (white bg, card text)
}

private renderCollapsedCells(cellGroups: Selection): void {
  // Circle + count text (indigo chip style per RenderModes.ts)
  // Circle: r=12, fill='#e0e7ff', stroke='#6366f1'
  // Text: font-size=10px, fill='#4338ca', centered
}
```

Import JanusDensityState from '@/types/density-control'.
Import aggregateCellsByPosition from CellDataService.

Follow the visual patterns from RenderModes.ts (matrix mode rendering).
  </action>
  <verify>npm run check:types passes; DataCellRenderer switches between leaf/collapsed rendering</verify>
  <done>DataCellRenderer shows individual cards (leaf) or count badges (collapsed) based on JanusDensityState</done>
</task>

<task type="auto">
  <name>Task 3: Create useDataCellRenderer hook</name>
  <files>src/hooks/useDataCellRenderer.ts</files>
  <action>
Create a React hook that manages DataCellRenderer lifecycle and connects to density state.

```typescript
import { useRef, useEffect, useCallback } from 'react';
import * as d3 from 'd3';
import { DataCellRenderer } from '@/d3/grid-rendering/DataCellRenderer';
import { createCoordinateSystem } from '@/utils/coordinate-system/coordinate-system';
import type { DataCellData } from '@/types/grid';
import type { JanusDensityState } from '@/types/density-control';
import type { Node } from '@/types/node';

export interface UseDataCellRendererOptions {
  cellWidth?: number;
  cellHeight?: number;
  headerOffsetX?: number;
  headerOffsetY?: number;
}

export function useDataCellRenderer(
  containerRef: React.RefObject<SVGSVGElement>,
  cells: DataCellData[],
  densityState: JanusDensityState,
  onCellClick?: (node: Node) => void,
  options: UseDataCellRendererOptions = {}
) {
  const rendererRef = useRef<DataCellRenderer | null>(null);

  useEffect(() => {
    if (!containerRef.current) return;

    const coordinateSystem = createCoordinateSystem(
      'anchor',
      options.cellWidth ?? 120,
      options.cellHeight ?? 60,
      {
        headerOffsetX: options.headerOffsetX ?? 0,  // Headers handled by container
        headerOffsetY: options.headerOffsetY ?? 0,
      }
    );

    // Create renderer if not exists
    if (!rendererRef.current) {
      rendererRef.current = new DataCellRenderer(coordinateSystem);
    }

    // Select or create data-cells group
    const svg = d3.select(containerRef.current);
    let container = svg.select<SVGGElement>('.data-cells-group');
    if (container.empty()) {
      container = svg.append('g').attr('class', 'data-cells-group');
    }

    // Render cells
    rendererRef.current.render(container, cells, {
      onCellClick,
      densityState,
    });

    return () => {
      // Cleanup on unmount - remove all cells
      container.selectAll('.data-cell').remove();
    };
  }, [containerRef, cells, densityState, onCellClick, options]);

  return {
    renderer: rendererRef.current,
  };
}
```

The hook:
1. Creates coordinate system from options
2. Instantiates DataCellRenderer once
3. Re-renders when cells or densityState changes
4. Cleans up on unmount
  </action>
  <verify>npm run check:types passes; useDataCellRenderer is exported</verify>
  <done>useDataCellRenderer hook manages renderer lifecycle and responds to density state changes</done>
</task>

<task type="auto">
  <name>Task 4: Integrate useDataCellRenderer hook in SuperGrid</name>
  <files>src/components/supergrid/SuperGrid.tsx</files>
  <action>
Wire the useDataCellRenderer hook to SuperGrid component to enable density-aware data cell rendering.

1. Import the hook:
```typescript
import { useDataCellRenderer } from '@/hooks/useDataCellRenderer';
import { useSuperGridContext } from '@/contexts/SuperGridContext';
```

2. Get density state from context:
```typescript
const { densityState } = useSuperGridContext();
```

3. Create ref for data grid SVG:
```typescript
const dataGridRef = useRef<SVGSVGElement>(null);
```

4. Use the hook to render data cells:
```typescript
useDataCellRenderer(
  dataGridRef,
  cells,  // DataCellData[] from SQL query
  densityState,
  handleCellClick,  // existing click handler
  {
    cellWidth: coordinateSystem.cellWidth,
    cellHeight: coordinateSystem.cellHeight,
  }
);
```

5. Pass dataGridRef to SuperGridScrollContainer's data-grid slot.

This wiring ensures:
- Density mode changes trigger re-render
- Hook manages D3 lifecycle (setup/cleanup)
- Cell positions use the same coordinate system as headers

Note: Do NOT add selection state here - that's handled in Plan 92-03.
  </action>
  <verify>npm run check:types passes; SuperGrid imports and calls useDataCellRenderer</verify>
  <done>SuperGrid uses useDataCellRenderer hook for density-aware data cell rendering</done>
</task>

</tasks>

<verification>
1. `npm run check:types` passes with zero TypeScript errors
2. aggregateCellsByPosition correctly groups cells by position
3. DataCellRenderer renders circles for collapsed mode, rectangles for leaf mode
4. useDataCellRenderer re-renders when densityState.valueDensity changes
5. Count badges display the correct aggregation count
</verification>

<success_criteria>
- Dense mode (valueDensity='collapsed'): cells at same position show count badge (circle with number)
- Sparse mode (valueDensity='leaf'): cells show individual card text (rectangle with text)
- Aggregated cells preserve sourceNodes array for future drill-down capability
- Hook re-renders on density state changes
</success_criteria>

<output>
After completion, create `.planning/phases/92-data-cell-integration/92-02-SUMMARY.md`
</output>
