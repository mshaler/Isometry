---
phase: 92-data-cell-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/d3/grid-rendering/DataCellRenderer.ts
  - src/services/supergrid/CellDataService.ts
  - src/components/supergrid/SuperGridScrollContainer.tsx
autonomous: true

must_haves:
  truths:
    - "Data cells render at correct positions aligned with leaf headers"
    - "Headers stay fixed while data area scrolls"
    - "Scroll container uses CSS Grid with sticky positioning"
  artifacts:
    - path: "src/d3/grid-rendering/DataCellRenderer.ts"
      provides: "D3 data cell rendering with coordinate mapping"
      exports: ["DataCellRenderer", "renderDataCellsToContainer"]
    - path: "src/services/supergrid/CellDataService.ts"
      provides: "Cell data transformation service"
      exports: ["CellDataService", "transformToCellData"]
    - path: "src/components/supergrid/SuperGridScrollContainer.tsx"
      provides: "CSS Grid scroll container with sticky headers"
      exports: ["SuperGridScrollContainer"]
  key_links:
    - from: "src/components/supergrid/SuperGridScrollContainer.tsx"
      to: "src/d3/grid-rendering/DataCellRenderer.ts"
      via: "useEffect for D3 rendering"
      pattern: "DataCellRenderer|renderDataCells"
    - from: "src/d3/grid-rendering/DataCellRenderer.ts"
      to: "src/utils/coordinate-system/coordinate-system.ts"
      via: "logicalToScreen for positioning"
      pattern: "coordinateSystem\\.logicalToScreen"
---

<objective>
Create the core data cell rendering infrastructure with CSS Grid scroll container

Purpose: Establish the foundation for CELL-01 (correct positioning) and CELL-02 (scroll coordination) by creating a DataCellRenderer service that uses the existing coordinate system and a SuperGridScrollContainer component that implements CSS sticky positioning for headers.

Output: Three new files - DataCellRenderer for D3 rendering, CellDataService for data transformation, SuperGridScrollContainer for the layout.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/92-data-cell-integration/92-RESEARCH.md

# Key existing files to reference
@src/utils/coordinate-system/coordinate-system.ts
@src/components/GridBlock4_DataCells.tsx
@src/components/supergrid/__tests__/SuperGridScroll.test.tsx
@src/types/grid.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CellDataService for data transformation</name>
  <files>src/services/supergrid/CellDataService.ts</files>
  <action>
Create a CellDataService class that transforms SQLite query results into DataCellData arrays for D3 rendering.

The service should:
1. Accept raw SQL result rows and a PAFVProjection configuration
2. Transform each row to DataCellData format with:
   - `id`: unique cell identifier (node.id)
   - `node`: the full node object
   - `logicalX`: column index based on x-axis facet value
   - `logicalY`: row index based on y-axis facet value
   - `value`: display text (node.name)
3. Build value-to-index maps for x-axis and y-axis facets from the data

Export:
- `CellDataService` class with `transformToCellData(rows, projection)` method
- `transformToCellData()` standalone function for simple usage

Reference existing DataCellData type from src/types/grid.ts. Follow the pattern established in src/components/GridBlock4_DataCells.tsx for data structure expectations.

Do NOT add aggregation logic here - that will be handled in Plan 92-02 for density modes.
  </action>
  <verify>npm run check:types passes; CellDataService is exported from the file</verify>
  <done>CellDataService transforms rows to DataCellData with correct logicalX/logicalY mapping</done>
</task>

<task type="auto">
  <name>Task 2: Create DataCellRenderer with coordinate system integration</name>
  <files>src/d3/grid-rendering/DataCellRenderer.ts</files>
  <action>
Create a DataCellRenderer service that renders data cells using D3, positioning them with the coordinate system.

The renderer should:
1. Accept a D3 container selection, cells array, and coordinate system
2. Use the existing createCoordinateSystem() from src/utils/coordinate-system/coordinate-system.ts for position calculations
3. Render cells using the D3 .join() pattern (enter/update/exit) with key function `d => d.id`
4. Position each cell using `coordinateSystem.logicalToScreen(d.logicalX, d.logicalY)`
5. Include hover effects and click handler callback (similar to GridBlock4_DataCells.tsx)

Structure:
```typescript
export class DataCellRenderer {
  private coordinateSystem: D3CoordinateSystem;

  constructor(coordinateSystem: D3CoordinateSystem) { ... }

  render(
    container: d3.Selection<SVGGElement, unknown, null, undefined>,
    cells: DataCellData[],
    options: { onCellClick?: (node: Node) => void }
  ): void { ... }

  updatePositions(cells: DataCellData[]): void { ... }
}

export function renderDataCellsToContainer(...): void { ... }
```

Use the existing D3CoordinateSystem and DataCellData types from src/types/grid.ts.

For cell visuals: white background rect with gray border, text clipped to cell width, smooth transitions on position change.
  </action>
  <verify>npm run check:types passes; DataCellRenderer and renderDataCellsToContainer are exported</verify>
  <done>DataCellRenderer positions cells using coordinateSystem.logicalToScreen and renders with D3 .join() pattern</done>
</task>

<task type="auto">
  <name>Task 3: Create SuperGridScrollContainer with CSS sticky headers</name>
  <files>src/components/supergrid/SuperGridScrollContainer.tsx</files>
  <action>
Create the SuperGridScrollContainer React component that implements CSS Grid layout with sticky headers per SCROLL-01 through SCROLL-05 requirements.

The layout structure (from SuperGridScroll.test.tsx):
```tsx
<div className="supergrid" style={{
  display: 'grid',
  gridTemplateColumns: 'auto 1fr',  // Row headers | Data grid
  gridTemplateRows: 'auto 1fr',     // Column headers | Data grid
  overflow: 'auto',                 // Single scroll container (SCROLL-05)
  width: '100%',
  height: '100%',
  position: 'relative',
}}>
  {/* Corner cell - sticky at top-left, z-index: 3 */}
  <div className="supergrid__corner" style={{
    position: 'sticky', top: 0, left: 0, zIndex: 3
  }}>
    {cornerContent}
  </div>

  {/* Column headers - sticky at top, z-index: 2 */}
  <div className="supergrid__column-headers" style={{
    position: 'sticky', top: 0, zIndex: 2
  }}>
    <svg ref={columnHeaderRef} ... />
  </div>

  {/* Row headers - sticky at left, z-index: 1 */}
  <div className="supergrid__row-headers" style={{
    position: 'sticky', left: 0, zIndex: 1, gridRow: 2
  }}>
    <svg ref={rowHeaderRef} ... />
  </div>

  {/* Data grid - scrollable content, no sticky */}
  <div className="supergrid__data-grid" style={{
    gridRow: 2, gridColumn: 2, transformOrigin: '0 0'
  }}>
    <svg ref={dataGridRef} ... />
  </div>
</div>
```

Props:
- columnHeaderRef: RefObject<SVGSVGElement>
- rowHeaderRef: RefObject<SVGSVGElement>
- dataGridRef: RefObject<SVGSVGElement>
- cornerContent?: ReactNode
- headerWidth?: number (default 150)
- headerHeight?: number (default 40)
- contentWidth: number
- contentHeight: number

Key requirements:
- SCROLL-01: Headers remain fixed during content scroll (CSS sticky)
- SCROLL-02: Upper-left corner pinned at (0,0)
- SCROLL-04: transformOrigin: '0 0' on data grid for upper-left zoom anchor
- SCROLL-05: Single scroll container (no nested overflow: auto)
  </action>
  <verify>npm run check:types passes; SuperGridScrollContainer renders with CSS Grid and sticky positioning</verify>
  <done>SuperGridScrollContainer implements CSS Grid with sticky headers per SCROLL-01 through SCROLL-05</done>
</task>

</tasks>

<verification>
1. `npm run check:types` passes with zero TypeScript errors
2. All three new files exist and export their main types/functions
3. DataCellRenderer uses coordinateSystem.logicalToScreen for positioning
4. SuperGridScrollContainer uses CSS Grid with sticky positioning per test patterns
5. No duplicate scroll containers (only the main container has overflow: auto)
</verification>

<success_criteria>
- CellDataService transforms query results to DataCellData with correct logical coordinates
- DataCellRenderer renders cells at positions computed by coordinate system
- SuperGridScrollContainer implements CSS sticky header pattern from SuperGridScroll.test.tsx
- All files pass TypeScript compilation
</success_criteria>

<output>
After completion, create `.planning/phases/92-data-cell-integration/92-01-SUMMARY.md`
</output>
