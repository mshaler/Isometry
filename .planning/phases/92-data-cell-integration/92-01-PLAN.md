---
phase: 92-data-cell-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/d3/grid-rendering/DataCellRenderer.ts
  - src/services/supergrid/CellDataService.ts
  - src/components/supergrid/SuperGridScrollContainer.tsx
autonomous: false

must_haves:
  truths:
    - "Data cells render at correct positions aligned with leaf headers"
    - "Headers remain visible during data scroll"
    - "User can scroll 1000+ rows without headers disappearing"
  artifacts:
    - path: "src/d3/grid-rendering/DataCellRenderer.ts"
      provides: "D3 data cell rendering with coordinate mapping"
      exports: ["DataCellRenderer", "renderDataCellsToContainer"]
    - path: "src/services/supergrid/CellDataService.ts"
      provides: "Cell data transformation service"
      exports: ["CellDataService", "transformToCellData"]
    - path: "src/components/supergrid/SuperGridScrollContainer.tsx"
      provides: "CSS Grid scroll container with sticky headers"
      exports: ["SuperGridScrollContainer"]
  key_links:
    - from: "src/components/supergrid/SuperGridScrollContainer.tsx"
      to: "src/d3/grid-rendering/DataCellRenderer.ts"
      via: "useEffect for D3 rendering"
      pattern: "DataCellRenderer|renderDataCells"
    - from: "src/d3/grid-rendering/DataCellRenderer.ts"
      to: "src/utils/coordinate-system/coordinate-system.ts"
      via: "logicalToScreen for positioning"
      pattern: "coordinateSystem\\.logicalToScreen"
---

<objective>
Create the core data cell rendering infrastructure with CSS Grid scroll container

Purpose: Establish the foundation for CELL-01 (correct positioning) and CELL-02 (scroll coordination) by creating a DataCellRenderer service that uses the existing coordinate system and a SuperGridScrollContainer component that implements CSS sticky positioning for headers.

Output: Three new files - DataCellRenderer for D3 rendering, CellDataService for data transformation, SuperGridScrollContainer for the layout.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/92-data-cell-integration/92-RESEARCH.md

# Key existing files to reference
@src/utils/coordinate-system/coordinate-system.ts
@src/components/GridBlock4_DataCells.tsx
@src/components/supergrid/__tests__/SuperGridScroll.test.tsx
@src/types/grid.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CellDataService for data transformation</name>
  <files>src/services/supergrid/CellDataService.ts</files>
  <action>
Create a CellDataService class that transforms SQLite query results into DataCellData arrays for D3 rendering.

The service should:
1. Accept raw SQL result rows and a PAFVProjection configuration
2. Transform each row to DataCellData format with:
   - `id`: unique cell identifier (node.id)
   - `node`: the full node object
   - `logicalX`: column index based on x-axis facet value
   - `logicalY`: row index based on y-axis facet value
   - `value`: display text (node.name)
3. Build value-to-index maps for x-axis and y-axis facets from the data

Export:
- `CellDataService` class with `transformToCellData(rows, projection)` method
- `transformToCellData()` standalone function for simple usage

Reference existing DataCellData type from src/types/grid.ts. Follow the pattern established in src/components/GridBlock4_DataCells.tsx for data structure expectations.

Do NOT add aggregation logic here - that will be handled in Plan 92-02 for density modes.
  </action>
  <verify>npm run check:types passes; CellDataService is exported from the file</verify>
  <done>CellDataService transforms rows to DataCellData with correct logicalX/logicalY mapping</done>
</task>

<task type="auto">
  <name>Task 2: Create DataCellRenderer with coordinate system integration</name>
  <files>src/d3/grid-rendering/DataCellRenderer.ts</files>
  <action>
Create a DataCellRenderer service that renders data cells using D3, positioning them with the coordinate system.

The renderer should:
1. Accept a D3 container selection, cells array, and coordinate system
2. Use the existing createCoordinateSystem() from src/utils/coordinate-system/coordinate-system.ts for position calculations
3. Render cells using the D3 .join() pattern (enter/update/exit) with key function `d => d.id`
4. Position each cell using `coordinateSystem.logicalToScreen(d.logicalX, d.logicalY)`
5. Include hover effects and click handler callback (similar to GridBlock4_DataCells.tsx)

Structure:
```typescript
export class DataCellRenderer {
  private coordinateSystem: D3CoordinateSystem;

  constructor(coordinateSystem: D3CoordinateSystem) { ... }

  render(
    container: d3.Selection<SVGGElement, unknown, null, undefined>,
    cells: DataCellData[],
    options: { onCellClick?: (node: Node) => void }
  ): void { ... }

  updatePositions(cells: DataCellData[]): void { ... }
}

export function renderDataCellsToContainer(...): void { ... }
```

Use the existing D3CoordinateSystem and DataCellData types from src/types/grid.ts.

For cell visuals: white background rect with gray border, text clipped to cell width, smooth transitions on position change.
  </action>
  <verify>npm run check:types passes; DataCellRenderer and renderDataCellsToContainer are exported</verify>
  <done>DataCellRenderer positions cells using coordinateSystem.logicalToScreen and renders with D3 .join() pattern</done>
</task>

<task type="auto">
  <name>Task 3: Create SuperGridScrollContainer with CSS sticky headers</name>
  <files>src/components/supergrid/SuperGridScrollContainer.tsx</files>
  <action>
Create the SuperGridScrollContainer React component that implements CSS Grid layout with sticky headers per SCROLL-01 through SCROLL-05 requirements.

The layout structure (from SuperGridScroll.test.tsx):
```tsx
<div className="supergrid" style={{
  display: 'grid',
  gridTemplateColumns: 'auto 1fr',  // Row headers | Data grid
  gridTemplateRows: 'auto 1fr',     // Column headers | Data grid
  overflow: 'auto',                 // Single scroll container (SCROLL-05)
  width: '100%',
  height: '100%',
  position: 'relative',
}}>
  {/* Corner cell - sticky at top-left, z-index: 3 */}
  <div className="supergrid__corner" style={{
    position: 'sticky', top: 0, left: 0, zIndex: 3
  }}>
    {cornerContent}
  </div>

  {/* Column headers - sticky at top, z-index: 2 */}
  <div className="supergrid__column-headers" style={{
    position: 'sticky', top: 0, zIndex: 2
  }}>
    <svg ref={columnHeaderRef} ... />
  </div>

  {/* Row headers - sticky at left, z-index: 1 */}
  <div className="supergrid__row-headers" style={{
    position: 'sticky', left: 0, zIndex: 1, gridRow: 2
  }}>
    <svg ref={rowHeaderRef} ... />
  </div>

  {/* Data grid - scrollable content, no sticky */}
  <div className="supergrid__data-grid" style={{
    gridRow: 2, gridColumn: 2, transformOrigin: '0 0'
  }}>
    <svg ref={dataGridRef} ... />
  </div>
</div>
```

Props:
- columnHeaderRef: RefObject<SVGSVGElement>
- rowHeaderRef: RefObject<SVGSVGElement>
- dataGridRef: RefObject<SVGSVGElement>
- cornerContent?: ReactNode
- headerWidth?: number (default 150)
- headerHeight?: number (default 40)
- contentWidth: number
- contentHeight: number

Key requirements:
- SCROLL-01: Headers remain fixed during content scroll (CSS sticky)
- SCROLL-02: Upper-left corner pinned at (0,0)
- SCROLL-04: transformOrigin: '0 0' on data grid for upper-left zoom anchor
- SCROLL-05: Single scroll container (no nested overflow: auto)
  </action>
  <verify>npm run check:types passes; SuperGridScrollContainer renders with CSS Grid and sticky positioning</verify>
  <done>SuperGridScrollContainer implements CSS Grid with sticky headers per SCROLL-01 through SCROLL-05</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 4: Verify scroll coordination (CELL-02)</name>
  <what-built>SuperGridScrollContainer with CSS sticky headers and D3 data cell rendering</what-built>
  <how-to-verify>
    1. Load SuperGrid with sample data (20+ rows, 10+ columns)
    2. Scroll the data area vertically - column headers should stay fixed at top
    3. Scroll the data area horizontally - row headers should stay fixed at left
    4. Scroll diagonally - both row and column headers remain visible
    5. Corner cell should remain pinned at (0,0) during all scroll directions
    6. Data cells should align correctly with their corresponding headers at all scroll positions
  </how-to-verify>
  <resume-signal>Type "approved" or describe any scroll/alignment issues</resume-signal>
</task>

</tasks>

<verification>
1. `npm run check:types` passes with zero TypeScript errors
2. All three new files exist and export their main types/functions
3. DataCellRenderer uses coordinateSystem.logicalToScreen for positioning
4. SuperGridScrollContainer uses CSS Grid with sticky positioning per test patterns
5. No duplicate scroll containers (only the main container has overflow: auto)
</verification>

<success_criteria>
- CellDataService transforms query results to DataCellData with correct logical coordinates
- DataCellRenderer renders cells at positions computed by coordinate system
- SuperGridScrollContainer implements CSS sticky header pattern from SuperGridScroll.test.tsx
- All files pass TypeScript compilation
</success_criteria>

<output>
After completion, create `.planning/phases/92-data-cell-integration/92-01-SUMMARY.md`
</output>
