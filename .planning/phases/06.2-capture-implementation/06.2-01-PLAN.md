---
phase: 06.2-capture-implementation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [
  "native/Sources/Isometry/Views/Notebook/NotebookCaptureView.swift",
  "native/Sources/Isometry/Views/Notebook/MarkdownEditor.swift",
  "native/Sources/Isometry/Views/Notebook/MarkdownPreview.swift",
  "native/Sources/Isometry/Models/NotebookEditorModel.swift"
]
autonomous: true

must_haves:
  truths:
    - "User can type markdown in native text editor"
    - "User can see live preview of formatted markdown"
    - "User can save markdown with auto-save functionality"
    - "User can switch between edit and preview modes"
  artifacts:
    - path: "native/Sources/Isometry/Views/Notebook/MarkdownEditor.swift"
      provides: "NSTextView/UITextView wrapper with markdown syntax highlighting"
      min_lines: 100
    - path: "native/Sources/Isometry/Views/Notebook/MarkdownPreview.swift"
      provides: "Native markdown renderer using AttributedString"
      min_lines: 50
    - path: "native/Sources/Isometry/Models/NotebookEditorModel.swift"
      provides: "ObservableObject managing editor state and auto-save"
      exports: ["NotebookEditorModel", "MarkdownEditorMode"]
  key_links:
    - from: "native/Sources/Isometry/Views/Notebook/NotebookCaptureView.swift"
      to: "NotebookEditorModel"
      via: "@StateObject editor model binding"
      pattern: "@StateObject.*NotebookEditorModel"
    - from: "native/Sources/Isometry/Models/NotebookEditorModel.swift"
      to: "IsometryDatabase.updateNotebookCard"
      via: "auto-save timer trigger"
      pattern: "updateNotebookCard.*timer"
---

<objective>
Replace React markdown editor with native NSTextView/UITextView providing superior text editing performance and platform-native keyboard shortcuts

Purpose: Deliver native text editing experience that matches platform conventions while supporting real-time markdown preview and auto-save functionality
Output: Native markdown editor integrated into NotebookCaptureView with live preview and data persistence
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06.1-foundation-layout/06.1-01-SUMMARY.md
@.planning/phases/06.1-foundation-layout/06.1-02-SUMMARY.md
@native/Sources/Isometry/Models/NotebookCard.swift
@native/Sources/Isometry/Views/Notebook/NotebookCaptureView.swift
@src/components/notebook/CaptureComponent.tsx
</context>

<tasks>

<task type="auto">
  <name>Create Native Markdown Editor Component</name>
  <files>native/Sources/Isometry/Views/Notebook/MarkdownEditor.swift</files>
  <action>
    Create SwiftUI wrapper around NSTextView (macOS) / UITextView (iOS) for markdown editing:

    1. Implement MarkdownEditor struct with UIViewRepresentable/NSViewRepresentable
    2. Configure text view with:
       - Monospace font for markdown syntax visibility
       - Line number gutter (optional, user preference)
       - Platform-appropriate keyboard shortcuts (Cmd+B for bold, etc.)
       - Real-time typing attributes for basic syntax highlighting
    3. Implement text storage delegate for:
       - Basic markdown syntax highlighting (headers, bold, italic, code)
       - Auto-indentation for lists and code blocks
       - Bracket/quote auto-completion
    4. Add SwiftUI binding integration:
       - @Binding for text content with proper update cycles
       - Coordinator pattern for delegate handling
       - Respect SwiftUI update lifecycle
    5. Platform-specific optimizations:
       - macOS: Use NSTextView with full undo/redo, ruler support
       - iOS: Use UITextView with custom input accessory for markdown toolbar

    Pattern: Follow existing SwiftUI+UIKit integration patterns in codebase.
    Performance: Target 60fps typing with syntax highlighting enabled.
  </action>
  <verify>Build compiles without errors, text editor renders in NotebookCaptureView placeholder</verify>
  <done>MarkdownEditor renders native text view with basic syntax highlighting and SwiftUI binding integration</done>
</task>

<task type="auto">
  <name>Create Native Markdown Preview Component</name>
  <files>native/Sources/Isometry/Views/Notebook/MarkdownPreview.swift</files>
  <action>
    Create native markdown preview using AttributedString and SwiftUI Text:

    1. Implement MarkdownPreview struct with:
       - AttributedString conversion from markdown text
       - Support for headers, bold, italic, code blocks, lists
       - Links rendered as tappable with proper styling
       - Code syntax highlighting using existing patterns
    2. Configure rendering with:
       - Theme-aware colors matching app design system
       - Proper font sizing hierarchy for headers
       - Code block background styling and padding
       - Link styling with hover/tap states
    3. Performance optimizations:
       - Debounced rendering (250ms delay) to avoid excessive updates
       - AttributedString caching for repeated renders
       - Lazy rendering for long documents
    4. Add scroll sync support:
       - ScrollViewReader for programmatic positioning
       - Coordinate with editor scroll position
    5. Platform-specific features:
       - macOS: Trackpad zoom support, context menus
       - iOS: Text selection, share sheet integration

    Pattern: Use SwiftUI native text rendering, avoid WebView for performance.
    Reference: React prototype MDEditor preview pane styling and features.
  </action>
  <verify>Preview renders properly formatted markdown with theme styling</verify>
  <done>MarkdownPreview shows formatted text with proper typography, links, and code highlighting</done>
</task>

<task type="auto">
  <name>Create Editor State Management Model</name>
  <files>native/Sources/Isometry/Models/NotebookEditorModel.swift</files>
  <action>
    Create ObservableObject for editor state management and auto-save:

    1. Define NotebookEditorModel with:
       - @Published content: String (current markdown text)
       - @Published isDirty: Bool (unsaved changes indicator)
       - @Published isSaving: Bool (save operation in progress)
       - @Published mode: MarkdownEditorMode (edit/split/preview)
       - @Published activeCard: NotebookCard? (current editing context)
    2. Implement auto-save system:
       - Timer-based auto-save with 2-second delay (matching React prototype)
       - Debounced save to prevent excessive database writes
       - Save state indicators for user feedback
       - Conflict resolution handling for concurrent edits
    3. Add editor operations:
       - loadCard(NotebookCard) -> loads content and resets dirty state
       - saveNow() -> immediate save bypassing timer
       - updateContent(String) -> updates content and sets dirty state
       - createNewCard() -> initializes blank card
    4. Integrate with existing database:
       - Use IsometryDatabase.updateNotebookCard for persistence
       - Handle database errors gracefully with user feedback
       - Maintain CloudKit sync compatibility
    5. State management best practices:
       - MainActor conformance for UI updates
       - Proper Combine subscription management
       - Memory management for timer cleanup

    Pattern: Follow existing model patterns (NavigationModel, NotebookLayoutModel).
    Integration: Connects editor UI to database layer seamlessly.
  </action>
  <verify>Model compiles and integrates with existing database operations</verify>
  <done>NotebookEditorModel provides complete state management for text editing with auto-save functionality</done>
</task>

<task type="auto">
  <name>Integrate Editor into NotebookCaptureView</name>
  <files>native/Sources/Isometry/Views/Notebook/NotebookCaptureView.swift</files>
  <action>
    Replace placeholder NotebookCaptureView with integrated editor components:

    1. Add state management:
       - @StateObject var editorModel = NotebookEditorModel()
       - @State var showingProperties = false
       - @State var mode: MarkdownEditorMode = .split
    2. Implement layout structure:
       - Header with title, save status, mode picker, minimize button
       - Content area with editor/preview based on selected mode
       - Footer with status indicators and word count
    3. Create mode layouts:
       - Edit mode: MarkdownEditor only, full width
       - Split mode: HStack with MarkdownEditor | MarkdownPreview
       - Preview mode: MarkdownPreview only, full width
    4. Add editor controls:
       - Mode picker (segmented control or buttons)
       - Save button with visual states (dirty, saving, saved)
       - View minimization matching existing shell/preview components
       - Keyboard shortcuts for mode switching (Cmd+1/2/3)
    5. Integrate with existing layout system:
       - Respect NotebookLayoutModel spacing and sizing
       - Maintain card-style appearance matching other components
       - Handle layout transitions smoothly
    6. Add status indicators:
       - Auto-save status with timer countdown
       - Word/character count display
       - Card information (ID, creation date)

    Pattern: Match React CaptureComponent.tsx functionality and layout.
    Theme: Integrate with existing app theme system and colors.
  </action>
  <verify>NotebookCaptureView shows complete editor interface with all modes functional</verify>
  <done>Native markdown editor fully integrated with split/edit/preview modes and auto-save status</done>
</task>

</tasks>

<verification>
1. Text editor responds to typing with syntax highlighting
2. Preview updates in real-time as text changes
3. Auto-save works with visual feedback
4. Mode switching between edit/split/preview functions
5. Editor integrates properly with existing layout system
</verification>

<success_criteria>
1. User can type markdown with native text editing performance
2. Live preview shows formatted content matching text input
3. Auto-save preserves work every 2 seconds with visual indicators
4. Mode switching provides edit/split/preview layouts
5. Editor maintains platform keyboard shortcuts and conventions
</success_criteria>

<output>
After completion, create `.planning/phases/06.2-capture-implementation/06.2-01-SUMMARY.md`
</output>