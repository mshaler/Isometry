---
phase: 67-canonical-schema
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - package-lock.json
  - src/etl/types/canonical.ts
  - src/etl/types/canonical-node.schema.json
  - src/etl/__tests__/canonical.test.ts
autonomous: true

must_haves:
  truths:
    - "zod package is installed as direct dependency"
    - "CanonicalNodeSchema validates nodes matching existing SQL schema"
    - "CanonicalNode type is inferred from Zod schema"
    - "JSON Schema file is generated and validates equivalent to Zod"
    - "SQL_COLUMN_MAP maps all camelCase TypeScript to snake_case SQL"
  artifacts:
    - path: "src/etl/types/canonical.ts"
      provides: "Zod schema, TypeScript type, SQL column mapping"
      exports: ["CanonicalNodeSchema", "CanonicalNode", "SQL_COLUMN_MAP", "toSQLRecord", "fromSQLRecord"]
    - path: "src/etl/types/canonical-node.schema.json"
      provides: "JSON Schema for Swift interoperability"
      exports: []
  key_links:
    - from: "src/etl/types/canonical.ts"
      to: "zod"
      via: "import { z } from 'zod'"
      pattern: "import.*z.*from 'zod'"
---

<objective>
Create the canonical Node schema as the single source of truth for ETL data entering Isometry.

Purpose: All importers (Markdown, Excel, Word, JSON, HTML, CSV) will output CanonicalNode objects. This ensures consistent validation, type safety, and mapping to the existing SQLite schema.

Output: Zod schema with TypeScript type inference, JSON Schema export for Swift, and SQL column mapping utilities.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/milestones/v4.8-etl-consolidation/REQUIREMENTS.md
@etl-consolidation-plan.md

# Existing schema and types to match
@src/db/schema.sql
@src/etl/alto-importer.ts (NodeRecord interface at lines 45-72)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install zod as direct dependency</name>
  <files>package.json, package-lock.json</files>
  <action>
Run `npm install zod` to add as direct dependency.

Expected addition to package.json dependencies:
- "zod": "^3.22.4" (or compatible 3.x)

Zod is currently only a transitive dependency of knip. Adding it directly ensures it's available for production use.
  </action>
  <verify>`npm ls zod` shows direct dependency, not just via knip</verify>
  <done>zod is a direct dependency in package.json</done>
</task>

<task type="auto">
  <name>Task 2: Create canonical schema with Zod</name>
  <files>src/etl/types/canonical.ts</files>
  <action>
Create `src/etl/types/` directory and `canonical.ts` module:

```typescript
/**
 * Canonical Node Schema for Isometry ETL
 *
 * This is the single source of truth for data entering the system.
 * All importers MUST output this format.
 *
 * LATCH Mapping:
 * - L (Location): latitude, longitude, locationName, locationAddress
 * - A (Alphabet): name (primary sort key)
 * - T (Time): createdAt, modifiedAt, dueAt, completedAt, eventStart, eventEnd
 * - C (Category): nodeType, folder, tags, status
 * - H (Hierarchy): priority, importance, sortOrder
 */

import { z } from 'zod';

// ISO 8601 datetime string pattern
const isoDatetime = z.string().datetime().nullable();

export const CanonicalNodeSchema = z.object({
  // Core Identity
  id: z.string().uuid(),
  nodeType: z.string().min(1).default('note'),
  name: z.string().min(1),
  content: z.string().nullable().default(null),
  summary: z.string().nullable().default(null),

  // LATCH: Location
  latitude: z.number().nullable().default(null),
  longitude: z.number().nullable().default(null),
  locationName: z.string().nullable().default(null),
  locationAddress: z.string().nullable().default(null),

  // LATCH: Time (ISO 8601 strings for JSON serialization)
  createdAt: z.string().datetime(),
  modifiedAt: z.string().datetime(),
  dueAt: isoDatetime.default(null),
  completedAt: isoDatetime.default(null),
  eventStart: isoDatetime.default(null),
  eventEnd: isoDatetime.default(null),

  // LATCH: Category
  folder: z.string().nullable().default(null),
  tags: z.array(z.string()).default([]),
  status: z.string().nullable().default(null),

  // LATCH: Hierarchy
  priority: z.number().int().min(0).max(5).default(0),
  importance: z.number().int().min(0).max(5).default(0),
  sortOrder: z.number().int().default(0),

  // Grid positioning (SuperGrid)
  gridX: z.number().default(0),
  gridY: z.number().default(0),

  // Provenance
  source: z.string().nullable().default(null),
  sourceId: z.string().nullable().default(null),
  sourceUrl: z.string().url().nullable().default(null),

  // Lifecycle
  deletedAt: isoDatetime.default(null),
  version: z.number().int().positive().default(1),

  // Extension point for format-specific metadata
  properties: z.record(z.unknown()).default({}),
});

export type CanonicalNode = z.infer<typeof CanonicalNodeSchema>;

/**
 * SQL Column Mapping: camelCase TypeScript -> snake_case SQL
 * Matches the nodes table schema in src/db/schema.sql
 */
export const SQL_COLUMN_MAP: Record<keyof Omit<CanonicalNode, 'properties'>, string> = {
  id: 'id',
  nodeType: 'node_type',
  name: 'name',
  content: 'content',
  summary: 'summary',
  latitude: 'latitude',
  longitude: 'longitude',
  locationName: 'location_name',
  locationAddress: 'location_address',
  createdAt: 'created_at',
  modifiedAt: 'modified_at',
  dueAt: 'due_at',
  completedAt: 'completed_at',
  eventStart: 'event_start',
  eventEnd: 'event_end',
  folder: 'folder',
  tags: 'tags',
  status: 'status',
  priority: 'priority',
  importance: 'importance',
  sortOrder: 'sort_order',
  gridX: 'grid_x',
  gridY: 'grid_y',
  source: 'source',
  sourceId: 'source_id',
  sourceUrl: 'source_url',
  deletedAt: 'deleted_at',
  version: 'version',
};

/**
 * Convert CanonicalNode to SQL-compatible record (snake_case keys)
 */
export function toSQLRecord(node: CanonicalNode): Record<string, unknown> {
  const record: Record<string, unknown> = {};
  for (const [tsKey, sqlKey] of Object.entries(SQL_COLUMN_MAP)) {
    const value = node[tsKey as keyof Omit<CanonicalNode, 'properties'>];
    // Convert tags array to JSON string for SQL storage
    if (tsKey === 'tags') {
      record[sqlKey] = value && Array.isArray(value) && value.length > 0
        ? JSON.stringify(value)
        : null;
    } else {
      record[sqlKey] = value;
    }
  }
  return record;
}

/**
 * Convert SQL record (snake_case keys) to CanonicalNode
 */
export function fromSQLRecord(record: Record<string, unknown>): CanonicalNode {
  const node: Partial<CanonicalNode> = {};

  for (const [tsKey, sqlKey] of Object.entries(SQL_COLUMN_MAP)) {
    const value = record[sqlKey];
    // Parse tags JSON string back to array
    if (tsKey === 'tags') {
      node.tags = value ? JSON.parse(value as string) : [];
    } else {
      (node as Record<string, unknown>)[tsKey] = value;
    }
  }

  // Properties come from node_properties table, not included in basic SQL record
  node.properties = {};

  return CanonicalNodeSchema.parse(node);
}
```

Key points:
- Schema matches existing SQL schema columns exactly
- All fields have sensible defaults for optional data
- tags stored as JSON array in TypeScript, JSON string in SQL
- Includes gridX/gridY for SuperGrid positioning
- properties field for EAV extension storage
  </action>
  <verify>
1. File exists at src/etl/types/canonical.ts
2. `npm run check:types` passes
3. Exports CanonicalNodeSchema, CanonicalNode, SQL_COLUMN_MAP, toSQLRecord, fromSQLRecord
  </verify>
  <done>CanonicalNodeSchema validates nodes with full LATCH mapping and SQL column conversion</done>
</task>

<task type="auto">
  <name>Task 3: Generate JSON Schema for Swift interop</name>
  <files>src/etl/types/canonical-node.schema.json</files>
  <action>
Create JSON Schema file matching the Zod schema for Swift validation:

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://isometry.app/schemas/canonical-node.json",
  "title": "CanonicalNode",
  "description": "Canonical Node schema for Isometry ETL - single source of truth for imported data",
  "type": "object",
  "required": ["id", "nodeType", "name", "createdAt", "modifiedAt"],
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid",
      "description": "Unique node identifier"
    },
    "nodeType": {
      "type": "string",
      "minLength": 1,
      "default": "note",
      "description": "Type of node (note, calendar, contact, etc.)"
    },
    "name": {
      "type": "string",
      "minLength": 1,
      "description": "Node title/name (LATCH-A primary sort key)"
    },
    "content": {
      "type": ["string", "null"],
      "default": null,
      "description": "Full content body"
    },
    "summary": {
      "type": ["string", "null"],
      "default": null,
      "description": "Brief summary or excerpt"
    },
    "latitude": {
      "type": ["number", "null"],
      "default": null,
      "description": "LATCH-L: Geographic latitude"
    },
    "longitude": {
      "type": ["number", "null"],
      "default": null,
      "description": "LATCH-L: Geographic longitude"
    },
    "locationName": {
      "type": ["string", "null"],
      "default": null,
      "description": "LATCH-L: Named location"
    },
    "locationAddress": {
      "type": ["string", "null"],
      "default": null,
      "description": "LATCH-L: Full address"
    },
    "createdAt": {
      "type": "string",
      "format": "date-time",
      "description": "LATCH-T: Creation timestamp (ISO 8601)"
    },
    "modifiedAt": {
      "type": "string",
      "format": "date-time",
      "description": "LATCH-T: Last modification timestamp (ISO 8601)"
    },
    "dueAt": {
      "type": ["string", "null"],
      "format": "date-time",
      "default": null,
      "description": "LATCH-T: Due date for tasks"
    },
    "completedAt": {
      "type": ["string", "null"],
      "format": "date-time",
      "default": null,
      "description": "LATCH-T: Completion timestamp"
    },
    "eventStart": {
      "type": ["string", "null"],
      "format": "date-time",
      "default": null,
      "description": "LATCH-T: Event start time"
    },
    "eventEnd": {
      "type": ["string", "null"],
      "format": "date-time",
      "default": null,
      "description": "LATCH-T: Event end time"
    },
    "folder": {
      "type": ["string", "null"],
      "default": null,
      "description": "LATCH-C: Folder/collection name"
    },
    "tags": {
      "type": "array",
      "items": { "type": "string" },
      "default": [],
      "description": "LATCH-C: Tag labels"
    },
    "status": {
      "type": ["string", "null"],
      "default": null,
      "description": "LATCH-C: Status (active, completed, archived)"
    },
    "priority": {
      "type": "integer",
      "minimum": 0,
      "maximum": 5,
      "default": 0,
      "description": "LATCH-H: Priority level (0-5)"
    },
    "importance": {
      "type": "integer",
      "minimum": 0,
      "maximum": 5,
      "default": 0,
      "description": "LATCH-H: Importance level (0-5)"
    },
    "sortOrder": {
      "type": "integer",
      "default": 0,
      "description": "LATCH-H: Manual sort order"
    },
    "gridX": {
      "type": "number",
      "default": 0,
      "description": "SuperGrid X position"
    },
    "gridY": {
      "type": "number",
      "default": 0,
      "description": "SuperGrid Y position"
    },
    "source": {
      "type": ["string", "null"],
      "default": null,
      "description": "Data source identifier (alto-index, apple-notes, etc.)"
    },
    "sourceId": {
      "type": ["string", "null"],
      "default": null,
      "description": "Unique ID within source system"
    },
    "sourceUrl": {
      "type": ["string", "null"],
      "format": "uri",
      "default": null,
      "description": "URL link to source"
    },
    "deletedAt": {
      "type": ["string", "null"],
      "format": "date-time",
      "default": null,
      "description": "Soft delete timestamp"
    },
    "version": {
      "type": "integer",
      "minimum": 1,
      "default": 1,
      "description": "Optimistic concurrency version"
    },
    "properties": {
      "type": "object",
      "additionalProperties": true,
      "default": {},
      "description": "Extension point for format-specific metadata"
    }
  }
}
```

This JSON Schema:
- Matches Zod schema semantically
- Uses JSON Schema 2020-12 draft for modern Swift decoders
- Documents LATCH mapping in descriptions
- Specifies required fields matching non-optional Zod fields
  </action>
  <verify>
1. File exists at src/etl/types/canonical-node.schema.json
2. Valid JSON (parseable)
3. Required fields match Zod schema
  </verify>
  <done>JSON Schema file generated matching Zod schema for Swift interoperability</done>
</task>

<task type="auto">
  <name>Task 4: Write unit tests for canonical schema</name>
  <files>src/etl/__tests__/canonical.test.ts</files>
  <action>
Create test file to verify schema validation:

```typescript
import { describe, it, expect } from 'vitest';
import { v4 as uuidv4 } from 'uuid';
import {
  CanonicalNodeSchema,
  CanonicalNode,
  SQL_COLUMN_MAP,
  toSQLRecord,
  fromSQLRecord,
} from '../types/canonical';

describe('CanonicalNodeSchema', () => {
  const validNode: CanonicalNode = {
    id: uuidv4(),
    nodeType: 'note',
    name: 'Test Node',
    content: 'Test content',
    summary: null,
    latitude: null,
    longitude: null,
    locationName: null,
    locationAddress: null,
    createdAt: new Date().toISOString(),
    modifiedAt: new Date().toISOString(),
    dueAt: null,
    completedAt: null,
    eventStart: null,
    eventEnd: null,
    folder: 'Test Folder',
    tags: ['tag1', 'tag2'],
    status: 'active',
    priority: 3,
    importance: 2,
    sortOrder: 0,
    gridX: 0,
    gridY: 0,
    source: 'test',
    sourceId: 'test-123',
    sourceUrl: null,
    deletedAt: null,
    version: 1,
    properties: {},
  };

  it('validates a complete valid node', () => {
    const result = CanonicalNodeSchema.safeParse(validNode);
    expect(result.success).toBe(true);
  });

  it('applies defaults for optional fields', () => {
    const minimal = {
      id: uuidv4(),
      name: 'Minimal Node',
      createdAt: new Date().toISOString(),
      modifiedAt: new Date().toISOString(),
    };
    const result = CanonicalNodeSchema.parse(minimal);
    expect(result.nodeType).toBe('note');
    expect(result.content).toBeNull();
    expect(result.tags).toEqual([]);
    expect(result.priority).toBe(0);
    expect(result.version).toBe(1);
    expect(result.properties).toEqual({});
  });

  it('rejects invalid UUID', () => {
    const invalid = { ...validNode, id: 'not-a-uuid' };
    const result = CanonicalNodeSchema.safeParse(invalid);
    expect(result.success).toBe(false);
  });

  it('rejects empty name', () => {
    const invalid = { ...validNode, name: '' };
    const result = CanonicalNodeSchema.safeParse(invalid);
    expect(result.success).toBe(false);
  });

  it('rejects priority out of range', () => {
    const invalid = { ...validNode, priority: 10 };
    const result = CanonicalNodeSchema.safeParse(invalid);
    expect(result.success).toBe(false);
  });

  it('rejects invalid datetime format', () => {
    const invalid = { ...validNode, createdAt: '2024-01-01' }; // Missing time component
    const result = CanonicalNodeSchema.safeParse(invalid);
    expect(result.success).toBe(false);
  });

  it('accepts valid ISO datetime strings', () => {
    const withDates = {
      ...validNode,
      dueAt: '2024-12-31T23:59:59.999Z',
      eventStart: '2024-06-15T09:00:00Z',
      eventEnd: '2024-06-15T17:00:00Z',
    };
    const result = CanonicalNodeSchema.safeParse(withDates);
    expect(result.success).toBe(true);
  });

  it('stores arbitrary properties', () => {
    const withProps = {
      ...validNode,
      properties: {
        customField: 'custom value',
        nestedObject: { a: 1, b: 2 },
        arrayField: [1, 2, 3],
      },
    };
    const result = CanonicalNodeSchema.parse(withProps);
    expect(result.properties.customField).toBe('custom value');
    expect(result.properties.nestedObject).toEqual({ a: 1, b: 2 });
  });
});

describe('SQL_COLUMN_MAP', () => {
  it('maps all TypeScript fields to SQL columns', () => {
    const tsKeys = Object.keys(SQL_COLUMN_MAP);
    // Should have all CanonicalNode keys except 'properties'
    expect(tsKeys).toContain('nodeType');
    expect(tsKeys).toContain('createdAt');
    expect(tsKeys).toContain('locationName');
    expect(tsKeys).not.toContain('properties');
  });

  it('uses snake_case for SQL columns', () => {
    expect(SQL_COLUMN_MAP.nodeType).toBe('node_type');
    expect(SQL_COLUMN_MAP.createdAt).toBe('created_at');
    expect(SQL_COLUMN_MAP.locationName).toBe('location_name');
    expect(SQL_COLUMN_MAP.sourceUrl).toBe('source_url');
  });
});

describe('toSQLRecord', () => {
  it('converts camelCase to snake_case', () => {
    const node: CanonicalNode = {
      id: uuidv4(),
      nodeType: 'calendar',
      name: 'Test Event',
      content: null,
      summary: null,
      latitude: 40.7128,
      longitude: -74.006,
      locationName: 'New York',
      locationAddress: null,
      createdAt: '2024-01-01T00:00:00Z',
      modifiedAt: '2024-01-01T00:00:00Z',
      dueAt: null,
      completedAt: null,
      eventStart: '2024-06-15T09:00:00Z',
      eventEnd: '2024-06-15T17:00:00Z',
      folder: 'Work',
      tags: ['meeting', 'important'],
      status: 'confirmed',
      priority: 3,
      importance: 4,
      sortOrder: 1,
      gridX: 5,
      gridY: 10,
      source: 'test',
      sourceId: 'evt-123',
      sourceUrl: null,
      deletedAt: null,
      version: 1,
      properties: {},
    };

    const sql = toSQLRecord(node);
    expect(sql.node_type).toBe('calendar');
    expect(sql.location_name).toBe('New York');
    expect(sql.event_start).toBe('2024-06-15T09:00:00Z');
    expect(sql.grid_x).toBe(5);
    expect(sql.tags).toBe('["meeting","important"]');
  });

  it('converts empty tags to null', () => {
    const node = CanonicalNodeSchema.parse({
      id: uuidv4(),
      name: 'No Tags',
      createdAt: new Date().toISOString(),
      modifiedAt: new Date().toISOString(),
      tags: [],
    });
    const sql = toSQLRecord(node);
    expect(sql.tags).toBeNull();
  });
});

describe('fromSQLRecord', () => {
  it('converts snake_case to camelCase', () => {
    const sql = {
      id: uuidv4(),
      node_type: 'contact',
      name: 'John Doe',
      content: null,
      summary: null,
      latitude: null,
      longitude: null,
      location_name: null,
      location_address: null,
      created_at: '2024-01-01T00:00:00Z',
      modified_at: '2024-01-02T00:00:00Z',
      due_at: null,
      completed_at: null,
      event_start: null,
      event_end: null,
      folder: 'Contacts',
      tags: '["friend","colleague"]',
      status: null,
      priority: 0,
      importance: 0,
      sort_order: 0,
      grid_x: 0,
      grid_y: 0,
      source: 'contacts',
      source_id: 'c-123',
      source_url: null,
      deleted_at: null,
      version: 1,
    };

    const node = fromSQLRecord(sql);
    expect(node.nodeType).toBe('contact');
    expect(node.locationName).toBeNull();
    expect(node.modifiedAt).toBe('2024-01-02T00:00:00Z');
    expect(node.tags).toEqual(['friend', 'colleague']);
  });

  it('parses null tags to empty array', () => {
    const sql = {
      id: uuidv4(),
      node_type: 'note',
      name: 'No Tags',
      content: null,
      summary: null,
      latitude: null,
      longitude: null,
      location_name: null,
      location_address: null,
      created_at: '2024-01-01T00:00:00Z',
      modified_at: '2024-01-01T00:00:00Z',
      due_at: null,
      completed_at: null,
      event_start: null,
      event_end: null,
      folder: null,
      tags: null,
      status: null,
      priority: 0,
      importance: 0,
      sort_order: 0,
      grid_x: 0,
      grid_y: 0,
      source: null,
      source_id: null,
      source_url: null,
      deleted_at: null,
      version: 1,
    };

    const node = fromSQLRecord(sql);
    expect(node.tags).toEqual([]);
    expect(node.properties).toEqual({});
  });
});
```

Tests cover:
- Complete valid node validation
- Default value application
- Invalid data rejection (UUID, empty name, out-of-range priority)
- Datetime format validation
- Properties extension storage
- SQL column mapping completeness
- Round-trip conversion (toSQLRecord/fromSQLRecord)
  </action>
  <verify>
1. File exists at src/etl/__tests__/canonical.test.ts
2. `npm run test -- --run src/etl/__tests__/canonical.test.ts` passes all tests
  </verify>
  <done>Unit tests verify schema validation, defaults, SQL mapping, and round-trip conversion</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Dependencies installed:**
   ```bash
   npm ls zod --depth=0
   ```
   Shows zod as direct dependency (not just via knip).

2. **TypeScript compiles:**
   ```bash
   npm run check:types
   ```
   No errors.

3. **Tests pass:**
   ```bash
   npm run test -- --run src/etl/__tests__/canonical.test.ts
   ```
   All tests green.

4. **JSON Schema valid:**
   ```bash
   cat src/etl/types/canonical-node.schema.json | jq .
   ```
   Parses without error.
</verification>

<success_criteria>
- [ ] zod ^3.22.4 or ^4.x in package.json dependencies (direct, not transitive)
- [ ] src/etl/types/canonical.ts exists with CanonicalNodeSchema export
- [ ] src/etl/types/canonical-node.schema.json exists with valid JSON Schema
- [ ] SQL_COLUMN_MAP covers all LATCH fields matching schema.sql
- [ ] toSQLRecord/fromSQLRecord provide round-trip conversion
- [ ] All unit tests pass
- [ ] `npm run check:types` passes
</success_criteria>

<output>
After completion, create `.planning/phases/67-canonical-schema/67-01-SUMMARY.md`
</output>
