---
phase: 06.1-foundation-layout
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [
  "native/Sources/Isometry/Resources/schema.sql",
  "native/Sources/Isometry/Database/IsometryDatabase.swift",
  "native/Sources/Isometry/Sync/CloudKitSyncManager.swift",
  "native/Sources/Isometry/Models/NotebookCard.swift"
]
autonomous: true

must_haves:
  truths:
    - "Database schema supports notebook cards with all required fields"
    - "CloudKit schema includes notebook_cards record type with sync"
    - "NotebookCard model provides typed access to notebook data"
    - "Database queries can fetch/save notebook cards efficiently"
  artifacts:
    - path: "native/Sources/Isometry/Resources/schema.sql"
      provides: "notebook_cards table with proper indexes"
      contains: "CREATE TABLE notebook_cards"
    - path: "native/Sources/Isometry/Models/NotebookCard.swift"
      provides: "Swift model for notebook cards"
      exports: ["NotebookCard"]
    - path: "native/Sources/Isometry/Database/IsometryDatabase.swift"
      provides: "CRUD methods for notebook cards"
      contains: "func createNotebookCard"
  key_links:
    - from: "NotebookCard.swift"
      to: "schema.sql"
      via: "table structure mapping"
      pattern: "notebook_cards.*id.*markdown.*properties"
    - from: "CloudKitSyncManager"
      to: "NotebookCard"
      via: "CKRecord conversion"
      pattern: "CKRecord.*notebook_cards"
---

<objective>
Extend existing database and CloudKit infrastructure to support notebook cards with full-text search, properties, and synchronization.

Purpose: Provide persistent storage foundation for notebook workflow that integrates seamlessly with existing Isometry data model
Output: Database schema extension, Swift models, and CloudKit sync support for notebook cards
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@native/Sources/Isometry/Resources/schema.sql
@native/Sources/Isometry/Models/Node.swift
@native/Sources/Isometry/Database/IsometryDatabase.swift
@native/Sources/Isometry/Sync/CloudKitSyncManager.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend database schema for notebook cards</name>
  <files>native/Sources/Isometry/Resources/schema.sql</files>
  <action>
    Add notebook_cards table to existing schema.sql (append after existing tables):

    ```sql
    -- Notebook Cards for capture-shell-preview workflow
    CREATE TABLE notebook_cards (
        id TEXT PRIMARY KEY,
        title TEXT NOT NULL,
        markdown_content TEXT,
        properties JSON DEFAULT '{}',
        template_id TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        modified_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        folder TEXT,
        tags JSON DEFAULT '[]',

        -- Integration with existing nodes (optional relationship)
        linked_node_id TEXT REFERENCES nodes(id),

        -- CloudKit sync fields (matching existing pattern)
        sync_version INTEGER DEFAULT 1,
        last_synced_at DATETIME,
        conflict_resolved_at DATETIME,
        deleted_at DATETIME,

        FOREIGN KEY (linked_node_id) REFERENCES nodes(id) ON DELETE SET NULL
    );

    -- Indexes for performance (match existing pattern)
    CREATE INDEX idx_notebook_cards_created_at ON notebook_cards(created_at);
    CREATE INDEX idx_notebook_cards_modified_at ON notebook_cards(modified_at);
    CREATE INDEX idx_notebook_cards_folder ON notebook_cards(folder);
    CREATE INDEX idx_notebook_cards_template_id ON notebook_cards(template_id);
    CREATE INDEX idx_notebook_cards_sync ON notebook_cards(sync_version, last_synced_at);

    -- Full-text search (matching existing FTS pattern)
    CREATE VIRTUAL TABLE notebook_cards_fts USING fts5(
        title,
        markdown_content,
        content='notebook_cards',
        content_rowid='rowid'
    );

    -- FTS trigger to maintain search index
    CREATE TRIGGER notebook_cards_fts_insert AFTER INSERT ON notebook_cards BEGIN
        INSERT INTO notebook_cards_fts(rowid, title, markdown_content)
        VALUES (new.rowid, new.title, new.markdown_content);
    END;

    CREATE TRIGGER notebook_cards_fts_update AFTER UPDATE ON notebook_cards BEGIN
        UPDATE notebook_cards_fts SET title=new.title, markdown_content=new.markdown_content
        WHERE rowid=new.rowid;
    END;

    CREATE TRIGGER notebook_cards_fts_delete AFTER DELETE ON notebook_cards BEGIN
        DELETE FROM notebook_cards_fts WHERE rowid=old.rowid;
    END;
    ```

    Follow existing schema patterns exactly for consistency with current database.
  </action>
  <verify>Schema builds without errors in SQLite, indexes created successfully</verify>
  <done>Database schema includes notebook_cards table with FTS and proper indexes</done>
</task>

<task type="auto">
  <name>Task 2: Create NotebookCard Swift model</name>
  <files>native/Sources/Isometry/Models/NotebookCard.swift</files>
  <action>
    Create NotebookCard model following existing Node.swift patterns:

    ```swift
    import Foundation
    import GRDB

    /// Notebook card for capture-shell-preview workflow
    public struct NotebookCard: Codable, Sendable, Hashable {
        public let id: String
        public let title: String
        public let markdownContent: String?
        public let properties: [String: String] // Simplified for now
        public let templateId: String?
        public let createdAt: Date
        public let modifiedAt: Date
        public let folder: String?
        public let tags: [String]
        public let linkedNodeId: String?

        // CloudKit sync fields
        public let syncVersion: Int
        public let lastSyncedAt: Date?
        public let conflictResolvedAt: Date?
        public let deletedAt: Date?

        public init(
            id: String = UUID().uuidString,
            title: String,
            markdownContent: String? = nil,
            properties: [String: String] = [:],
            templateId: String? = nil,
            createdAt: Date = Date(),
            modifiedAt: Date = Date(),
            folder: String? = nil,
            tags: [String] = [],
            linkedNodeId: String? = nil,
            syncVersion: Int = 1,
            lastSyncedAt: Date? = nil,
            conflictResolvedAt: Date? = nil,
            deletedAt: Date? = nil
        ) {
            self.id = id
            self.title = title
            self.markdownContent = markdownContent
            self.properties = properties
            self.templateId = templateId
            self.createdAt = createdAt
            self.modifiedAt = modifiedAt
            self.folder = folder
            self.tags = tags
            self.linkedNodeId = linkedNodeId
            self.syncVersion = syncVersion
            self.lastSyncedAt = lastSyncedAt
            self.conflictResolvedAt = conflictResolvedAt
            self.deletedAt = deletedAt
        }
    }
    ```

    Add GRDB FetchableRecord and PersistableRecord conformance following Node.swift patterns exactly.
    Handle JSON encoding/decoding for properties and tags arrays.
  </action>
  <verify>NotebookCard builds and conforms to required protocols</verify>
  <done>NotebookCard model exists with proper GRDB integration and CloudKit sync fields</done>
</task>

<task type="auto">
  <name>Task 3: Add database methods and CloudKit sync</name>
  <files>native/Sources/Isometry/Database/IsometryDatabase.swift, native/Sources/Isometry/Sync/CloudKitSyncManager.swift</files>
  <action>
    In IsometryDatabase.swift, add notebook card CRUD methods:
    - `func createNotebookCard(_ card: NotebookCard) async throws`
    - `func updateNotebookCard(_ card: NotebookCard) async throws`
    - `func getNotebookCard(id: String) async throws -> NotebookCard?`
    - `func getAllNotebookCards() async throws -> [NotebookCard]`
    - `func searchNotebookCards(_ query: String) async throws -> [NotebookCard]`
    - `func deleteNotebookCard(id: String) async throws`

    Follow existing patterns from Node operations exactly. Use same error handling, transactions, and performance optimizations.

    In CloudKitSyncManager.swift, add NotebookCard sync support:
    - Add "notebook_cards" to record types array
    - Add convertToCloudKit() and convertFromCloudKit() methods for NotebookCard
    - Follow existing Node sync patterns exactly
    - Handle properties and tags as CKRecord fields

    Import NotebookCard model in both files.
  </action>
  <verify>Database methods compile and CloudKit sync manager includes notebook_cards record type</verify>
  <done>Database and CloudKit infrastructure supports full notebook card lifecycle</done>
</task>

</tasks>

<verification>
1. Build native project: `cd native && xcodebuild -scheme Isometry build`
2. Run database migration to verify schema changes work
3. Test creating/fetching notebook cards through database methods
4. Verify CloudKit schema can sync notebook cards (requires developer account)
</verification>

<success_criteria>
- Database includes notebook_cards table with proper indexes and FTS support
- NotebookCard Swift model provides typed access to all notebook data
- Database methods support full CRUD operations for notebook cards
- CloudKit sync manager can synchronize notebook cards across devices
- Schema changes maintain compatibility with existing data
</success_criteria>

<output>
After completion, create `.planning/phases/06.1-foundation-layout/06.1-02-SUMMARY.md`
</output>