---
phase: 06.1-foundation-layout
plan: 03
type: execute
wave: 2
depends_on: ["06.1-01"]
files_modified: [
  "native/Sources/Isometry/App/AppState.swift",
  "native/Sources/Isometry/App/ContentView.swift",
  "native/Sources/Isometry/Models/NavigationModel.swift"
]
autonomous: true

must_haves:
  truths:
    - "User can navigate between main app and notebook mode via navigation"
    - "Navigation state persists when switching between modes"
    - "App remembers user's last position in both main and notebook modes"
    - "Navigation transitions are smooth and maintain context"
  artifacts:
    - path: "native/Sources/Isometry/App/AppState.swift"
      provides: "Notebook mode state management"
      contains: "var isNotebookMode"
    - path: "native/Sources/Isometry/Models/NavigationModel.swift"
      provides: "Navigation state persistence"
      exports: ["NavigationModel", "AppMode"]
    - path: "native/Sources/Isometry/App/ContentView.swift"
      provides: "Mode switching integration"
      contains: "NotebookContentView"
  key_links:
    - from: "AppState"
      to: "NavigationModel"
      via: "mode state binding"
      pattern: "@Published.*appMode"
    - from: "ContentView"
      to: "NotebookContentView"
      via: "conditional rendering"
      pattern: "if.*isNotebookMode"
---

<objective>
Integrate notebook mode navigation into existing app architecture while preserving main app state and providing seamless mode switching.

Purpose: Enable users to access notebook functionality within the existing native app navigation structure
Output: Navigation system supporting both main Isometry mode and notebook mode with state preservation
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@native/Sources/Isometry/App/ContentView.swift
@native/Sources/Isometry/App/AppState.swift
@.planning/phases/06.1-foundation-layout/06.1-01-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create NavigationModel for app mode management</name>
  <files>native/Sources/Isometry/Models/NavigationModel.swift</files>
  <action>
    Create NavigationModel that manages app mode state:

    ```swift
    import Foundation
    import SwiftUI

    /// App mode enumeration
    public enum AppMode: String, CaseIterable, Codable {
        case main = "main"
        case notebook = "notebook"

        var title: String {
            switch self {
            case .main: return "Isometry"
            case .notebook: return "Notebook"
            }
        }

        var systemImage: String {
            switch self {
            case .main: return "square.grid.3x3"
            case .notebook: return "book.pages"
            }
        }
    }

    /// Navigation state management
    @MainActor
    public final class NavigationModel: ObservableObject {
        @Published public var currentMode: AppMode = .main
        @Published public var previousMode: AppMode = .main

        // State preservation
        @Published public var mainViewState: MainViewState = MainViewState()
        @Published public var notebookViewState: NotebookViewState = NotebookViewState()

        private let userDefaults = UserDefaults.standard
        private let currentModeKey = "NavigationModel.currentMode"

        public init() {
            loadPersistedState()
        }

        public func switchMode(to newMode: AppMode) {
            previousMode = currentMode
            currentMode = newMode
            savePersistedState()
        }

        public func toggleMode() {
            let newMode: AppMode = currentMode == .main ? .notebook : .main
            switchMode(to: newMode)
        }

        private func loadPersistedState() {
            if let modeString = userDefaults.string(forKey: currentModeKey),
               let mode = AppMode(rawValue: modeString) {
                currentMode = mode
            }
        }

        private func savePersistedState() {
            userDefaults.set(currentMode.rawValue, forKey: currentModeKey)
        }
    }

    // State preservation structures
    public struct MainViewState: Codable {
        public var selectedFolder: String?
        public var searchText: String = ""
    }

    public struct NotebookViewState: Codable {
        public var selectedCardId: String?
        public var lastEditingComponent: String? // "capture", "shell", "preview"
    }
    ```

    Follow existing app patterns for UserDefaults persistence and @MainActor usage.
  </action>
  <verify>NavigationModel builds and can switch between app modes</verify>
  <done>NavigationModel manages app mode state with persistence</done>
</task>

<task type="auto">
  <name>Task 2: Integrate navigation into AppState and ContentView</name>
  <files>native/Sources/Isometry/App/AppState.swift, native/Sources/Isometry/App/ContentView.swift</files>
  <action>
    In AppState.swift, add navigation support:
    - Add `@Published var navigation = NavigationModel()` property
    - Add computed property `var isNotebookMode: Bool { navigation.currentMode == .notebook }`
    - In existing initialization, observe navigation changes for state management

    In ContentView.swift, modify main view structure:
    - Add `@EnvironmentObject private var navigation: NavigationModel`
    - Wrap existing NavigationSplitView in conditional based on `appState.isNotebookMode`
    - Add NotebookContentView import and conditional rendering
    - Add toolbar item for mode switching:

    ```swift
    ToolbarItem(placement: .navigation) {
        Button {
            appState.navigation.toggleMode()
        } label: {
            Image(systemName: appState.navigation.currentMode.systemImage)
        }
        .help("Switch to \(appState.navigation.currentMode == .main ? "Notebook" : "Main") Mode")
    }
    ```

    Preserve existing toolbar items and ensure NotebookContentView is properly integrated.
    Maintain existing error handling and loading states.
  </action>
  <verify>ContentView builds and can switch between main and notebook modes</verify>
  <done>App navigation integrates notebook mode with existing main app functionality</done>
</task>

</tasks>

<verification>
1. Build native project: `cd native && xcodebuild -scheme Isometry build`
2. Test mode switching via toolbar button
3. Verify navigation state persists across app restarts
4. Check that main app state is preserved when switching to notebook mode
5. Confirm smooth transitions between modes
</verification>

<success_criteria>
- Navigation toolbar allows seamless switching between main and notebook modes
- App state is preserved when switching between modes
- Navigation preferences persist across app sessions
- Both iOS and macOS support proper navigation patterns
- Mode switching provides clear visual feedback to user
</success_criteria>

<output>
After completion, create `.planning/phases/06.1-foundation-layout/06.1-03-SUMMARY.md`
</output>