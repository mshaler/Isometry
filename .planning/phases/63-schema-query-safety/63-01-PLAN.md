---
phase: 63-schema-query-safety
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/schema.sql
  - src/db/operations.ts
  - src/db/init.ts
autonomous: true

must_haves:
  truths:
    - "node_properties table exists with proper schema"
    - "Properties linked to nodes via foreign key with cascade delete"
    - "execute() binds parameters via stmt.bind()"
  artifacts:
    - path: "src/db/schema.sql"
      provides: "node_properties table definition"
      contains: "CREATE TABLE IF NOT EXISTS node_properties"
    - path: "src/db/operations.ts"
      provides: "Fixed execute() with parameter binding"
      contains: "stmt.bind"
  key_links:
    - from: "node_properties.node_id"
      to: "nodes.id"
      via: "REFERENCES with ON DELETE CASCADE"
      pattern: "REFERENCES nodes\\(id\\) ON DELETE CASCADE"
---

<objective>
Add node_properties table to schema and fix SQL injection vulnerability in execute()

Purpose: Enable arbitrary YAML frontmatter storage and ensure query parameter safety across the application
Output: Updated schema.sql with node_properties table, fixed operations.ts with proper parameter binding
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/63-schema-query-safety/63-RESEARCH.md

@src/db/schema.sql
@src/db/operations.ts
@src/db/init.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add node_properties table to schema</name>
  <files>src/db/schema.sql</files>
  <action>
Add `node_properties` table after the `nodes` table definition in schema.sql:

```sql
-- Node Properties: Dynamic key-value storage for arbitrary YAML frontmatter
CREATE TABLE IF NOT EXISTS node_properties (
    id TEXT PRIMARY KEY,
    node_id TEXT NOT NULL REFERENCES nodes(id) ON DELETE CASCADE,
    key TEXT NOT NULL,
    value TEXT,  -- JSON-encoded value (preserves type information)
    value_type TEXT NOT NULL DEFAULT 'string',  -- string, number, boolean, array, object, null
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    UNIQUE(node_id, key)  -- One value per key per node
);

-- Indexes for efficient property queries
CREATE INDEX IF NOT EXISTS idx_node_properties_node_id ON node_properties(node_id);
CREATE INDEX IF NOT EXISTS idx_node_properties_key ON node_properties(key);
CREATE INDEX IF NOT EXISTS idx_node_properties_lookup ON node_properties(node_id, key);
```

Place this immediately after the nodes table and its indexes (after line 63 in current schema), before the FTS5 virtual table.

Note: Using EAV table per roadmap specification (research suggested JSON column but roadmap explicitly requires node_properties table).
  </action>
  <verify>
Run `npm run typecheck` to ensure no type errors.
Grep for "node_properties" in schema.sql to confirm table exists.
  </verify>
  <done>
node_properties table defined with:
- Foreign key to nodes(id) with ON DELETE CASCADE
- UNIQUE constraint on (node_id, key)
- Indexes for efficient querying
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix execute() parameter binding vulnerability</name>
  <files>src/db/operations.ts</files>
  <action>
Fix the SQL injection vulnerability in `execute()` function (line 33).

Current bug: The `_params` parameter is prefixed with underscore (indicating unused) and `stmt.bind()` is never called.

Change from:
```typescript
const execute = (sql: string, _params: unknown[] = []): Record<string, unknown>[] => {
  // ... _params is never used
  const stmt = db.prepare(sql);
  // ...
}
```

To:
```typescript
const execute = (sql: string, params: unknown[] = []): Record<string, unknown>[] => {
  // ...
  const stmt = db.prepare(sql);

  // Bind parameters before stepping through results
  if (params.length > 0) {
    stmt.bind(params as BindParams);
  }

  // ... rest of function
}
```

Key changes:
1. Remove underscore prefix from `_params` -> `params`
2. Add `if (params.length > 0) { stmt.bind(params as BindParams); }` before the while loop

This mirrors the existing pattern in `run()` function (line 70) which correctly uses `stmt.run(params as BindParams)`.
  </action>
  <verify>
Run `npm run typecheck` to ensure no type errors.
Grep for "stmt.bind" in operations.ts to confirm binding is present in both functions.
  </verify>
  <done>
execute() function:
- Removes underscore prefix from params parameter
- Calls stmt.bind(params) before stepping
- Matches pattern used in run() function
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify schema loads correctly in init.ts</name>
  <files>src/db/init.ts</files>
  <action>
Verify that the schema loading in init.ts handles the new table correctly. No code changes expected - this is a verification task.

Check that:
1. `db.run(schemaSQL)` or equivalent executes full schema including new table
2. No hardcoded assumptions about table names that would exclude node_properties
3. Schema loading doesn't filter out specific tables

If any issues found, document what changes are needed. Most likely no changes needed since schema.sql is loaded as a whole.
  </action>
  <verify>
Read src/db/init.ts and confirm schema loading approach.
Run `npm run dev` briefly and check browser console for database initialization success.
  </verify>
  <done>
Schema loading verified to handle new table:
- Either confirms no changes needed, OR
- Documents and implements any required changes
  </done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes with zero errors
2. `grep -n "node_properties" src/db/schema.sql` shows table definition
3. `grep -n "stmt.bind" src/db/operations.ts` shows binding in execute()
4. `grep -n "ON DELETE CASCADE" src/db/schema.sql` shows cascade on node_properties
</verification>

<success_criteria>
- node_properties table exists in schema with foreign key and cascade delete
- execute() function binds parameters using stmt.bind()
- Schema loads successfully in database initialization
- All TypeScript type checks pass
</success_criteria>

<output>
After completion, create `.planning/phases/63-schema-query-safety/63-01-SUMMARY.md`
</output>
