---
phase: 10-foundation-cleanup
plan: 11
type: execute
wave: 1
depends_on: []
files_modified: [
  "src/components/demo/D3SampleChart.tsx",
  "src/components/demo/GridDemo.tsx",
  "src/utils/encrypted-storage.ts",
  "src/utils/officeDocumentProcessor.ts",
  "src/components/shell/TerminalEmulator.tsx"
]
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Code compiles without strict mode errors when running npx tsc --noEmit --strict"
    - "D3 demo components display visualizations without runtime type errors"
    - "Encrypted storage functions work without type-related crashes"
    - "Office document processing completes without type assignment failures"
  artifacts:
    - path: "src/components/demo/"
      provides: "Type-safe D3 demo components"
      contains: "proper D3Selection types"
    - path: "src/utils/encrypted-storage.ts"
      provides: "Proper crypto API type compatibility"
      exports: ["EncryptedStorage"]
    - path: "src/utils/officeDocumentProcessor.ts"
      provides: "Consistent type assignments for document processing"
      exports: ["processOfficeDocument"]
  key_links:
    - from: "D3 demo components"
      to: "D3 type definitions"
      via: "proper D3Selection<T> generics"
      pattern: "d3\\.select.*<.*Element>"
    - from: "EncryptedStorage"
      to: "Web Crypto API"
      via: "BufferSource type compatibility"
      pattern: "crypto\\.subtle\\.(encrypt|decrypt)"
---

<objective>
Resolve TypeScript strict mode compilation failures by fixing D3 type mismatches, crypto API compatibility issues, and type assignment inconsistencies in utility components.

Purpose: Address the "hundreds of TypeScript errors" gap preventing strict mode compilation, enabling production-ready type safety across the entire codebase.
Output: TypeScript strict mode compilation success with zero errors, completing the foundation cleanup type safety requirements.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-foundation-cleanup/10-09-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix D3 demo component type mismatches</name>
  <files>src/components/demo/D3SampleChart.tsx, src/components/demo/GridDemo.tsx</files>
  <action>
    Address the D3 type mismatches and 'any' type parameters identified in verification gaps:

    For D3SampleChart.tsx:
    - Add proper D3Selection type parameters: D3Selection<SVGElement, unknown, null, undefined>
    - Fix data binding with explicit type annotations for scales and axes
    - Use type guards for d3.max/d3.min operations similar to 10-09 histogram fixes
    - Apply the established String() conversion pattern for data accessors

    For GridDemo.tsx:
    - Add proper D3Selection types for SVG container and grid elements
    - Fix scale domain/range type assignments with explicit number[] types
    - Use Number() filtering for data operations to prevent undefined/null issues
    - Apply D3ChartTheme interface pattern from 10-09 for theme consistency

    Reference 10-09 patterns: D3 type guards, Number filtering, and String() conversion for type safety.
  </action>
  <verify>npx tsc --noEmit --strict | grep -E "(demo|D3)" | wc -l</verify>
  <done>D3 demo components compile with TypeScript strict mode without errors</done>
</task>

<task type="auto">
  <name>Task 2: Resolve crypto API BufferSource type issues</name>
  <files>src/utils/encrypted-storage.ts</files>
  <action>
    Fix BufferSource type incompatibilities in crypto operations:

    Identified issue: BufferSource type mismatches in Web Crypto API usage

    Solutions:
    - Use proper TypedArray or ArrayBuffer types instead of generic BufferSource
    - Add type assertions where necessary: data as ArrayBuffer
    - Create helper functions for buffer conversion: toArrayBuffer(data: string | Uint8Array)
    - Use proper async/await typing for crypto.subtle operations
    - Add error handling with typed catch blocks

    Ensure compatibility with both browser and WebView crypto implementations.
    Follow the established String() conversion pattern for consistent type handling.
  </action>
  <verify>npx tsc --noEmit --strict src/utils/encrypted-storage.ts</verify>
  <done>Encrypted storage compiles with strict mode, crypto API types resolved</done>
</task>

<task type="auto">
  <name>Task 3: Fix office document processor type assignments</name>
  <files>src/utils/officeDocumentProcessor.ts</files>
  <action>
    Resolve null vs undefined type mismatches and unknown types:

    Identified issues from verification:
    - null vs undefined type mismatches in document parsing
    - unknown types in mammoth.js integration
    - Inconsistent type assignments for document properties

    Solutions:
    - Use consistent undefined (not null) for optional properties following project pattern
    - Add proper interfaces for mammoth document structure
    - Use type guards for unknown mammoth results: if (result && typeof result === 'object')
    - Apply String() conversion pattern for document text content
    - Add proper error handling with typed exceptions

    Reference 10-09 established patterns: undefined over null, String() conversion, and interface completion.
  </action>
  <verify>npx tsc --noEmit --strict src/utils/officeDocumentProcessor.ts</verify>
  <done>Office document processor compiles with strict mode, type assignments consistent</done>
</task>

<task type="auto">
  <name>Task 4: Validate TypeScript strict mode compilation success</name>
  <files></files>
  <action>
    Comprehensive TypeScript strict mode validation:

    1. Run full strict mode compilation: npx tsc --noEmit --strict
    2. Verify zero compilation errors across all source files
    3. Test build process still functions: npm run build
    4. Validate runtime functionality with npm run dev (quick smoke test)
    5. Generate before/after compilation metrics

    Compare against verification baseline:
    - Before: "Hundreds of TypeScript strict mode errors"
    - After: Zero compilation errors with strict mode enabled

    Document successful TypeScript strict mode foundation for Phase 11 readiness.
  </action>
  <verify>npx tsc --noEmit --strict</verify>
  <done>Complete TypeScript strict mode compilation achieved, foundation ready for Phase 11</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit --strict` completes with zero errors
- D3 demo components compile without type mismatches
- Crypto API operations use proper BufferSource types
- Office document processor has consistent type assignments
- `npm run build` still succeeds with strict mode fixes
</verification>

<success_criteria>
TypeScript strict mode compilation success eliminates the "hundreds of errors" gap, achieving type safety foundation required for Phase 10 completion and Phase 11 readiness.
</success_criteria>

<output>
After completion, create `.planning/phases/10-foundation-cleanup/10-11-SUMMARY.md`
</output>