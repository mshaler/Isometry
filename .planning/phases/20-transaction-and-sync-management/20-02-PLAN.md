---
phase: 20-transaction-and-sync-management
plan: 02
type: execute
wave: 2
depends_on: [20-01]
files_modified: [
  native/Sources/Isometry/Sync/ConflictDetectionService.swift,
  native/Sources/Isometry/Sync/ConflictResolver.swift,
  src/components/ConflictResolutionModal.tsx,
  src/hooks/useConflictResolution.ts,
  src/utils/transaction/rollback-manager.ts,
  native/Sources/Isometry/Database/RollbackManager.swift
]
autonomous: false

must_haves:
  truths:
    - "Conflicts from simultaneous editing on multiple devices resolve with user control"
    - "Failed transactions rollback completely within 50ms without leaving partial state"
    - "Application clearly displays conflict status and provides resolution interface"
    - "Auto-resolved conflicts show subtle notification explaining resolution"
  artifacts:
    - path: "src/components/ConflictResolutionModal.tsx"
      provides: "Side-by-side diff interface for manual conflict resolution"
      min_lines: 100
    - path: "native/Sources/Isometry/Sync/ConflictResolver.swift"
      provides: "CloudKit conflict detection and resolution logic"
      exports: ["detectConflicts", "resolveConflict"]
    - path: "src/utils/transaction/rollback-manager.ts"
      provides: "Transaction rollback coordination with state cleanup"
      exports: ["rollbackTransaction", "preserveDrafts"]
  key_links:
    - from: "useConflictResolution.ts"
      to: "ConflictDetectionService.swift"
      via: "conflict detection bridge messages"
      pattern: "bridgeMessage.*conflict"
    - from: "ConflictResolutionModal.tsx"
      to: "ConflictResolver.swift"
      via: "resolution decision bridge calls"
      pattern: "resolveConflict.*manual"
    - from: "rollback-manager.ts"
      to: "TransactionBridge.swift"
      via: "rollback coordination"
      pattern: "rollbackTransaction"
---

<objective>
Implement multi-device conflict resolution and comprehensive transaction rollback with user control and state preservation

Purpose: Handle conflicts when users edit simultaneously on different devices, provide intuitive resolution interfaces, and ensure failed transactions clean up completely without data corruption
Output: Production-ready conflict resolution system with automatic and manual resolution flows
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-transaction-and-sync-management/20-01-SUMMARY.md

# Phase-specific research and decisions
@.planning/phases/20-transaction-and-sync-management/20-CONTEXT.md
@.planning/phases/20-transaction-and-sync-management/20-RESEARCH.md

# CloudKit integration context
@native/Sources/Isometry/Sync/CloudKitSyncManager.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: CloudKit conflict detection and resolution backend</name>
  <files>
    native/Sources/Isometry/Sync/ConflictDetectionService.swift
    native/Sources/Isometry/Sync/ConflictResolver.swift
  </files>
  <action>
    Implement CloudKit-based conflict detection with adaptive granularity and smart resolution:

    1. **ConflictDetectionService.swift**: Session-aware conflict monitoring
       - `startMonitoring(for recordTypes: [String])` - begins adaptive frequency monitoring
       - `detectConflicts(recordID: CKRecord.ID) async throws -> [ConflictInfo]` - field-level conflict detection
       - Session-aware polling: 2s intervals for active editing sessions, 30s for idle devices (per research Pattern 3)
       - Event-driven backup using CloudKit push notifications for immediate conflict alerts
       - Adaptive granularity: smart detection based on content type and historical conflict patterns
       - Integration with existing CloudKitSyncManager for subscription management

    2. **ConflictResolver.swift**: Intelligent conflict resolution engine
       - `resolveAutomatically(conflicts: [ConflictInfo]) async throws -> [ResolvedConflict]` - CRDT-style automatic resolution
       - `prepareManualResolution(conflict: ConflictInfo) async throws -> ConflictDiff` - diff generation for UI
       - `applyResolution(conflict: ConflictInfo, decision: ResolutionDecision) async throws` - apply user decision
       - Smart hybrid approach: auto-resolve simple conflicts (timestamps, non-overlapping fields), manual for complex
       - Field-level last-edit-wins for simple cases, preserve both versions for manual review
       - CloudKit record merging with proper modification date handling

    Follow research CloudKit conflict resolution patterns. Integrate with existing sync infrastructure. Use Actor isolation for thread safety. Implement adaptive monitoring frequency based on user activity patterns.
  </action>
  <verify>
    1. Swift compilation: `swift build` in native directory succeeds
    2. CloudKit integration: `grep -n "CKRecord\|CloudKit" native/Sources/Isometry/Sync/ConflictDetectionService.swift`
    3. Actor safety: `grep -n "actor.*ConflictDetectionService\|actor.*ConflictResolver" native/Sources/Isometry/Sync/`
    4. Automatic resolution: `grep -n "resolveAutomatically\|CRDT" native/Sources/Isometry/Sync/ConflictResolver.swift`
  </verify>
  <done>ConflictDetectionService monitors CloudKit changes with adaptive frequency, ConflictResolver implements hybrid automatic/manual resolution with field-level conflict detection</done>
</task>

<task type="auto">
  <name>Task 2: Transaction rollback and state cleanup infrastructure</name>
  <files>
    native/Sources/Isometry/Database/RollbackManager.swift
    src/utils/transaction/rollback-manager.ts
  </files>
  <action>
    Implement comprehensive transaction rollback with draft preservation and state cleanup:

    1. **RollbackManager.swift**: Database-level rollback coordination
       - `rollbackTransaction(transactionId: String, preserveDrafts: Bool) async throws` - coordinated rollback with cleanup
       - `preserveValidState(from transaction: TransactionInfo) async throws -> DraftInfo` - save valid portions as drafts
       - `cleanupTransactionState(transactionId: String) async throws` - remove transaction artifacts
       - Integration with TransactionBridge for coordinated rollback operations
       - Smart preservation: save valid database operations, discard problematic ones
       - 50ms rollback completion target with optimized cleanup procedures

    2. **rollback-manager.ts**: React-side rollback coordination
       - `rollbackTransaction(correlationId: string, preserveDrafts?: boolean): Promise<RollbackResult>` - client rollback API
       - `handleRollbackNotification(result: RollbackResult): void` - user feedback coordination
       - `recoverFromDrafts(draftIds: string[]): Promise<RecoveryResult>` - draft recovery workflow
       - Toast notification system for rollback communication (brief message explaining what was rolled back)
       - Integration with existing useTransaction hook for automatic rollback triggers
       - Draft state preservation UI for user review and resubmission

    Follow research patterns for smart preservation and draft state recovery. Coordinate with Phase 20-01 transaction infrastructure. Implement <50ms rollback timing requirements. Provide clear user feedback for rollback events.
  </action>
  <verify>
    1. Swift compilation: `swift build` in native directory succeeds
    2. TypeScript compilation: `npm run type-check` passes
    3. Rollback timing: `grep -n "50ms\|millisecond" native/Sources/Isometry/Database/RollbackManager.swift`
    4. Draft preservation: `grep -n "preserveValidState\|DraftInfo" native/Sources/Isometry/Database/RollbackManager.swift`
    5. Toast integration: `grep -n "toast\|notification" src/utils/transaction/rollback-manager.ts`
  </verify>
  <done>RollbackManager provides <50ms transaction rollback with state cleanup, rollback-manager.ts coordinates client-side recovery with draft preservation and user notifications</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Conflict resolution UI with side-by-side diff interface and manual resolution controls</what-built>
  <name>Task 3: Conflict resolution user interface</name>
  <files>
    src/components/ConflictResolutionModal.tsx
    src/hooks/useConflictResolution.ts
  </files>
  <action>
    Create intuitive conflict resolution UI following git merge tool patterns:

    1. **ConflictResolutionModal.tsx**: Side-by-side diff interface
       - Modal component with side-by-side diff display for conflicted content
       - Left panel: server version, Right panel: client version, Center: merged result
       - Visual highlighting for conflicted sections (red background), auto-merged sections (green background)
       - Resolution controls: "Keep Left", "Keep Right", "Edit Manually", "Keep Both"
       - Show merged content while conflicts pending (auto-merged visible, conflicted highlighted)
       - Integration with existing theme system (NeXTSTEP/Modern themes)
       - Responsive design for both desktop and mobile conflict resolution

    2. **useConflictResolution.ts**: Conflict resolution state management
       - `const { conflicts, resolveConflict, autoResolveSimple } = useConflictResolution()`
       - `resolveConflict(conflictId: string, decision: ResolutionDecision): Promise<void>` - manual resolution API
       - `autoResolveSimple(conflicts: ConflictInfo[]): Promise<AutoResolutionResult>` - automatic resolution trigger
       - Subtle toast notifications for auto-resolved conflicts (brief message indicating resolution occurred)
       - Bridge integration with ConflictResolver for resolution application
       - State tracking for pending conflicts and resolution progress

    Follow research side-by-side diff interface pattern. Implement familiar git merge tool UX. Provide clear visual indicators for conflict types. Enable mobile-friendly conflict resolution. Integrate with existing UI theme system.
  </action>
  <verify>
    1. TypeScript compilation: `npm run type-check` passes
    2. React component structure: `grep -n "ConflictResolutionModal\|side-by-side" src/components/ConflictResolutionModal.tsx`
    3. Hook integration: `grep -n "useConflictResolution\|resolveConflict" src/hooks/useConflictResolution.ts`
    4. Theme integration: `grep -n "theme\|NeXTSTEP\|Modern" src/components/ConflictResolutionModal.tsx`
  </verify>
  <how-to-verify>
    1. Start the application: `npm run dev`
    2. Navigate to notebook interface
    3. Open browser dev tools and trigger a simulated conflict:
       ```javascript
       // In console, simulate conflict detection
       window.testConflictResolution({
         type: 'field_conflict',
         fieldName: 'content',
         serverValue: 'Original content from server',
         clientValue: 'Modified content on client',
         recordId: 'test_node_001'
       });
       ```
    4. Verify ConflictResolutionModal appears with side-by-side diff
    5. Test resolution controls: "Keep Left", "Keep Right", "Edit Manually"
    6. Confirm visual highlighting for conflicted vs auto-merged sections
    7. Test responsive behavior on mobile viewport
    8. Verify theme consistency with rest of application
    9. Test auto-resolution notification (subtle toast message)
  </how-to-verify>
  <resume-signal>Type "approved" when conflict resolution UI works correctly or describe issues found</resume-signal>
  <done>ConflictResolutionModal provides side-by-side diff interface with visual conflict highlighting, useConflictResolution manages resolution state with bridge coordination and user notifications</done>
</task>

</tasks>

<verification>
## Multi-Device Conflict Resolution Validation

1. **Conflict Detection Test**:
   ```bash
   # Verify CloudKit integration and Swift compilation
   cd native && swift build

   # Check conflict detection integration
   grep -n "detectConflicts\|CloudKit" native/Sources/Isometry/Sync/ConflictDetectionService.swift
   ```

2. **Rollback Performance Test**:
   ```bash
   # Verify rollback timing requirements
   grep -n "50ms\|millisecond" native/Sources/Isometry/Database/RollbackManager.swift

   # Check state cleanup implementation
   grep -n "cleanupTransactionState\|preserveValidState" native/Sources/Isometry/Database/RollbackManager.swift
   ```

3. **UI Integration Test** (Checkpoint Task 3):
   - Manual verification of conflict resolution interface
   - Side-by-side diff functionality
   - Resolution controls and visual feedback
   - Mobile responsiveness and theme integration
</verification>

<success_criteria>
1. **Multi-Device Conflict Handling**: Conflicts from simultaneous editing resolve with appropriate user control and automatic resolution where possible
2. **Fast Rollback Performance**: Failed transactions rollback completely within 50ms without leaving partial state or corruption
3. **Intelligent Conflict Detection**: Session-aware monitoring adapts frequency based on editing activity (2s active, 30s idle)
4. **Intuitive Resolution Interface**: Side-by-side diff modal provides familiar git merge tool experience with visual conflict highlighting
5. **Smart Preservation**: Valid portions of failed transactions saved as drafts for user recovery, with automatic cleanup after successful resubmission
6. **Subtle User Feedback**: Auto-resolved conflicts show brief notifications, rollback events provide clear explanatory messages
</success_criteria>

<output>
After completion, create `.planning/phases/20-transaction-and-sync-management/20-02-SUMMARY.md`
</output>