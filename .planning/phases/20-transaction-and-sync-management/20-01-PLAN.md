---
phase: 20-transaction-and-sync-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [
  native/Sources/Isometry/Bridge/Transaction/TransactionBridge.swift,
  native/Sources/Isometry/Database/TransactionCoordinator.swift,
  src/hooks/useTransaction.ts,
  src/utils/transaction/correlation-ids.ts,
  src/utils/transaction/transaction-scope.ts
]
autonomous: true

must_haves:
  truths:
    - "Multi-step operations complete atomically or rollback entirely with ACID guarantees"
    - "React components can group multiple operations into single database transactions"
    - "Every bridge operation has correlation ID for debugging and transaction tracking"
  artifacts:
    - path: "src/hooks/useTransaction.ts"
      provides: "Hook-based transaction API with Promise support"
      exports: ["useTransaction"]
    - path: "native/Sources/Isometry/Bridge/Transaction/TransactionBridge.swift"
      provides: "Bridge-level transaction coordination"
      exports: ["beginTransaction", "commitTransaction", "rollbackTransaction"]
    - path: "src/utils/transaction/correlation-ids.ts"
      provides: "Hierarchical correlation ID generation"
      exports: ["generateCorrelationId", "createChildId"]
  key_links:
    - from: "src/hooks/useTransaction.ts"
      to: "TransactionBridge.swift"
      via: "webview bridge transaction messages"
      pattern: "bridgeMessage.*transaction"
    - from: "TransactionBridge.swift"
      to: "IsometryDatabase.swift"
      via: "GRDB transaction coordination"
      pattern: "database\\.write"
---

<objective>
Implement ACID transaction safety across React-to-Native bridge boundaries with hierarchical correlation tracking

Purpose: Enable multi-step operations to span React and Native layers while maintaining data integrity and providing debugging visibility through correlation IDs
Output: Production-ready transaction coordination infrastructure with hook-based React API
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-bridge-optimization-foundation/18-03-SUMMARY.md
@.planning/phases/19-real-time-change-notifications/19-01-SUMMARY.md

# Phase-specific research and decisions
@.planning/phases/20-transaction-and-sync-management/20-CONTEXT.md
@.planning/phases/20-transaction-and-sync-management/20-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Bridge-level transaction coordination infrastructure</name>
  <files>
    native/Sources/Isometry/Bridge/Transaction/TransactionBridge.swift
    native/Sources/Isometry/Database/TransactionCoordinator.swift
  </files>
  <action>
    Create TransactionBridge actor that coordinates GRDB transactions across WebView boundary:

    1. **TransactionBridge.swift**: Actor managing bridge-level transaction state
       - `beginTransaction(correlationId: String) async throws -> String` - starts GRDB write transaction, returns transaction ID
       - `commitTransaction(transactionId: String) async throws` - commits active transaction with validation
       - `rollbackTransaction(transactionId: String) async throws` - rolls back transaction with cleanup
       - `executeInTransaction<T>(correlationId: String, operation: @escaping () async throws -> T) async throws -> T` - atomic execution wrapper
       - Integrate with existing MessageBatcher for <16ms response times (reuse Phase 18 optimization)
       - Use correlation IDs for debugging and transaction relationship tracking

    2. **TransactionCoordinator.swift**: GRDB transaction management layer
       - Wraps IsometryDatabase write operations with transaction scoping
       - Implements flat transaction nesting (nested calls join existing transaction, no savepoints per research)
       - Handles SQLite IMMEDIATE transactions to avoid deadlocks (research pitfall prevention)
       - Integrates with ChangeNotificationBridge for transaction-aware change events
       - Transaction timeout handling (max 30 seconds before automatic rollback)

    Reference existing Phase 18 MessageBatcher and Phase 19 ChangeNotificationBridge patterns. Use BEGIN IMMEDIATE for all write transactions to prevent SQLite deadlocks. Implement proper Actor isolation for thread safety.
  </action>
  <verify>
    1. Run `swift build` in native directory - compiles without errors
    2. Verify TransactionBridge actor methods exist: `grep -n "func beginTransaction\|func commitTransaction\|func rollbackTransaction" native/Sources/Isometry/Bridge/Transaction/TransactionBridge.swift`
    3. Check GRDB integration: `grep -n "database\.write\|BEGIN IMMEDIATE" native/Sources/Isometry/Database/TransactionCoordinator.swift`
  </verify>
  <done>TransactionBridge actor provides async transaction coordination methods, TransactionCoordinator wraps GRDB operations with proper transaction scoping and deadlock prevention</done>
</task>

<task type="auto">
  <name>Task 2: React transaction hook and correlation ID system</name>
  <files>
    src/hooks/useTransaction.ts
    src/utils/transaction/correlation-ids.ts
    src/utils/transaction/transaction-scope.ts
  </files>
  <action>
    Implement React-side transaction coordination with hierarchical correlation tracking:

    1. **correlation-ids.ts**: Hierarchical ID generation system
       - `generateCorrelationId(): string` - creates parent transaction ID (format: tx_abc123)
       - `createChildId(parentId: string, sequence: number): string` - creates child operation ID (format: tx_abc123.001)
       - Use nanoid for unique short IDs, sequence tracking for child operations
       - Export correlation ID parsing utilities for debugging

    2. **transaction-scope.ts**: Transaction boundary management
       - `TransactionScope` class managing transaction state and correlation
       - Stack-based nesting detection (flat nesting per research - join existing transaction)
       - Bridge message coordination with correlation ID headers
       - Error boundary handling with automatic rollback on exceptions

    3. **useTransaction.ts**: Hook-based transaction API
       - `const { execute, isActive, correlationId } = useTransaction()`
       - `execute<T>(operation: (tx: TransactionScope) => Promise<T>): Promise<T>` - main transaction execution method
       - Promise-based API matching React async patterns per research
       - Automatic correlation ID generation and child ID sequencing
       - Integration with existing webview-bridge.ts for message passing
       - Flat nesting behavior: nested useTransaction calls join current transaction

    Use existing webview-bridge infrastructure. Follow research Pattern 1 (Hook-Based Transaction Coordination) and Pattern 2 (Flat Transaction Nesting). Ensure Promise-based API for natural React integration.
  </action>
  <verify>
    1. TypeScript compilation: `npm run type-check` passes without errors
    2. Check hook export: `grep -n "export.*useTransaction" src/hooks/useTransaction.ts`
    3. Verify correlation ID format: `grep -n "tx_.*\\.0" src/utils/transaction/correlation-ids.ts`
    4. Bridge integration: `grep -n "bridgeMessage.*transaction" src/hooks/useTransaction.ts`
  </verify>
  <done>useTransaction hook provides Promise-based transaction API, correlation ID system generates hierarchical tracking IDs, transaction scope manages bridge coordination with flat nesting behavior</done>
</task>

<task type="auto">
  <name>Task 3: WebView bridge integration and transaction message routing</name>
  <files>
    src/utils/webview-bridge.ts
    native/Sources/Isometry/App/WebViewBridge.swift
  </files>
  <action>
    Integrate transaction coordination into existing WebView bridge infrastructure:

    1. **webview-bridge.ts** updates:
       - Add "transaction" message type to existing BridgeMessageType enum
       - `sendTransactionMessage(method: string, params: any, correlationId: string): Promise<any>` - transaction-specific messaging
       - Extend existing message handler to route transaction operations to TransactionBridge
       - Add correlation ID to all transaction bridge messages for debugging
       - Integrate with existing error handling and timeout logic from Phase 18

    2. **WebViewBridge.swift** updates:
       - Add transaction message routing to existing handleMessage method
       - Route transaction operations to TransactionBridge actor: beginTransaction, commitTransaction, rollbackTransaction
       - Pass correlation IDs through message headers for debugging visibility
       - Maintain existing MessageBatcher integration for <16ms response optimization

    Build on existing bridge infrastructure from Phase 18. Reuse MessageBatcher, BinarySerializer, and error handling patterns. Add transaction-specific routing without disrupting existing functionality.
  </action>
  <verify>
    1. Swift compilation: `swift build` in native directory succeeds
    2. TypeScript compilation: `npm run type-check` passes
    3. Bridge message routing: `grep -n "transaction.*handleMessage\|TransactionBridge" native/Sources/Isometry/App/WebViewBridge.swift`
    4. React bridge integration: `grep -n "sendTransactionMessage\|BridgeMessageType" src/utils/webview-bridge.ts`
  </verify>
  <done>WebView bridge routes transaction messages between React and Swift layers, transaction operations use existing optimized bridge infrastructure with correlation ID tracking</done>
</task>

</tasks>

<verification>
## Transaction Coordination Validation

1. **Bridge Communication Test**:
   ```bash
   # Verify Swift compilation and bridge integration
   cd native && swift build

   # Check React TypeScript compilation
   npm run type-check
   ```

2. **Correlation ID System Test**:
   ```typescript
   // Test hierarchical ID generation
   const parentId = generateCorrelationId(); // tx_abc123
   const childId = createChildId(parentId, 1); // tx_abc123.001
   ```

3. **Transaction API Test**:
   ```typescript
   // Test hook-based transaction execution
   const { execute } = useTransaction();
   await execute(async (tx) => {
     // Multi-step operation with ACID guarantees
   });
   ```
</verification>

<success_criteria>
1. **ACID Transaction Support**: Multi-step operations spanning React and Native complete atomically or rollback entirely
2. **Bridge-Level Coordination**: TransactionBridge actor coordinates GRDB transactions across WebView boundary
3. **Hierarchical Correlation**: Every transaction and child operation has unique correlation ID for debugging
4. **Hook-Based API**: useTransaction hook provides Promise-based transaction execution matching React patterns
5. **Flat Nesting Behavior**: Nested transaction calls join existing transaction instead of creating savepoints
6. **Performance Integration**: Transaction messages use existing Phase 18 MessageBatcher optimization for <16ms response times
</success_criteria>

<output>
After completion, create `.planning/phases/20-transaction-and-sync-management/20-01-SUMMARY.md`
</output>