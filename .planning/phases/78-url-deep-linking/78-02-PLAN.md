---
phase: 78-url-deep-linking
plan: 02
type: execute
wave: 1
depends_on: [78-01]
files_modified:
  - src/App.tsx
  - src/state/FilterContext.tsx
  - src/utils/url-serialization.ts
  - src/hooks/useNodeDeepLink.ts
autonomous: true

must_haves:
  truths:
    - "URL ?nodeId=xyz opens that specific node"
    - "Filter state persists to URL query params"
    - "Sharing URL preserves filter configuration"
  artifacts:
    - path: "src/hooks/useNodeDeepLink.ts"
      provides: "Node deep linking hook"
    - path: "src/utils/url-serialization.ts"
      provides: "Filter state serialization utilities"
---

<objective>
Implement URL deep linking for nodes and filter state persistence.

Purpose: Enable sharing URLs that open specific nodes and preserve filter configurations. This is P1 because it enables collaboration and bookmarking.

Output: ?nodeId= support and filter state in URL.
</objective>

<context>
@.planning/milestones/v4.9-data-layer-completion.md
@src/App.tsx
@src/state/FilterContext.tsx
@src/hooks/ui/useURLState.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create URL serialization utilities</name>
  <files>src/utils/url-serialization.ts</files>
  <action>
Create filter state serialization:

```typescript
import { FilterState } from '../state/FilterContext';

/**
 * Serialize filter state to URL-safe string
 */
export function serializeFilters(filters: FilterState): string {
  const params: Record<string, string> = {};
  
  if (filters.folder) params.folder = filters.folder;
  if (filters.tags?.length) params.tags = filters.tags.join(',');
  if (filters.status) params.status = filters.status;
  if (filters.priority !== undefined) params.priority = String(filters.priority);
  if (filters.search) params.search = filters.search;
  if (filters.dateRange) {
    params.dateFrom = filters.dateRange.from;
    params.dateTo = filters.dateRange.to;
  }
  
  return new URLSearchParams(params).toString();
}

/**
 * Deserialize URL params to filter state
 */
export function deserializeFilters(searchParams: URLSearchParams): Partial<FilterState> {
  const filters: Partial<FilterState> = {};
  
  const folder = searchParams.get('folder');
  if (folder) filters.folder = folder;
  
  const tags = searchParams.get('tags');
  if (tags) filters.tags = tags.split(',').filter(Boolean);
  
  const status = searchParams.get('status');
  if (status) filters.status = status;
  
  const priority = searchParams.get('priority');
  if (priority) filters.priority = parseInt(priority, 10);
  
  const search = searchParams.get('search');
  if (search) filters.search = search;
  
  const dateFrom = searchParams.get('dateFrom');
  const dateTo = searchParams.get('dateTo');
  if (dateFrom && dateTo) {
    filters.dateRange = { from: dateFrom, to: dateTo };
  }
  
  return filters;
}

/**
 * Get node ID from URL
 */
export function getNodeIdFromURL(): string | null {
  const params = new URLSearchParams(window.location.search);
  return params.get('nodeId');
}

/**
 * Set node ID in URL without page reload
 */
export function setNodeIdInURL(nodeId: string | null): void {
  const url = new URL(window.location.href);
  if (nodeId) {
    url.searchParams.set('nodeId', nodeId);
  } else {
    url.searchParams.delete('nodeId');
  }
  window.history.replaceState({}, '', url.toString());
}
```
  </action>
  <verify>TypeScript compiles without errors</verify>
  <done>URL serialization utilities created</done>
</task>

<task type="auto">
  <name>Task 2: Create useNodeDeepLink hook</name>
  <files>src/hooks/useNodeDeepLink.ts</files>
  <action>
Create hook for node deep linking:

```typescript
import { useEffect, useCallback } from 'react';
import { getNodeIdFromURL, setNodeIdInURL } from '../utils/url-serialization';

interface UseNodeDeepLinkOptions {
  onNodeId?: (nodeId: string) => void;
}

/**
 * Hook for managing node deep links via URL
 * 
 * Usage:
 * ```tsx
 * const { nodeId, setNodeId, clearNodeId } = useNodeDeepLink({
 *   onNodeId: (id) => selectNode(id)
 * });
 * ```
 */
export function useNodeDeepLink(options: UseNodeDeepLinkOptions = {}) {
  const { onNodeId } = options;

  // Check URL on mount
  useEffect(() => {
    const nodeId = getNodeIdFromURL();
    if (nodeId && onNodeId) {
      onNodeId(nodeId);
    }
  }, [onNodeId]);

  // Listen for popstate (back/forward)
  useEffect(() => {
    const handlePopState = () => {
      const nodeId = getNodeIdFromURL();
      if (nodeId && onNodeId) {
        onNodeId(nodeId);
      }
    };

    window.addEventListener('popstate', handlePopState);
    return () => window.removeEventListener('popstate', handlePopState);
  }, [onNodeId]);

  const setNodeId = useCallback((nodeId: string) => {
    setNodeIdInURL(nodeId);
  }, []);

  const clearNodeId = useCallback(() => {
    setNodeIdInURL(null);
  }, []);

  return {
    nodeId: getNodeIdFromURL(),
    setNodeId,
    clearNodeId,
  };
}

export default useNodeDeepLink;
```
  </action>
  <verify>Hook exports correctly</verify>
  <done>Node deep linking hook created</done>
</task>

<task type="auto">
  <name>Task 3: Wire filter state to URL in FilterContext</name>
  <files>src/state/FilterContext.tsx</files>
  <action>
Update FilterContext to persist filters to URL:

1. Import serialization utilities
2. Initialize state from URL on mount
3. Update URL when filters change

Key changes:
```typescript
import { serializeFilters, deserializeFilters } from '../utils/url-serialization';

// In FilterProvider:
const [filters, setFiltersInternal] = useState<FilterState>(() => {
  // Initialize from URL
  const params = new URLSearchParams(window.location.search);
  const urlFilters = deserializeFilters(params);
  return { ...defaultFilters, ...urlFilters };
});

// Wrap setFilters to also update URL
const setFilters = useCallback((newFilters: FilterState) => {
  setFiltersInternal(newFilters);
  
  // Update URL without reload
  const url = new URL(window.location.href);
  const filterParams = serializeFilters(newFilters);
  const newParams = new URLSearchParams(filterParams);
  
  // Preserve existing non-filter params (test, nodeId, etc.)
  const preserveParams = ['test', 'nodeId', 'reset'];
  preserveParams.forEach(key => {
    const val = url.searchParams.get(key);
    if (val) newParams.set(key, val);
  });
  
  url.search = newParams.toString();
  window.history.replaceState({}, '', url.toString());
}, []);
```
  </action>
  <verify>Filters persist in URL</verify>
  <done>FilterContext wired to URL</done>
</task>

<task type="auto">
  <name>Task 4: Wire node deep link to App.tsx</name>
  <files>src/App.tsx</files>
  <action>
Add node deep link handling to App:

```typescript
import { useNodeDeepLink } from './hooks/useNodeDeepLink';
import { useSelection } from './state/SelectionContext'; // or similar

function App() {
  const { selectNode, scrollToNode } = useSelection();
  
  // Handle deep link to specific node
  useNodeDeepLink({
    onNodeId: (nodeId) => {
      // Select the node
      selectNode(nodeId);
      // Scroll to it in the grid
      scrollToNode?.(nodeId);
    }
  });
  
  // ... rest of App
}
```

Also add nodeId to the test mode routing so it works in development.
  </action>
  <verify>?nodeId=xxx opens that node</verify>
  <done>App handles node deep links</done>
</task>

</tasks>

<verification>
1. Open URL with `?folder=work` - filter is applied
2. Change filter in UI - URL updates
3. Open URL with `?nodeId=card-1` - node is selected
4. Back button restores previous filter state
</verification>

<success_criteria>
- URL-01: Node deep linking via ?nodeId= ✅
- URL-02: Filter state serialization to URL ✅
- PAFV state + filter state + nodeId all coexist in URL
</success_criteria>
