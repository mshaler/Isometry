---
phase: 07.2-webview-bridge
plan: 02
type: execute
wave: 2
depends_on: ["07.2-01"]
files_modified: [
  "src/db/WebViewDatabaseContext.tsx",
  "src/db/WebViewClient.ts",
  "src/utils/webview-bridge.ts",
  "native/Sources/Isometry/WebView/DatabaseMessageHandler.swift"
]
autonomous: true

must_haves:
  truths:
    - "Database operations route securely through WebView MessageHandler"
    - "Request/response correlation works reliably with unique IDs"
    - "Error handling maintains consistency across WebView bridge"
    - "Performance equals or exceeds HTTP API for database operations"
    - "React components work identically in WebView and browser environments"
  artifacts:
    - path: "src/utils/webview-bridge.ts"
      provides: "WebView communication layer with promise support"
      min_lines: 120
      exports: ["WebViewBridge", "isWebViewEnvironment", "postMessage"]
    - path: "src/db/WebViewClient.ts"
      provides: "Database client using WebView bridge transport"
      min_lines: 100
      exports: ["WebViewClient", "createWebViewClient"]
    - path: "native/Sources/Isometry/WebView/DatabaseMessageHandler.swift"
      provides: "Enhanced MessageHandler with async/await support"
      min_lines: 150
      contains: ["DatabaseMessageHandler", "handleDatabaseMessage"]
  key_links:
    - from: "React WebViewClient.execute()"
      to: "webkit.messageHandlers.database"
      via: "postMessage with request ID"
      pattern: "webkit\\.messageHandlers\\.database\\.postMessage.*id.*sql"
    - from: "DatabaseMessageHandler.userContentController"
      to: "IsometryDatabase actor"
      via: "async await database operations"
      pattern: "await database\\.(execute|createNode)"
    - from: "WebView bridge response"
      to: "React promise resolution"
      via: "callback lookup and resolution"
      pattern: "resolveCallback.*requestId.*result"
---

<objective>
Implement secure API routing through native MessageHandler bridge, replacing HTTP transport with WebView messaging while maintaining identical React component interfaces.

Purpose: Enable React prototype to use native database directly through WebView bridge for better security, performance, and App Sandbox compliance.

Output: Complete WebView bridge implementation providing seamless database access for React components running in native WKWebView.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07.2-webview-bridge/07.2-01-PLAN.md
@src/db/NativeAPIClient.ts
@src/db/NativeDatabaseContext.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WebView bridge communication layer</name>
  <files>
    src/utils/webview-bridge.ts
  </files>
  <action>
    Create webview-bridge.ts for secure React-to-native communication:

    Export WebViewBridge class with core messaging functionality:
    - postMessage(handler: string, method: string, params: unknown): Promise<T>
    - generateRequestId(): string (UUID for request correlation)
    - registerCallback(id: string, resolve: Function, reject: Function): void
    - handleResponse(id: string, result: unknown, error?: Error): void
    - cleanup(): void (remove pending callbacks)

    Environment detection:
    - Export isWebViewEnvironment(): boolean
    - Check for webkit.messageHandlers availability
    - Validate specific handler availability (database, filesystem)
    - Provide graceful fallback detection
    - Handle incomplete WebView implementations

    Message protocol implementation:
    ```typescript
    interface WebViewMessage {
      id: string;
      handler: 'database' | 'filesystem';
      method: string;
      params: Record<string, unknown>;
      timestamp: number;
    }

    interface WebViewResponse {
      id: string;
      result?: unknown;
      error?: string;
      success: boolean;
    }
    ```

    Promise-based communication:
    - Handle async request/response correlation
    - Support timeout for failed requests (default 10 seconds)
    - Manage concurrent requests with unique IDs
    - Provide error handling for bridge failures
    - Include retry logic for transient failures

    Development debugging support:
    - Log all bridge communications in dev mode
    - Provide bridge health checking
    - Export debug information for troubleshooting
    - Handle malformed responses gracefully

    Include comprehensive TypeScript types for all message formats and ensure type safety.
  </action>
  <verify>
    WebView environment detection works correctly
    Bridge can send messages and receive responses with proper correlation
    Error handling works for failed or timeout scenarios
  </verify>
  <done>
    WebView bridge provides reliable promise-based communication between React and native app with comprehensive error handling
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement WebView database client</name>
  <files>
    src/db/WebViewClient.ts
    src/db/WebViewDatabaseContext.tsx
  </files>
  <action>
    Create WebViewClient.ts implementing database operations through bridge:

    Export WebViewClient class with DatabaseContextValue interface:
    - execute<T>(sql: string, params?: unknown[]): Promise<T[]>
    - save(): Promise<void> (no-op for compatibility)
    - reset(): Promise<void>
    - isConnected(): boolean
    - getConnectionStatus(): ConnectionStatus

    Database operation implementation:
    - execute(): Route through 'database' handler with 'execute' method
    - Include SQL injection prevention and parameter binding
    - Handle result format translation (native to sql.js format)
    - Support both SELECT and INSERT/UPDATE/DELETE operations
    - Maintain exact same response structure as sql.js

    Connection management:
    - Test WebView bridge availability on initialization
    - Handle bridge connectivity issues gracefully
    - Provide connection status monitoring
    - Support reconnection attempts if bridge fails
    - Cache connection state for performance

    Create WebViewDatabaseContext.tsx:
    - Mirror exact interface of existing DatabaseContext
    - Use WebViewClient instead of sql.js Database
    - Handle WebView-specific initialization patterns
    - Provide same loading/error state management
    - Export useWebViewDatabase() hook with identical interface

    Error handling and compatibility:
    - Map WebView errors to DatabaseContext error types
    - Handle bridge unavailability with meaningful errors
    - Provide fallback messaging for development
    - Maintain backward compatibility with existing hooks
    - Include comprehensive logging for debugging

    Export createWebViewClient() factory with configuration options.
  </action>
  <verify>
    WebViewClient provides identical interface to NativeAPIClient
    Database operations work correctly through WebView bridge
    Context hook maintains same interface as existing DatabaseContext
  </verify>
  <done>
    WebView database client provides identical interface to HTTP API client while using WebView bridge for secure native communication
  </done>
</task>

<task type="auto">
  <name>Task 3: Enhance native MessageHandler with async database operations</name>
  <files>
    native/Sources/Isometry/WebView/DatabaseMessageHandler.swift
  </files>
  <action>
    Create comprehensive DatabaseMessageHandler.swift for secure database access:

    Export DatabaseMessageHandler class conforming to WKScriptMessageHandler:
    - userContentController(_:didReceive:) main entry point
    - handleDatabaseMessage(_:) for message parsing and routing
    - executeSQL(_:params:) for raw SQL execution
    - handleOptimizedQueries(_:) for common operations
    - sendResponse(to:result:error:) for result delivery

    Message handling and validation:
    - Parse JSON messages with comprehensive error handling
    - Validate required fields (id, method, params)
    - Sanitize SQL queries and parameters
    - Prevent malicious or malformed requests
    - Log all operations for security auditing

    Database operation routing:
    - execute: Route to database.read() for SELECT queries
    - execute: Route to database.write() for INSERT/UPDATE/DELETE
    - getNodes: Use optimized database.getAllNodes()
    - createNode: Use database.createNode() with validation
    - searchNodes: Use database.searchNodes() for FTS5
    - All operations support async/await patterns

    Response delivery to WebView:
    ```swift
    func sendResponse(to webView: WKWebView, id: String, result: Any?, error: Error?) {
        let response = [
            "id": id,
            "result": result,
            "error": error?.localizedDescription,
            "success": error == nil
        ]
        let script = "window.resolveWebViewRequest('\(id)', \(jsonString))"
        webView.evaluateJavaScript(script)
    }
    ```

    Security and performance:
    - Validate all database operations for safety
    - Prevent unauthorized access patterns
    - Handle database errors gracefully
    - Maintain actor isolation for database access
    - Include performance timing and monitoring

    Include proper error handling for all database operations and WebView communication failures.
  </action>
  <verify>
    MessageHandler successfully receives and processes database requests
    Database operations work correctly with async/await patterns
    Responses are delivered back to WebView with proper correlation
  </verify>
  <done>
    Native MessageHandler provides secure and performant database access for WebView with comprehensive validation and error handling
  </done>
</task>

</tasks>

<verification>
1. WebView bridge enables secure communication between React and native services
2. Database operations work identically through bridge vs HTTP API
3. Request/response correlation handles concurrent operations reliably
4. Performance equals or exceeds HTTP transport for typical operations
5. Error handling maintains consistency across WebView and HTTP implementations
</verification>

<success_criteria>
- [ ] WebView bridge provides reliable promise-based communication
- [ ] Database operations work securely through MessageHandler
- [ ] React components require zero changes when using WebView bridge
- [ ] Performance matches or exceeds HTTP API for database operations
- [ ] Error handling and edge cases work consistently across transports
</success_criteria>

<output>
After completion, create `.planning/phases/07.2-webview-bridge/07.2-02-SUMMARY.md`
</output>