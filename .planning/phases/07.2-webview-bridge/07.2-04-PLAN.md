---
phase: 07.2-webview-bridge
plan: 04
type: execute
wave: 4
depends_on: ["07.2-03"]
files_modified: [
  "src/db/DatabaseContext.tsx",
  "src/contexts/EnvironmentContext.tsx",
  "src/utils/sync-manager.ts",
  "native/Sources/Isometry/WebView/SyncCoordinator.swift"
]
autonomous: true

must_haves:
  truths:
    - "Real-time data sync maintains consistency between native and WebView"
    - "Conflict resolution handles concurrent edits properly"
    - "Performance monitoring shows native-equivalent response times"
    - "Data integrity is preserved during WebView bridge operations"
    - "Sync state is consistent across all application views"
  artifacts:
    - path: "src/contexts/EnvironmentContext.tsx"
      provides: "Environment detection and provider selection"
      min_lines: 80
      exports: ["EnvironmentProvider", "useEnvironment", "DatabaseMode"]
    - path: "src/utils/sync-manager.ts"
      provides: "Real-time sync coordination for WebView bridge"
      min_lines: 120
      exports: ["SyncManager", "startSync", "handleConflict"]
    - path: "native/Sources/Isometry/WebView/SyncCoordinator.swift"
      provides: "Native sync coordination with WebView"
      min_lines: 100
      exports: ["SyncCoordinator", "notifyWebViewOfChanges"]
  key_links:
    - from: "React SyncManager"
      to: "webkit.messageHandlers.sync"
      via: "real-time sync notifications"
      pattern: "webkit\\.messageHandlers\\.sync\\.postMessage.*changes"
    - from: "Native SyncCoordinator"
      to: "WebView JavaScript"
      via: "evaluateJavaScript for change notifications"
      pattern: "webView\\.evaluateJavaScript.*syncUpdate"
    - from: "DatabaseContext"
      to: "EnvironmentContext"
      via: "automatic provider selection"
      pattern: "useEnvironment.*databaseMode.*provider"
---

<objective>
Implement real-time sync and conflict resolution between React WebView and native app, ensuring data consistency and optimal performance across all views.

Purpose: Complete WebView bridge integration with production-ready sync capabilities that maintain data integrity while providing seamless user experience.

Output: Comprehensive sync system that handles real-time updates, conflict resolution, and performance optimization for WebView bridge architecture.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07.2-webview-bridge/07.2-03-PLAN.md
@src/db/WebViewDatabaseContext.tsx
@src/utils/webview-bridge.ts
@native/Sources/Isometry/Database/IsometryDatabase.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create environment detection and provider selection system</name>
  <files>
    src/contexts/EnvironmentContext.tsx
    src/db/DatabaseContext.tsx
  </files>
  <action>
    Create EnvironmentContext.tsx for comprehensive environment detection:

    Export DatabaseMode enum:
    - SQLJS: Original sql.js browser implementation
    - HTTP_API: Native HTTP API bridge
    - WEBVIEW_BRIDGE: WebView MessageHandler bridge
    - AUTO: Automatic detection and selection

    Export EnvironmentProvider component:
    - Detect runtime environment (browser vs WebView vs app)
    - Test available communication channels (HTTP, MessageHandlers)
    - Handle feature detection and capability testing
    - Provide fallback chain: WebView -> HTTP -> sql.js
    - Support forced mode override for testing

    Environment detection logic:
    ```typescript
    function detectEnvironment(): DatabaseMode {
      // Check for WebView MessageHandlers
      if (window.webkit?.messageHandlers?.database) {
        return DatabaseMode.WEBVIEW_BRIDGE;
      }

      // Check for HTTP API availability
      if (await testHTTPAPIConnection()) {
        return DatabaseMode.HTTP_API;
      }

      // Fall back to sql.js
      return DatabaseMode.SQLJS;
    }
    ```

    Export useEnvironment() hook:
    - Return current database mode and capabilities
    - Provide mode switching for development
    - Handle environment changes gracefully
    - Include performance characteristics for each mode

    Update DatabaseContext.tsx:
    - Use EnvironmentContext for automatic provider selection
    - Support all three database modes seamlessly
    - Handle provider switching without breaking state
    - Maintain backward compatibility with existing code
    - Include environment-specific optimizations

    Provider selection priority:
    1. WebView bridge (when available and functional)
    2. HTTP API (when WebView unavailable)
    3. sql.js (fallback for browser environments)

    Include comprehensive error handling and graceful degradation.
  </action>
  <verify>
    Environment detection correctly identifies WebView vs browser vs HTTP API
    Provider selection works automatically with proper fallbacks
    Components work identically regardless of selected provider
  </verify>
  <done>
    Environment context provides automatic database provider selection with intelligent fallback chain and seamless component compatibility
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement real-time sync coordination</name>
  <files>
    src/utils/sync-manager.ts
    native/Sources/Isometry/WebView/SyncCoordinator.swift
  </files>
  <action>
    Create sync-manager.ts for React-side sync coordination:

    Export SyncManager class with real-time capabilities:
    - startSync(): Initialize sync connection and handlers
    - stopSync(): Clean up sync resources
    - handleRemoteChange(change: DataChange): Process incoming changes
    - publishLocalChange(change: DataChange): Send changes to native
    - resolveConflict(conflict: SyncConflict): Handle merge conflicts

    Sync protocol implementation:
    ```typescript
    interface DataChange {
      id: string;
      table: 'nodes' | 'notebook_cards';
      operation: 'create' | 'update' | 'delete';
      data: Record<string, unknown>;
      timestamp: number;
      version: number;
    }

    interface SyncConflict {
      id: string;
      localChange: DataChange;
      remoteChange: DataChange;
      resolutionStrategy: 'local_wins' | 'remote_wins' | 'merge';
    }
    ```

    Real-time sync features:
    - Use WebView bridge for bidirectional change notifications
    - Handle concurrent edits with version-based conflict resolution
    - Support optimistic updates with rollback on conflict
    - Provide offline queue for failed sync attempts
    - Include change debouncing for performance

    Create SyncCoordinator.swift for native-side coordination:
    - Monitor database changes through GRDB observation
    - Notify WebView of changes via evaluateJavaScript
    - Handle sync conflicts with last-writer-wins + timestamps
    - Support sync pause/resume for performance
    - Include CloudKit integration for multi-device sync

    Conflict resolution strategies:
    - Timestamp-based resolution (newer wins)
    - User preference resolution (prompt for choice)
    - Field-level merging for compatible changes
    - Automatic rollback for incompatible changes
    - Audit trail for conflict resolutions

    Performance optimizations:
    - Batch change notifications to reduce overhead
    - Use incremental sync with change sets
    - Implement sync throttling during heavy operations
    - Support sync priority levels (critical vs background)
    - Include network-aware sync scheduling

    Include comprehensive error handling and recovery mechanisms.
  </action>
  <verify>
    Real-time sync correctly propagates changes between WebView and native
    Conflict resolution handles concurrent edits without data loss
    Performance remains responsive during active sync operations
  </verify>
  <done>
    Real-time sync system maintains data consistency across WebView and native views with comprehensive conflict resolution
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement performance monitoring and validation</name>
  <files>
    src/db/PerformanceMonitor.ts
    src/utils/bridge-performance.ts
    native/Sources/Isometry/Performance/BridgePerformanceMonitor.swift
  </files>
  <action>
    Update PerformanceMonitor.ts for WebView bridge validation:

    Add WebView-specific performance tracking:
    - measureBridgeLatency(): Test round-trip message timing
    - compareBridgeVsHTTP(): Performance comparison between transports
    - trackSyncPerformance(): Monitor real-time sync overhead
    - validateDataIntegrity(): Ensure bridge operations maintain consistency
    - generatePerformanceReport(): Comprehensive performance analysis

    Bridge performance metrics:
    - Message round-trip time (WebView to native and back)
    - Database operation throughput (ops/second)
    - Sync latency (change notification to UI update)
    - Memory usage during bridge operations
    - CPU impact of message passing

    Create bridge-performance.ts for specialized testing:
    - Export bridgePerformanceTest(): Comprehensive bridge testing
    - Test large data transfers through bridge
    - Measure concurrent operation handling
    - Validate error recovery performance
    - Include stress testing for reliability

    Performance validation criteria:
    ```typescript
    interface PerformanceTargets {
      bridgeLatency: number; // < 50ms for round-trip
      databaseOps: number;   // > 100 ops/second
      syncLatency: number;   // < 100ms notification to UI
      memoryOverhead: number; // < 10MB additional
    }
    ```

    Create BridgePerformanceMonitor.swift for native monitoring:
    - Track native-side bridge performance
    - Monitor MessageHandler processing times
    - Measure database operation latencies
    - Include memory and CPU usage tracking
    - Provide performance analytics for optimization

    Integration with development workflow:
    - Performance dashboard in React dev tools
    - Automated performance regression testing
    - Performance alerts for threshold violations
    - Export performance data for analysis
    - Include A/B testing framework for optimizations

    Validation features:
    - Data consistency checks across bridge operations
    - Error rate monitoring and alerting
    - Performance baseline establishment
    - Regression detection and reporting
    - Automated performance improvement suggestions

    Include comprehensive logging and analytics for production monitoring.
  </action>
  <verify>
    Performance monitoring shows WebView bridge meets or exceeds HTTP API performance
    Data integrity validation confirms no corruption during bridge operations
    Performance dashboard provides actionable insights for optimization
  </verify>
  <done>
    Comprehensive performance monitoring validates WebView bridge meets production performance and reliability requirements
  </done>
</task>

</tasks>

<verification>
1. Environment detection automatically selects optimal database provider
2. Real-time sync maintains data consistency across all application views
3. Conflict resolution handles concurrent operations without data loss
4. Performance monitoring validates bridge architecture meets targets
5. Data integrity is preserved throughout all WebView bridge operations
</verification>

<success_criteria>
- [ ] Environment context provides seamless provider selection and fallbacks
- [ ] Real-time sync maintains consistency between WebView and native views
- [ ] Conflict resolution handles concurrent edits gracefully
- [ ] Performance monitoring confirms bridge meets or exceeds HTTP API speed
- [ ] Data integrity validation ensures no corruption during bridge operations
</success_criteria>

<output>
After completion, create `.planning/phases/07.2-webview-bridge/07.2-04-SUMMARY.md`
</output>