---
phase: 07.2-webview-bridge
plan: 01
type: execute
wave: 1
depends_on: ["07.1-03"]
files_modified: [
  "native/Sources/Isometry/WebView/NotebookWebView.swift",
  "native/Sources/Isometry/WebView/MessageHandlers.swift",
  "native/Sources/Isometry/WebView/WebViewBridge.swift",
  "native/Sources/Isometry/Views/Notebook/NotebookWebView.swift"
]
autonomous: true

must_haves:
  truths:
    - "React prototype runs inside native WKWebView with full functionality"
    - "WebView communicates securely with native app through MessageHandler"
    - "Database operations route through WebView bridge instead of HTTP server"
    - "File system access respects App Sandbox constraints"
    - "WebView integration maintains responsive UI performance"
  artifacts:
    - path: "native/Sources/Isometry/WebView/NotebookWebView.swift"
      provides: "SwiftUI WKWebView wrapper for React prototype"
      min_lines: 150
      exports: ["NotebookWebView", "loadReactApp"]
    - path: "native/Sources/Isometry/WebView/MessageHandlers.swift"
      provides: "WKScriptMessageHandler implementations"
      min_lines: 200
      contains: ["DatabaseMessageHandler", "FileSystemMessageHandler"]
    - path: "native/Sources/Isometry/WebView/WebViewBridge.swift"
      provides: "Coordinate between WebView and native services"
      min_lines: 100
      exports: ["WebViewBridge", "handleMessage"]
  key_links:
    - from: "React window.webkit.messageHandlers"
      to: "MessageHandlers.swift"
      via: "WKWebView message posting"
      pattern: "webkit\\.messageHandlers\\.database\\.postMessage"
    - from: "DatabaseMessageHandler"
      to: "IsometryDatabase"
      via: "actor method calls"
      pattern: "database\\.(execute|createNode)"
    - from: "NotebookWebView"
      to: "React build artifacts"
      via: "local HTML/JS loading"
      pattern: "loadFileURL.*react.*index\\.html"
---

<objective>
Integrate React prototype into native app using WKWebView with secure MessageHandler bridge for database and file system operations.

Purpose: Replace HTTP API server with direct WebView messaging for better security, performance, and App Sandbox compliance while maintaining React functionality.

Output: Native WKWebView container running React prototype with secure bridge communication replacing HTTP-based API calls.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07.1-api-bridge/07.1-03-PLAN.md
@native/Sources/Isometry/Database/IsometryDatabase.swift
@native/Sources/Isometry/Views/Notebook/NotebookShellView.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WKWebView container for React prototype</name>
  <files>
    native/Sources/Isometry/WebView/NotebookWebView.swift
    native/Sources/Isometry/Views/Notebook/NotebookWebView.swift
  </files>
  <action>
    Create NotebookWebView.swift as SwiftUI wrapper for WKWebView:

    Export NotebookWebView struct conforming to UIViewRepresentable (iOS) / NSViewRepresentable (macOS):
    - Configure WKWebView with proper security settings
    - Enable JavaScript and disable other web features for security
    - Set up MessageHandler registration for database and file operations
    - Handle WebView lifecycle (load, navigation, errors)
    - Support responsive design with proper sizing constraints

    WebView configuration:
    - Enable JavaScript (required for React)
    - Disable external navigation and popups
    - Configure User-Agent for identification
    - Set up local file loading permissions
    - Handle memory management and cleanup

    React app loading:
    - Load React build artifacts from app bundle
    - Handle bundle path resolution correctly
    - Support both development and production builds
    - Manage loading states and error handling
    - Provide fallback for failed loads

    Update Views/Notebook/NotebookWebView.swift to integrate new WebView:
    - Replace existing shell view with WKWebView container
    - Maintain same SwiftUI integration patterns
    - Handle platform differences (iOS vs macOS)
    - Preserve existing navigation and layout behavior
    - Support dark mode and theme changes

    Include proper error handling and logging for WebView operations.
  </action>
  <verify>
    WKWebView loads successfully in native app
    React prototype renders properly within WebView container
    WebView handles responsive design and platform differences correctly
  </verify>
  <done>
    React prototype runs successfully inside native WKWebView with proper security configuration and responsive layout
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement MessageHandler bridge for secure communication</name>
  <files>
    native/Sources/Isometry/WebView/MessageHandlers.swift
    native/Sources/Isometry/WebView/WebViewBridge.swift
  </files>
  <action>
    Create MessageHandlers.swift with WKScriptMessageHandler implementations:

    Export DatabaseMessageHandler class:
    - Implement userContentController(_:didReceive:) for database operations
    - Handle message parsing and validation
    - Route to IsometryDatabase actor methods
    - Return results via JavaScript callback system
    - Include comprehensive error handling

    Export FileSystemMessageHandler class:
    - Handle file read/write operations within App Sandbox
    - Validate file paths for security
    - Support reading React build artifacts and user files
    - Manage temporary file creation for exports
    - Respect App Sandbox container restrictions

    Message format standardization:
    ```javascript
    {
      id: "unique-request-id",
      method: "execute" | "getNodes" | "readFile" | "writeFile",
      params: { sql?: string, params?: unknown[], path?: string, content?: string },
      callback: "callbackFunctionName"
    }
    ```

    Create WebViewBridge.swift for coordination:
    - Manage MessageHandler registration and lifecycle
    - Coordinate between different handlers
    - Provide centralized error handling and logging
    - Handle async operations and callback routing
    - Support future handler additions

    Security considerations:
    - Validate all incoming messages
    - Sanitize file paths and SQL queries
    - Prevent unauthorized file system access
    - Log security-relevant operations
    - Handle malicious or malformed requests safely

    Include TypeScript interface definitions for the React side to ensure type safety.
  </action>
  <verify>
    MessageHandlers successfully receive and process WebView messages
    Database operations work through MessageHandler bridge
    File system operations respect App Sandbox constraints
  </verify>
  <done>
    Secure MessageHandler bridge enables React to communicate with native services while maintaining App Sandbox security
  </done>
</task>

<task type="auto">
  <name>Task 3: Update React to use WebView bridge instead of HTTP API</name>
  <files>
    src/db/WebViewDatabaseContext.tsx
    src/db/WebViewClient.ts
    src/utils/webview-bridge.ts
  </files>
  <action>
    Create webview-bridge.ts for React-side WebView communication:

    Export WebViewBridge class:
    - Detect WebView environment vs browser environment
    - Provide webkit.messageHandlers interface typing
    - Handle message posting and response callbacks
    - Implement request/response correlation with unique IDs
    - Support both promise-based and callback-based usage

    WebView detection and fallback:
    - Check for webkit.messageHandlers availability
    - Fall back to HTTP API when running in browser
    - Provide identical interface regardless of transport
    - Handle environment switching gracefully
    - Log transport method for debugging

    Create WebViewClient.ts implementing database operations:
    - execute(sql, params): Route through database MessageHandler
    - save(): No-op (native handles persistence)
    - reset(): Call native reset through MessageHandler
    - Match exact interface of NativeAPIClient

    Create WebViewDatabaseContext.tsx:
    - Mirror existing DatabaseContext interface exactly
    - Use WebViewClient instead of HTTP client
    - Handle WebView-specific loading and error states
    - Provide same React context patterns
    - Support development mode switching

    Environment-based provider selection:
    - WebView environment: Use WebViewDatabaseContext
    - Browser environment: Use NativeAPIClient or sql.js
    - Handle automatic detection and provider switching
    - Maintain backward compatibility

    Include comprehensive error handling for WebView communication failures and bridge unavailability.
  </action>
  <verify>
    React app detects WebView environment and uses MessageHandler bridge
    Database operations work identically through WebView vs HTTP transport
    Components require no changes when switching between environments
  </verify>
  <done>
    React prototype automatically uses WebView bridge when running in native app while maintaining identical component interfaces
  </done>
</task>

</tasks>

<verification>
1. React prototype loads and functions properly within native WKWebView
2. MessageHandler bridge provides secure communication for database operations
3. File system operations work within App Sandbox constraints
4. Performance matches or exceeds HTTP API approach
5. Components work identically whether running in browser or WebView
</verification>

<success_criteria>
- [ ] React prototype runs seamlessly inside native WKWebView container
- [ ] MessageHandler bridge replaces HTTP API for secure communication
- [ ] Database operations work through WebView bridge with same performance
- [ ] File system access respects App Sandbox security requirements
- [ ] Components require zero changes to work in WebView environment
</success_criteria>

<output>
After completion, create `.planning/phases/07.2-webview-bridge/07.2-01-SUMMARY.md`
</output>