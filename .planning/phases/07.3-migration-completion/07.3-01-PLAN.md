---
phase: 07.3-migration-completion
plan: 01
type: execute
wave: 1
depends_on: ["07.2-04"]
files_modified: [
  "src/test/migration-e2e.test.ts",
  "src/test/performance-regression.test.ts",
  "src/test/data-integrity-validation.test.ts",
  "native/Tests/IsometryTests/MigrationValidationTests.swift",
  "src/utils/migration-validator.ts"
]
autonomous: true

must_haves:
  truths:
    - "End-to-end testing validates React → WebView → Native database flow"
    - "Performance validation confirms targets (60fps, <50ms latency) are met"
    - "Data integrity validation ensures zero corruption across migration path"
    - "Rollback procedure testing provides safe reversion capabilities"
    - "Cross-platform testing validates iOS/macOS compatibility"
  artifacts:
    - path: "src/test/migration-e2e.test.ts"
      provides: "Complete workflow validation across all providers"
      min_lines: 400
      exports: ["testCompleteWorkflow", "testProviderMigration", "testRollbackProcedures"]
    - path: "src/test/performance-regression.test.ts"
      provides: "Performance validation against established targets"
      min_lines: 250
      exports: ["validatePerformanceTargets", "benchmarkMigrationPath"]
    - path: "native/Tests/IsometryTests/MigrationValidationTests.swift"
      provides: "Native migration testing and validation"
      min_lines: 300
      contains: ["MigrationValidationTests", "testDataMigration", "testPerformanceTargets"]
    - path: "src/utils/migration-validator.ts"
      provides: "Migration validation utilities and rollback procedures"
      min_lines: 200
      exports: ["MigrationValidator", "validateMigrationPath", "executeRollback"]
  key_links:
    - from: "E2E migration tests"
      to: "WebView bridge infrastructure from 07.2-04"
      via: "established performance monitoring and sync coordination"
      pattern: "BridgePerformanceMonitor.*SyncCoordinator"
    - from: "Performance regression tests"
      to: "Established targets (<50ms, 60fps, 100 ops/sec)"
      via: "bridge-performance.ts infrastructure"
      pattern: "performanceTargets.*bridge.*latency"
    - from: "Native migration validation"
      to: "WebView MessageHandler security validation"
      via: "SandboxValidator and comprehensive testing"
      pattern: "SandboxValidator.*MessageHandler.*validation"
---

<objective>
Execute comprehensive migration testing and validation for the complete sql.js → native migration path, leveraging established WebView bridge infrastructure and performance monitoring to ensure production readiness.

Purpose: Validate the complete migration architecture with rigorous testing against established performance targets, data integrity requirements, and cross-platform compatibility to provide confidence for production deployment.

Output: Production-ready migration validation suite with automated testing, rollback procedures, and performance benchmarking for safe sql.js deprecation.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07.2-webview-bridge/07.2-SUMMARY.md
@.planning/phases/07.2-webview-bridge/07.2-04-SUMMARY.md
@src/utils/bridge-performance.ts
@native/Sources/Isometry/Performance/BridgePerformanceMonitor.swift
@src/contexts/EnvironmentContext.tsx
@native/Sources/Isometry/WebView/SyncCoordinator.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create end-to-end migration testing suite</name>
  <files>
    src/test/migration-e2e.test.ts
    src/test/workflow-scenarios.ts
  </files>
  <action>
    Create comprehensive end-to-end testing suite leveraging established Phase 7.2 infrastructure:

    Build migration-e2e.test.ts using existing performance monitoring:
    - Import BridgePerformanceMonitor patterns from bridge-performance.ts
    - Leverage EnvironmentContext automatic provider detection
    - Use established SyncCoordinator for real-time validation
    - Integrate with existing conflict resolution testing

    Export core test functions:
    ```typescript
    export async function testCompleteWorkflow(providers: DatabaseProvider[]): Promise<TestResult>
    export async function testProviderMigration(from: Provider, to: Provider): Promise<MigrationResult>
    export async function testRollbackProcedures(scenario: RollbackScenario): Promise<RollbackResult>
    export async function validateCrossPlatform(platform: 'ios' | 'macos'): Promise<PlatformResult>
    ```

    Complete workflow validation scenarios:
    1. **Notebook Creation Flow**:
       - Create notebook card through React interface
       - Validate data persistence through WebView bridge
       - Confirm real-time sync through SyncCoordinator
       - Test cross-platform rendering (iOS/macOS)

    2. **Data Migration Flow**:
       - Start with sql.js baseline data
       - Migrate to WebView bridge using EnvironmentContext
       - Validate identical results across all providers
       - Test bidirectional sync integrity

    3. **Performance Validation Flow**:
       - Execute against established targets from 07.2-04:
         * Bridge latency < 50ms
         * Database throughput > 100 ops/sec
         * Sync latency < 100ms
         * Memory overhead < 10MB
       - Use BridgePerformanceMonitor for native measurements
       - Compare WebView bridge vs HTTP API performance

    4. **Rollback Procedure Flow**:
       - Test safe reversion from WebView bridge to HTTP API
       - Validate fallback to sql.js in browser environment
       - Ensure no data loss during rollback operations
       - Test recovery from partial migration failures

    Create workflow-scenarios.ts with reusable test data:
    - Sample notebook cards with complex content
    - Large dataset scenarios (1000+ nodes)
    - Concurrent user operation simulations
    - Error condition test cases
    - Cross-platform compatibility datasets

    Integration with established infrastructure:
    - Use existing bridge-performance.ts testing patterns
    - Leverage SyncCoordinator change detection
    - Integrate with EnvironmentContext provider selection
    - Build on SandboxValidator security testing

    Comprehensive assertion framework:
    - Data integrity checksums across providers
    - Performance benchmark comparisons
    - Real-time sync validation
    - Security compliance verification
    - Cross-platform UI consistency checks
  </action>
  <verify>
    All workflow scenarios pass on all three providers (sql.js, HTTP API, WebView bridge)
    Performance tests meet established targets from Phase 7.2
    Cross-platform tests validate iOS and macOS compatibility
  </verify>
  <done>
    Comprehensive end-to-end migration testing validates complete React → WebView → Native database flow with established performance targets
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement performance regression testing against established targets</name>
  <files>
    src/test/performance-regression.test.ts
    src/utils/performance-benchmarks.ts
  </files>
  <action>
    Create performance regression testing suite using established Phase 7.2 performance infrastructure:

    Build performance-regression.test.ts leveraging existing monitoring:
    - Import BridgePerformanceMonitor from native layer
    - Use bridge-performance.ts testing framework
    - Reference established targets from 07.2-04 Summary
    - Integrate with existing stress testing infrastructure

    Export performance validation functions:
    ```typescript
    export async function validatePerformanceTargets(provider: DatabaseProvider): Promise<PerformanceReport>
    export async function benchmarkMigrationPath(scenario: MigrationScenario): Promise<BenchmarkResult>
    export async function detectRegressions(baseline: PerformanceBaseline): Promise<RegressionReport>
    export async function stressTestMigration(loadLevel: 'light' | 'heavy' | 'extreme'): Promise<StressResult>
    ```

    Performance target validation (from Phase 7.2):
    1. **Bridge Latency**: < 50ms round-trip
       - Test MessageHandler response times
       - Measure WebView → Native communication
       - Compare against HTTP API baseline
       - Validate consistency across operations

    2. **Database Throughput**: > 100 ops/sec
       - Batch operation testing
       - Concurrent request handling
       - Memory usage during high throughput
       - Garbage collection impact

    3. **Sync Latency**: < 100ms
       - Real-time change notification timing
       - Bidirectional sync performance
       - Conflict resolution timing
       - Offline queue processing

    4. **Memory Overhead**: < 10MB
       - WebView memory footprint
       - Native bridge overhead
       - Memory leak detection
       - Cleanup efficiency validation

    5. **UI Performance**: 60fps target
       - React component rendering during database operations
       - Native UI responsiveness during sync
       - Animation smoothness validation
       - Input latency measurement

    Create performance-benchmarks.ts utility:
    - Performance baseline storage and comparison
    - Automated regression detection (>10% slowdown)
    - Performance report generation
    - Integration with BridgePerformanceMonitor
    - Cross-platform performance comparison

    Migration-specific performance testing:
    - Provider switching performance impact
    - Data migration timing for large datasets
    - Rollback operation performance
    - Environment detection overhead
    - Fallback chain performance impact

    Stress testing scenarios:
    - 1000+ concurrent database operations
    - Large file operations through WebView bridge
    - Memory pressure testing
    - Long-running sync operations
    - Multi-user simulation testing

    Automated regression detection:
    - Compare against Phase 7.2 established baselines
    - Flag any performance degradation >10%
    - Identify specific operations causing regressions
    - Generate actionable performance recommendations
    - Support CI/CD integration for continuous monitoring
  </action>
  <verify>
    All performance targets from Phase 7.2 are met or exceeded
    Regression testing detects any performance degradation >5%
    Stress testing validates performance under extreme load
  </verify>
  <done>
    Performance regression testing validates migration maintains established targets (60fps, <50ms latency) with comprehensive benchmarking
  </done>
</task>

<task type="auto">
  <name>Task 3: Create data integrity validation and rollback procedures</name>
  <files>
    src/test/data-integrity-validation.test.ts
    src/utils/migration-validator.ts
    native/Tests/IsometryTests/MigrationValidationTests.swift
  </files>
  <action>
    Create comprehensive data integrity validation leveraging established sync and security infrastructure:

    Build data-integrity-validation.test.ts using SyncCoordinator patterns:
    - Leverage established conflict resolution from 07.2-04
    - Use SandboxValidator security testing patterns
    - Build on real-time sync validation infrastructure
    - Integrate with existing data checksum validation

    Export data integrity functions:
    ```typescript
    export async function validateDataConsistency(providers: DatabaseProvider[]): Promise<ConsistencyReport>
    export async function testDataMigration(migrationPath: MigrationPath): Promise<IntegrityReport>
    export async function validateConcurrentOperations(): Promise<ConcurrencyReport>
    export async function detectDataCorruption(dataset: TestDataset): Promise<CorruptionReport>
    ```

    Data consistency validation:
    1. **Cross-Provider Consistency**:
       - Compare data across sql.js, HTTP API, and WebView bridge
       - Field-level comparison for accuracy
       - Relationship integrity validation
       - Foreign key consistency checks
       - Schema compliance verification

    2. **Migration Integrity**:
       - Pre-migration data snapshots
       - Post-migration data verification
       - Field mapping validation
       - Data type preservation
       - Metadata consistency

    3. **Concurrent Operation Safety**:
       - Multi-user editing scenarios
       - Race condition testing
       - Transaction isolation validation
       - Deadlock prevention testing
       - Conflict resolution accuracy

    Create migration-validator.ts utility leveraging sync infrastructure:
    ```typescript
    export class MigrationValidator {
      async validateMigrationPath(from: Provider, to: Provider): Promise<ValidationResult>
      async executeRollback(scenario: RollbackScenario): Promise<RollbackResult>
      async createMigrationCheckpoint(): Promise<Checkpoint>
      async restoreFromCheckpoint(checkpoint: Checkpoint): Promise<RestoreResult>
    }
    ```

    Rollback procedure implementation:
    - Safe reversion from WebView bridge to HTTP API
    - Fallback to sql.js for browser environments
    - Data preservation during rollback operations
    - Partial migration failure recovery
    - Checkpoint-based rollback strategy

    Create MigrationValidationTests.swift for native validation:
    ```swift
    class MigrationValidationTests: XCTestCase {
        func testDataMigration() async throws
        func testPerformanceTargets() async throws
        func testSecurityValidation() async throws
        func testConcurrentOperations() async throws
        func testRollbackProcedures() async throws
    }
    ```

    Native testing integration:
    - Use established BridgePerformanceMonitor
    - Leverage SandboxValidator security patterns
    - Build on SyncCoordinator change detection
    - Integrate with existing GRDB testing infrastructure

    Security validation using established patterns:
    - App Sandbox compliance validation
    - Path traversal prevention testing
    - MessageHandler security validation
    - File system access validation
    - Rate limiting compliance testing

    Large dataset testing:
    - 10,000+ node migration testing
    - Complex relationship preservation
    - Full-text search index integrity
    - Binary data (images) migration
    - CloudKit sync validation

    Automated corruption detection:
    - Cryptographic hash validation
    - Foreign key integrity checks
    - Schema compliance verification
    - Relationship consistency validation
    - Data type preservation validation
  </action>
  <verify>
    Data integrity tests show 100% consistency across all providers
    Migration validation confirms zero data loss or corruption
    Rollback procedures successfully restore previous state
  </verify>
  <done>
    Comprehensive data integrity validation ensures zero corruption across migration path with safe rollback procedures
  </done>
</task>

</tasks>

<verification>
1. End-to-end testing validates complete React → WebView → Native database flow
2. Performance testing confirms all established targets from Phase 7.2 are met
3. Data integrity validation ensures zero corruption or loss during migration
4. Cross-platform testing validates iOS and macOS compatibility
5. Rollback procedures provide safe reversion capabilities with automated testing
</verification>

<success_criteria>
- [ ] End-to-end tests validate complete migration workflow with established performance targets
- [ ] Performance regression tests confirm 60fps rendering and <50ms bridge latency
- [ ] Data integrity validation shows 100% consistency across all providers
- [ ] Cross-platform tests validate iOS and macOS compatibility
- [ ] Rollback procedures provide safe reversion with automated validation
</success_criteria>

<output>
After completion, create `.planning/phases/07.3-migration-completion/07.3-01-SUMMARY.md`
</output>