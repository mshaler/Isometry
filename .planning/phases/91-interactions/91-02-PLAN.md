---
phase: 91-interactions
plan: 02
type: execute
wave: 2
depends_on: [91-01]
files_modified:
  - src/d3/grid-rendering/HeaderKeyboardController.ts
  - src/d3/grid-rendering/GridSqlHeaderAdapter.ts
  - src/components/supergrid/SuperGrid.tsx
autonomous: true

must_haves:
  truths:
    - "Arrow keys navigate between headers"
    - "Enter/Space toggles collapse on focused header"
    - "Focus indicator visible on current header"
    - "Tab enters header navigation, Escape exits"
  artifacts:
    - path: "src/d3/grid-rendering/HeaderKeyboardController.ts"
      provides: "Keyboard navigation controller for headers"
      exports: ["HeaderKeyboardController"]
    - path: "src/d3/grid-rendering/GridSqlHeaderAdapter.ts"
      provides: "Focus management and ARIA attributes on headers"
      contains: "tabindex"
  key_links:
    - from: "src/d3/grid-rendering/HeaderKeyboardController.ts"
      to: "GridSqlHeaderAdapter"
      via: "focus updates and toggle callbacks"
      pattern: "onFocusChange|onToggle"
    - from: "src/components/supergrid/SuperGrid.tsx"
      to: "HeaderKeyboardController"
      via: "instantiation and lifecycle management"
      pattern: "new HeaderKeyboardController"
---

<objective>
Add keyboard navigation to SuperStack headers following WCAG 2.4.3 patterns.

Purpose: Enable keyboard-only users to navigate and interact with headers using arrow keys, Enter/Space for toggle, meeting accessibility requirements.

Output: Fully keyboard-navigable headers with visible focus indicators and screen reader support via ARIA attributes.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/91-interactions/91-RESEARCH.md
@.planning/phases/91-interactions/91-01-PLAN.md

# Key existing files to build on
@src/d3/grid-selection/GridSelectionController.ts
@src/d3/grid-rendering/GridSqlHeaderAdapter.ts
@src/d3/grid-rendering/NestedHeaderRenderer.ts
@src/superstack/types/superstack.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HeaderKeyboardController</name>
  <files>
    src/d3/grid-rendering/HeaderKeyboardController.ts
  </files>
  <action>
Create keyboard navigation controller for SuperStack headers, following patterns from GridSelectionController.

**Interface:**
```typescript
export interface HeaderKeyboardConfig {
  enableKeyboardNavigation: boolean;
}

export interface HeaderKeyboardCallbacks {
  onFocusChange: (headerId: string | null) => void;
  onToggle: (headerId: string) => void;
  onSelect: (headerId: string) => void;
}

export class HeaderKeyboardController {
  private container: d3.Selection<SVGElement, unknown, null, undefined>;
  private config: HeaderKeyboardConfig;
  private callbacks: HeaderKeyboardCallbacks;
  private focusedHeaderId: string | null = null;
  private headerIds: string[] = [];  // Ordered list for navigation

  constructor(
    container: d3.Selection<SVGElement, unknown, null, undefined>,
    config: HeaderKeyboardConfig,
    callbacks: HeaderKeyboardCallbacks
  );

  public setHeaderIds(ids: string[]): void;
  public focus(): void;
  public destroy(): void;
  private setupKeyboardHandlers(): void;
  private handleKeydown(event: KeyboardEvent): void;
  private focusHeader(headerId: string): void;
  private focusNext(): void;
  private focusPrev(): void;
  private focusChild(): void;
  private focusParent(): void;
}
```

**Implementation details:**

1. `setupKeyboardHandlers`:
```typescript
this.container
  .attr('tabindex', '0')
  .attr('role', 'treegrid')
  .attr('aria-label', 'SuperGrid headers')
  .on('keydown', (event: KeyboardEvent) => {
    if (!this.config.enableKeyboardNavigation) return;
    this.handleKeydown(event);
  });
```

2. `handleKeydown` - follow pattern from GridSelectionController lines 231-264:
```typescript
switch (event.key) {
  case 'ArrowRight':
    event.preventDefault();
    this.focusNext();
    break;
  case 'ArrowLeft':
    event.preventDefault();
    this.focusPrev();
    break;
  case 'ArrowDown':
    event.preventDefault();
    this.focusChild();  // Move to first child header
    break;
  case 'ArrowUp':
    event.preventDefault();
    this.focusParent();  // Move to parent header
    break;
  case 'Enter':
  case ' ':  // Space
    event.preventDefault();
    if (this.focusedHeaderId) {
      this.callbacks.onToggle(this.focusedHeaderId);
    }
    break;
  case 'Escape':
    event.preventDefault();
    this.callbacks.onFocusChange(null);
    this.focusedHeaderId = null;
    break;
}
```

3. Navigation helpers:
- `focusNext`: Move to next sibling at same level
- `focusPrev`: Move to previous sibling at same level
- `focusChild`: Move to first child if expanded
- `focusParent`: Move to parent node

Use headerIds array for linear navigation. Parse header key format `{axis}_{level}_{path}` to determine relationships.

4. `focusHeader`:
```typescript
private focusHeader(headerId: string): void {
  this.focusedHeaderId = headerId;
  this.callbacks.onFocusChange(headerId);

  // Programmatically focus the DOM element
  const element = this.container
    .select(`[data-header-id="${headerId}"]`)
    .node() as SVGGElement | null;

  if (element) {
    element.focus();
  }
}
```

5. `destroy`: Remove event listeners
```typescript
public destroy(): void {
  this.container.on('keydown', null);
}
```
  </action>
  <verify>
TypeScript compiles: `npm run typecheck`
Class exported: grep for "export class HeaderKeyboardController"
  </verify>
  <done>
HeaderKeyboardController class exists with arrow key navigation, Enter/Space toggle, Escape exit, and proper focus management via callbacks.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add ARIA attributes and focus visuals to GridSqlHeaderAdapter</name>
  <files>
    src/d3/grid-rendering/GridSqlHeaderAdapter.ts
  </files>
  <action>
Extend GridSqlHeaderAdapter to add ARIA attributes and focus visual management.

**1. Modify renderSqlDrivenHeaders to add ARIA attributes:**

After NestedHeaderRenderer renders, select all headers and add ARIA:
```typescript
// Add ARIA attributes for accessibility
const allHeaders = this.container.selectAll('.row-header, .col-header');

allHeaders
  .attr('tabindex', '-1')  // Focusable via JS but not Tab order
  .attr('role', 'gridcell')
  .attr('aria-expanded', (d: unknown) => {
    const data = d as NestedHeaderData;
    // Only set aria-expanded if node has children (is expandable)
    return data.span > 1 ? String(!data.isCollapsed) : null;
  })
  .attr('data-header-id', (d: unknown) => (d as NestedHeaderData).key);
```

**2. Add focus visual management method:**
```typescript
/**
 * Update focus visual indicator for keyboard navigation.
 * Shows visible focus ring per WCAG 2.4.7 (3:1 contrast minimum).
 */
public updateFocusedHeader(focusedId: string | null): void {
  this.container.selectAll('.row-header, .col-header')
    .classed('focused', (d: unknown) => {
      const headerData = d as NestedHeaderData;
      return headerData.key === focusedId;
    })
    .select('rect')
    .attr('stroke', (d: unknown) => {
      const headerData = d as NestedHeaderData;
      if (headerData.key === focusedId) {
        return '#1d4ed8';  // Blue-700 for focus (different from selection)
      }
      // Keep selection stroke if selected but not focused
      return '#cbd5e1';
    })
    .attr('stroke-width', (d: unknown) => {
      const headerData = d as NestedHeaderData;
      return headerData.key === focusedId ? 3 : 1;  // Thicker for focus
    })
    .attr('stroke-dasharray', (d: unknown) => {
      const headerData = d as NestedHeaderData;
      return headerData.key === focusedId ? '4 2' : null;  // Dashed for focus
    });
}

/**
 * Get ordered list of header IDs for keyboard navigation.
 * Returns headers in visual order (left-to-right for columns, top-to-bottom for rows).
 */
public getHeaderIds(): string[] {
  const ids: string[] = [];

  // Collect column headers first (visual reading order)
  if (this.columnHeaderTree) {
    this.collectHeaderIds(this.columnHeaderTree.roots, ids);
  }

  // Then row headers
  if (this.rowHeaderTree) {
    this.collectHeaderIds(this.rowHeaderTree.roots, ids);
  }

  return ids;
}

private collectHeaderIds(nodes: HeaderNode[], ids: string[]): void {
  for (const node of nodes) {
    // Convert HeaderNode id format to NestedHeaderData key format
    const axis = this.columnHeaderTree?.roots.includes(node) ? 'x' : 'y';
    const key = `${axis}_${node.depth}_${node.path.join('|')}`;
    ids.push(key);

    if (!node.collapsed && node.children.length > 0) {
      this.collectHeaderIds(node.children, ids);
    }
  }
}
```

**3. Update config interface to include keyboard callbacks:**
```typescript
export interface SqlHeaderAdapterConfig {
  // ... existing fields
  onFocusChange?: (headerId: string | null) => void;
}
```

Import HeaderNode from superstack types if not already imported.
  </action>
  <verify>
TypeScript compiles: `npm run typecheck`
ARIA attributes added: grep for "role.*gridcell" in GridSqlHeaderAdapter.ts
Focus visuals: grep for "updateFocusedHeader" in GridSqlHeaderAdapter.ts
  </verify>
  <done>
GridSqlHeaderAdapter adds ARIA attributes (role, aria-expanded, tabindex, data-header-id) to headers, provides updateFocusedHeader() for focus visuals with dashed stroke, and getHeaderIds() for navigation order.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate HeaderKeyboardController in SuperGrid</name>
  <files>
    src/components/supergrid/SuperGrid.tsx
  </files>
  <action>
Wire HeaderKeyboardController into SuperGrid component lifecycle.

**PREREQUISITE CHECK:** This task depends on Plan 91-01 being complete. Before implementation, verify:
```bash
grep "export function useHeaderInteractions" src/hooks/useHeaderInteractions.ts
```
If this grep fails, Plan 91-01 must be executed first.

**1. Import the controller:**
```typescript
import { HeaderKeyboardController } from '@/d3/grid-rendering/HeaderKeyboardController';
```

**2. Add ref for controller:**
```typescript
const keyboardControllerRef = useRef<HeaderKeyboardController | null>(null);
```

**3. Initialize controller when SVG is ready:**
```typescript
useEffect(() => {
  if (!svgRef.current || !sqlHeaderAdapterRef.current) return;

  const container = d3.select(svgRef.current as SVGElement);

  // Create keyboard controller
  keyboardControllerRef.current = new HeaderKeyboardController(
    container,
    { enableKeyboardNavigation: true },
    {
      onFocusChange: (headerId) => {
        sqlHeaderAdapterRef.current?.updateFocusedHeader(headerId);
      },
      onToggle: (headerId) => {
        // Use the handleHeaderToggle from useHeaderInteractions
        handleHeaderToggle(headerId, /* new collapsed state determined by lookup */);
      },
      onSelect: (headerId) => {
        handleHeaderSelect(headerId);
      }
    }
  );

  // Set initial header IDs for navigation
  const headerIds = sqlHeaderAdapterRef.current.getHeaderIds();
  keyboardControllerRef.current.setHeaderIds(headerIds);

  return () => {
    keyboardControllerRef.current?.destroy();
    keyboardControllerRef.current = null;
  };
}, [svgRef.current, handleHeaderToggle, handleHeaderSelect]);
```

**4. Update header IDs when trees change:**
```typescript
useEffect(() => {
  if (keyboardControllerRef.current && sqlHeaderAdapterRef.current) {
    const headerIds = sqlHeaderAdapterRef.current.getHeaderIds();
    keyboardControllerRef.current.setHeaderIds(headerIds);
  }
}, [interactiveColumnTree, interactiveRowTree]);
```

**5. Handle toggle determination:**
The onToggle callback needs to determine the new collapsed state. Add a helper:
```typescript
const handleKeyboardToggle = useCallback((headerId: string) => {
  // Find current collapsed state from collapsedIds set
  const isCurrentlyCollapsed = collapsedIds.has(headerId);
  handleHeaderToggle(headerId, !isCurrentlyCollapsed);
}, [collapsedIds, handleHeaderToggle]);
```

Pass `handleKeyboardToggle` to the controller's onToggle callback.
  </action>
  <verify>
**Dependency verification (run first):**
```bash
grep "export function useHeaderInteractions" src/hooks/useHeaderInteractions.ts || echo "BLOCKER: Plan 91-01 not complete"
```

TypeScript compiles: `npm run typecheck`
Controller created: grep for "HeaderKeyboardController" in SuperGrid.tsx
Lifecycle managed: grep for "keyboardControllerRef" in SuperGrid.tsx
  </verify>
  <done>
SuperGrid creates HeaderKeyboardController, passes focus/toggle/select callbacks, updates header IDs when trees change, and cleans up on unmount. Verified that useHeaderInteractions from Plan 91-01 is available.
  </done>
</task>

</tasks>

<verification>
**Manual testing:**
1. Run `npm run dev`
2. Navigate to SuperGrid view with nested headers
3. Tab into the grid - first header should get focus (dashed blue border)
4. Press ArrowRight - focus moves to next sibling header
5. Press ArrowLeft - focus moves to previous sibling
6. Press ArrowDown - focus moves to first child (if expanded)
7. Press ArrowUp - focus moves to parent
8. Press Enter or Space - toggles collapse on focused header
9. Press Escape - focus exits header navigation
10. Verify screen reader announces "gridcell" role and expanded state

**Automated:**
```bash
npm run typecheck  # Zero errors
npm run test       # All tests pass
```
</verification>

<success_criteria>
1. INT-05: Arrow keys navigate between headers (Right/Left for siblings, Down/Up for parent/child)
2. Focus indicator visible: Dashed blue stroke on focused header
3. Enter/Space toggles collapse on focused header
4. Tab enters, Escape exits header navigation
5. ARIA attributes present: role="gridcell", aria-expanded, tabindex
</success_criteria>

<output>
After completion, create `.planning/phases/91-interactions/91-02-SUMMARY.md`
</output>
