---
phase: 91-interactions
plan: 01
type: execute
wave: 1
depends_on: [90-02]
files_modified:
  - src/hooks/useHeaderInteractions.ts
  - src/d3/grid-rendering/GridSqlHeaderAdapter.ts
  - src/superstack/builders/header-tree-builder.ts
  - src/components/supergrid/SuperGrid.tsx
autonomous: true

must_haves:
  truths:
    - "Click collapse icon toggles children visibility"
    - "Collapsed headers occupy single column/row visually"
    - "Click header filters data to that path subset"
    - "Selected header highlighted visually"
  artifacts:
    - path: "src/hooks/useHeaderInteractions.ts"
      provides: "React hook bridging D3 events to state management"
      exports: ["useHeaderInteractions"]
    - path: "src/d3/grid-rendering/GridSqlHeaderAdapter.ts"
      provides: "D3 event handlers for collapse/expand and click-to-filter"
      contains: "on('click'"
    - path: "src/superstack/builders/header-tree-builder.ts"
      provides: "Toggle collapse and recalculate tree functions"
      exports: ["toggleHeaderCollapse", "recalculateTree"]
  key_links:
    - from: "src/d3/grid-rendering/GridSqlHeaderAdapter.ts"
      to: "useHeaderInteractions"
      via: "callback invocation on click events"
      pattern: "onHeaderToggle|onHeaderFilter"
    - from: "src/hooks/useHeaderInteractions.ts"
      to: "src/superstack/builders/header-tree-builder.ts"
      via: "recalculateTree() call after collapse toggle"
      pattern: "recalculateTree"
---

<objective>
Add collapse/expand toggle and click-to-filter interactions to SuperStack headers.

Purpose: Enable users to navigate and filter the grid by clicking headers - collapsing subtrees to simplify the view, or filtering data to a specific path subset.

Output: Working click interactions on headers with visual feedback (highlight) and state-driven re-renders.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/91-interactions/91-RESEARCH.md
@.planning/phases/90-sql-integration/90-02-SUMMARY.md

# Key existing files to build on
@src/superstack/types/superstack.ts
@src/superstack/builders/header-tree-builder.ts
@src/d3/grid-rendering/GridSqlHeaderAdapter.ts
@src/d3/grid-rendering/NestedHeaderRenderer.ts
@src/d3/SuperGridEngine/FilterManager.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useHeaderInteractions hook</name>
  <files>
    src/hooks/useHeaderInteractions.ts
  </files>
  <action>
Create React hook that bridges D3 event handlers to React state management.

**Interface:**
```typescript
interface UseHeaderInteractionsConfig {
  columnTree: HeaderTree | null;
  rowTree: HeaderTree | null;
  onFilterChange?: (path: FilterConstraint[]) => void;
}

interface UseHeaderInteractionsReturn {
  collapsedIds: Set<string>;
  selectedHeaderId: string | null;
  handleHeaderToggle: (headerId: string, collapsed: boolean) => void;
  handleHeaderClick: (node: HeaderNode) => void;
  handleHeaderSelect: (nodeId: string | null) => void;
  columnTree: HeaderTree | null;  // Returns recalculated tree
  rowTree: HeaderTree | null;     // Returns recalculated tree
}
```

**Implementation:**
1. Use `useState` for collapsedIds (Set<string>) - NOT Context API (avoids re-render cascade per research)
2. Use `useState` for selectedHeaderId (string | null)
3. `handleHeaderToggle`:
   - **CRITICAL: Clone tree using `structuredClone(tree)` before mutation** - React requires immutable updates
   - Find node by id in cloned tree, toggle collapsed flag
   - Call `recalculateTree(clonedTree)` from header-tree-builder
   - Update state with new cloned tree
4. `handleHeaderClick`:
   - Build filter path from node using `node.path` array
   - Convert to FilterConstraint[] format: `{facet: sourceColumn, operator: 'equals', value}`
   - Call `onFilterChange` callback if provided
5. `handleHeaderSelect`: Update selectedHeaderId state

**Key decision (from research):** Keep collapse state LOCAL to this hook, not in Context. Prevents re-render of entire tree on every toggle.

Import recalculateTree from '@/superstack/builders/header-tree-builder'.
  </action>
  <verify>
TypeScript compiles without errors: `npm run typecheck`
Hook exports correctly: grep for "export function useHeaderInteractions"
structuredClone used: grep for "structuredClone" in src/hooks/useHeaderInteractions.ts
  </verify>
  <done>
useHeaderInteractions hook exists with collapsedIds state, handleHeaderToggle that clones tree via structuredClone before calling recalculateTree, handleHeaderClick that builds filter path, and handleHeaderSelect for selection tracking.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add toggleHeaderCollapse to header-tree-builder</name>
  <files>
    src/superstack/builders/header-tree-builder.ts
  </files>
  <action>
Add helper function to toggle collapse state on a specific node and recalculate the tree.

**Add function:**
```typescript
/**
 * Toggle collapse state for a node and recalculate tree metrics.
 * @param tree - The HeaderTree to modify (mutates in place)
 * @param nodeId - ID of the node to toggle
 * @returns true if node was found and toggled, false otherwise
 */
export function toggleHeaderCollapse(tree: HeaderTree, nodeId: string): boolean {
  const node = findNodeById(tree, nodeId);
  if (!node) return false;

  node.collapsed = !node.collapsed;
  recalculateTree(tree);
  return true;
}
```

**CRITICAL: Update recalculateTree span logic:**

When recalculating spans in `recalculateTree`, ensure collapsed nodes get span=1:
```typescript
// In span calculation logic:
if (node.collapsed) {
  node.span = 1;  // Collapsed parent = single column/row
} else {
  // Sum children spans (existing logic)
  node.span = node.children.reduce((sum, child) => sum + child.span, 0);
  // Leaf nodes with no children get span 1
  if (node.children.length === 0) node.span = 1;
}
```

**Note:** `findNodeById` and `recalculateTree` already exist in this file - add the toggle wrapper and verify/fix span logic for collapsed state.

This enables the pattern: `toggleHeaderCollapse(columnTree, nodeId)` instead of manually finding node + toggling + recalculating.
  </action>
  <verify>
Function exported: `grep "export function toggleHeaderCollapse" src/superstack/builders/header-tree-builder.ts`
Span=1 logic: `grep -A2 "node.collapsed" src/superstack/builders/header-tree-builder.ts` shows span=1 assignment
TypeScript compiles: `npm run typecheck`
  </verify>
  <done>
toggleHeaderCollapse function exists and is exported. recalculateTree correctly sets node.span=1 when node.collapsed=true, and node.span=sum(children) when collapsed=false.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add click handlers to GridSqlHeaderAdapter</name>
  <files>
    src/d3/grid-rendering/GridSqlHeaderAdapter.ts
  </files>
  <action>
Extend GridSqlHeaderAdapter to attach D3 click handlers to rendered headers.

**Add private fields for tree storage:**
```typescript
private columnHeaderTree: HeaderTree | null = null;
private rowHeaderTree: HeaderTree | null = null;
```

**Add setters if not already present:**
```typescript
public setColumnHeaderTree(tree: HeaderTree | null): void {
  this.columnHeaderTree = tree;
}

public setRowHeaderTree(tree: HeaderTree | null): void {
  this.rowHeaderTree = tree;
}
```

**Add to SqlHeaderAdapterConfig interface:**
```typescript
onHeaderToggle?: (headerId: string, collapsed: boolean) => void;
onHeaderFilter?: (node: HeaderNode) => void;
onHeaderSelect?: (nodeId: string | null) => void;
```

**Add method to class:**
```typescript
/**
 * Attach click event handlers to all header elements.
 * Must be called AFTER renderSqlDrivenHeaders().
 */
public attachHeaderEventHandlers(): void {
  const container = this.container;

  // Select all header groups (both row and column)
  const headers = container.selectAll('.row-header, .col-header');

  headers.on('click', (event: MouseEvent, d: unknown) => {
    event.stopPropagation();

    // Don't process clicks during drag
    if ((event.target as any)?.isDragging) return;

    const headerData = d as NestedHeaderData;
    const headerId = headerData.key;

    // Determine click intent based on target
    // If clicked on collapse icon (small area), toggle collapse
    // Otherwise, filter to this path

    // For now: single-click = filter, use collapse icon target detection
    const target = event.target as SVGElement;
    const isCollapseIcon = target.classList.contains('collapse-icon');

    if (isCollapseIcon) {
      // Toggle collapse
      const newCollapsed = !headerData.isCollapsed;
      this.config.onHeaderToggle?.(headerId, newCollapsed);
    } else {
      // Filter to this path - need to map NestedHeaderData back to HeaderNode
      const node = this.findHeaderNodeByKey(headerId);
      if (node) {
        this.config.onHeaderSelect?.(headerId);
        this.config.onHeaderFilter?.(node);
      }
    }
  });
}

/**
 * Find HeaderNode from key (path-based lookup in stored trees).
 * Requires trees to be set via setColumnHeaderTree/setRowHeaderTree.
 */
private findHeaderNodeByKey(key: string): HeaderNode | null {
  // Key format: "{axis}_{level}_{pathJoinedByPipe}"
  // Need to search in columnHeaderTree or rowHeaderTree
  const isColumn = key.startsWith('x_');
  const tree = isColumn ? this.columnHeaderTree : this.rowHeaderTree;
  if (!tree) return null;

  // Extract the path portion from key
  const pathPart = key.replace(/^[xy]_\d+_/, '');

  return this.searchTreeByPath(tree.roots, pathPart.split('|'));
}

private searchTreeByPath(nodes: HeaderNode[], pathParts: string[]): HeaderNode | null {
  if (pathParts.length === 0) return null;

  for (const node of nodes) {
    if (node.value === pathParts[0]) {
      if (pathParts.length === 1) return node;
      return this.searchTreeByPath(node.children, pathParts.slice(1));
    }
  }
  return null;
}
```

**Modify renderSqlDrivenHeaders() to call attachHeaderEventHandlers() at the end.**

**Add visual highlight for selected header:**
```typescript
public updateSelectedHeader(selectedId: string | null): void {
  this.container.selectAll('.row-header, .col-header')
    .classed('selected', (d: unknown) => {
      const headerData = d as NestedHeaderData;
      return headerData.key === selectedId;
    })
    .select('rect')
    .attr('stroke', (d: unknown) => {
      const headerData = d as NestedHeaderData;
      return headerData.key === selectedId ? '#2563eb' : '#cbd5e1';
    })
    .attr('stroke-width', (d: unknown) => {
      const headerData = d as NestedHeaderData;
      return headerData.key === selectedId ? 2 : 1;
    });
}
```

Import HeaderNode from superstack types.
  </action>
  <verify>
TypeScript compiles: `npm run typecheck`
Private fields: `grep "private columnHeaderTree" src/d3/grid-rendering/GridSqlHeaderAdapter.ts`
Event handlers attached: grep for "on('click'" in GridSqlHeaderAdapter.ts
  </verify>
  <done>
GridSqlHeaderAdapter has private columnHeaderTree/rowHeaderTree fields with setters, attachHeaderEventHandlers() that wires D3 click events, findHeaderNodeByKey() for path lookup, and updateSelectedHeader() for visual highlighting.
  </done>
</task>

<task type="auto">
  <name>Task 4: Wire useHeaderInteractions to SuperGrid</name>
  <files>
    src/components/supergrid/SuperGrid.tsx
  </files>
  <action>
Integrate useHeaderInteractions hook into SuperGrid component.

**Changes:**
1. Import useHeaderInteractions hook
2. Add state callbacks to GridSqlHeaderAdapter:
```typescript
const {
  collapsedIds,
  selectedHeaderId,
  handleHeaderToggle,
  handleHeaderClick,
  handleHeaderSelect,
  columnTree: interactiveColumnTree,
  rowTree: interactiveRowTree
} = useHeaderInteractions({
  columnTree: headerData.columnTree,
  rowTree: headerData.rowTree,
  onFilterChange: (constraints) => {
    // TODO: Wire to FilterContext in future phase
    console.log('Filter constraints:', constraints);
  }
});
```

3. Pass callbacks to GridSqlHeaderAdapter config:
```typescript
const adapterConfig: SqlHeaderAdapterConfig = {
  ...existingConfig,
  onHeaderToggle: handleHeaderToggle,
  onHeaderFilter: handleHeaderClick,
  onHeaderSelect: handleHeaderSelect,
};
```

4. Use interactive trees (with collapse state applied) instead of raw headerData trees:
```typescript
sqlHeaderAdapter.setColumnHeaderTree(interactiveColumnTree);
sqlHeaderAdapter.setRowHeaderTree(interactiveRowTree);
```

5. Call updateSelectedHeader when selectedHeaderId changes:
```typescript
useEffect(() => {
  if (sqlHeaderAdapterRef.current) {
    sqlHeaderAdapterRef.current.updateSelectedHeader(selectedHeaderId);
  }
}, [selectedHeaderId]);
```

**Note:** The onFilterChange callback logs to console for now. Full FilterContext integration will be added in Phase 92 (Data Cell Integration) when headers need to coordinate with data cells.
  </action>
  <verify>
TypeScript compiles: `npm run typecheck`
Hook is used: grep for "useHeaderInteractions" in SuperGrid.tsx
Callbacks passed to adapter: grep for "onHeaderToggle" in SuperGrid.tsx
  </verify>
  <done>
SuperGrid uses useHeaderInteractions hook, passes callbacks to GridSqlHeaderAdapter, uses interactive trees with collapse state applied, and updates selected header visuals on selection change.
  </done>
</task>

</tasks>

<verification>
**Manual testing:**
1. Run `npm run dev`
2. Navigate to SuperGrid view with nested headers
3. Click a parent header - should highlight with blue border
4. Click collapse icon on parent - children should hide, parent span should become 1 (single column width)
5. Click again - children reappear, spans restore to full width
6. Click different header - selection moves, previous deselects
7. Check browser console for "Filter constraints" log on click

**Automated:**
```bash
npm run typecheck  # Zero errors
npm run test       # All tests pass
```
</verification>

<success_criteria>
1. INT-01: Click collapse icon toggles children visibility (children hide/show)
2. INT-02: Collapsed parent occupies single column visually (span=1 in tree)
3. INT-03: Click header logs filter path to console (FilterContext wiring in Phase 92)
4. INT-04: Selected header has blue border, others have default border
</success_criteria>

<output>
After completion, create `.planning/phases/91-interactions/91-01-SUMMARY.md`
</output>
