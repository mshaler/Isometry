---
phase: 85-backend-terminal
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/terminal/terminalPTYServer.ts
  - src/services/terminal/terminalTypes.ts
  - src/services/terminal/outputBuffer.ts
autonomous: true

must_haves:
  truths:
    - "PTY backend spawns real shell process with node-pty"
    - "Terminal output streams to WebSocket clients in real-time"
    - "Output buffer stores last N bytes for reconnection replay"
  artifacts:
    - path: "src/services/terminal/terminalPTYServer.ts"
      provides: "PTY process management with node-pty"
      exports: ["TerminalPTYServer", "PTYSession"]
    - path: "src/services/terminal/terminalTypes.ts"
      provides: "Type definitions for terminal messages"
      exports: ["TerminalMessage", "TerminalInputMessage", "TerminalOutputMessage", "PTYConfig"]
    - path: "src/services/terminal/outputBuffer.ts"
      provides: "Circular buffer for output replay on reconnection"
      exports: ["OutputBuffer"]
  key_links:
    - from: "src/services/terminal/terminalPTYServer.ts"
      to: "node-pty"
      via: "import { spawn } from 'node-pty'"
      pattern: "import.*node-pty"
    - from: "src/services/terminal/terminalPTYServer.ts"
      to: "src/services/terminal/outputBuffer.ts"
      via: "OutputBuffer for replay"
      pattern: "OutputBuffer"
---

<objective>
Create PTY backend infrastructure using node-pty for real shell process execution with output buffering.

Purpose: Establish the server-side foundation for real terminal execution. node-pty provides proper PTY semantics (signals, job control, terminal size) that child_process.spawn lacks. Output buffering enables TERM-05 reconnection replay.

Output:
- `terminalPTYServer.ts` — PTY session manager using node-pty
- `terminalTypes.ts` — TypeScript types for terminal WebSocket protocol
- `outputBuffer.ts` — Circular buffer for reconnection output replay
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@src/services/claude-code/claudeCodeServer.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create terminal types and output buffer</name>
  <files>
    src/services/terminal/terminalTypes.ts
    src/services/terminal/outputBuffer.ts
  </files>
  <action>
Create `src/services/terminal/` directory and add type definitions:

**terminalTypes.ts:**
```typescript
export interface PTYConfig {
  shell: string;           // '/bin/zsh' or '/bin/bash'
  cwd: string;             // Working directory
  cols: number;            // Terminal columns (default: 80)
  rows: number;            // Terminal rows (default: 24)
  env?: Record<string, string>; // Additional env vars
}

export type TerminalMode = 'shell' | 'claude-code';

export interface TerminalSession {
  id: string;
  mode: TerminalMode;
  config: PTYConfig;
  createdAt: Date;
}

// Client -> Server messages
export interface TerminalInputMessage {
  type: 'terminal:input';
  sessionId: string;
  data: string;           // Raw input data (keystrokes)
}

export interface TerminalResizeMessage {
  type: 'terminal:resize';
  sessionId: string;
  cols: number;
  rows: number;
}

export interface TerminalSpawnMessage {
  type: 'terminal:spawn';
  sessionId: string;
  config: PTYConfig;
  mode: TerminalMode;
}

export interface TerminalKillMessage {
  type: 'terminal:kill';
  sessionId: string;
  signal?: string;        // 'SIGTERM', 'SIGKILL', 'SIGINT'
}

export interface TerminalReplayMessage {
  type: 'terminal:replay';
  sessionId: string;
}

export type TerminalClientMessage =
  | TerminalInputMessage
  | TerminalResizeMessage
  | TerminalSpawnMessage
  | TerminalKillMessage
  | TerminalReplayMessage;

// Server -> Client messages
export interface TerminalOutputMessage {
  type: 'terminal:output';
  sessionId: string;
  data: string;           // PTY output data
}

export interface TerminalSpawnedMessage {
  type: 'terminal:spawned';
  sessionId: string;
  pid: number;
}

export interface TerminalExitMessage {
  type: 'terminal:exit';
  sessionId: string;
  exitCode: number;
  signal?: number;
}

export interface TerminalErrorMessage {
  type: 'terminal:error';
  sessionId: string;
  error: string;
}

export interface TerminalReplayDataMessage {
  type: 'terminal:replay-data';
  sessionId: string;
  data: string;           // Buffered output for replay
}

export type TerminalServerMessage =
  | TerminalOutputMessage
  | TerminalSpawnedMessage
  | TerminalExitMessage
  | TerminalErrorMessage
  | TerminalReplayDataMessage;
```

**outputBuffer.ts:**
```typescript
/**
 * Circular buffer for terminal output replay on reconnection.
 * Stores last N bytes of output (default: 64KB).
 * Thread-safe for single-writer use case (PTY output handler).
 */
export class OutputBuffer {
  private buffer: string[] = [];
  private totalSize = 0;
  private readonly maxSize: number;

  constructor(maxSizeBytes: number = 64 * 1024) {
    this.maxSize = maxSizeBytes;
  }

  /**
   * Append data to buffer, evicting oldest entries if over limit
   */
  append(data: string): void {
    const dataSize = data.length;

    // If single chunk exceeds max, truncate it
    if (dataSize > this.maxSize) {
      this.buffer = [data.slice(-this.maxSize)];
      this.totalSize = this.maxSize;
      return;
    }

    // Evict oldest entries until we have room
    while (this.totalSize + dataSize > this.maxSize && this.buffer.length > 0) {
      const removed = this.buffer.shift();
      if (removed) {
        this.totalSize -= removed.length;
      }
    }

    this.buffer.push(data);
    this.totalSize += dataSize;
  }

  /**
   * Get all buffered output as single string for replay
   */
  getAll(): string {
    return this.buffer.join('');
  }

  /**
   * Clear the buffer
   */
  clear(): void {
    this.buffer = [];
    this.totalSize = 0;
  }

  /**
   * Get current buffer size in bytes
   */
  size(): number {
    return this.totalSize;
  }
}
```

Security note: Types enforce structured messages - no command string interpolation.
  </action>
  <verify>
    Run `npm run typecheck` - no errors in new files.
    Files exist: `src/services/terminal/terminalTypes.ts`, `src/services/terminal/outputBuffer.ts`
  </verify>
  <done>
    Type definitions export all terminal message types.
    OutputBuffer class with append/getAll/clear methods.
    TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create PTY server with node-pty integration</name>
  <files>
    src/services/terminal/terminalPTYServer.ts
  </files>
  <action>
Create the PTY server that manages terminal sessions using node-pty.

**terminalPTYServer.ts:**
```typescript
import { spawn, IPty } from 'node-pty';
import { WebSocket } from 'ws';
import { OutputBuffer } from './outputBuffer';
import {
  PTYConfig,
  TerminalMode,
  TerminalSession,
  TerminalClientMessage,
  TerminalOutputMessage,
  TerminalSpawnedMessage,
  TerminalExitMessage,
  TerminalErrorMessage,
  TerminalReplayDataMessage
} from './terminalTypes';
import { devLogger } from '../../utils/logging';

export interface PTYSessionState extends TerminalSession {
  pty: IPty | null;
  outputBuffer: OutputBuffer;
  clients: Set<WebSocket>;
}

/**
 * PTY server managing terminal sessions with node-pty.
 *
 * Features:
 * - Real PTY semantics (signals, job control, terminal resize)
 * - Output buffering for reconnection replay (64KB default)
 * - Multi-client broadcast (same session, multiple viewers)
 * - Secure: uses spawn with args array (never string interpolation)
 */
export class TerminalPTYServer {
  private sessions = new Map<string, PTYSessionState>();

  /**
   * Handle incoming terminal message from WebSocket client
   */
  async handleMessage(ws: WebSocket, message: TerminalClientMessage): Promise<void> {
    devLogger.debug('Terminal message received', {
      component: 'TerminalPTYServer',
      type: message.type,
      sessionId: message.sessionId
    });

    switch (message.type) {
      case 'terminal:spawn':
        await this.spawnSession(ws, message.sessionId, message.config, message.mode);
        break;
      case 'terminal:input':
        this.handleInput(message.sessionId, message.data);
        break;
      case 'terminal:resize':
        this.handleResize(message.sessionId, message.cols, message.rows);
        break;
      case 'terminal:kill':
        await this.killSession(message.sessionId, message.signal);
        break;
      case 'terminal:replay':
        this.handleReplay(ws, message.sessionId);
        break;
    }
  }

  /**
   * Spawn a new PTY session
   * SECURITY: Uses spawn with args array, never string interpolation
   */
  private async spawnSession(
    ws: WebSocket,
    sessionId: string,
    config: PTYConfig,
    mode: TerminalMode
  ): Promise<void> {
    // Validate shell path - whitelist allowed shells
    const allowedShells = ['/bin/zsh', '/bin/bash', '/bin/sh'];
    const shell = allowedShells.includes(config.shell) ? config.shell : '/bin/zsh';

    // Create session state
    const session: PTYSessionState = {
      id: sessionId,
      mode,
      config: { ...config, shell },
      createdAt: new Date(),
      pty: null,
      outputBuffer: new OutputBuffer(),
      clients: new Set([ws])
    };

    try {
      // Spawn PTY process - args array, not string concatenation
      const pty = spawn(shell, [], {
        name: 'xterm-256color',
        cols: config.cols || 80,
        rows: config.rows || 24,
        cwd: config.cwd || process.cwd(),
        env: {
          ...process.env,
          ...config.env,
          TERM: 'xterm-256color',
          COLORTERM: 'truecolor'
        }
      });

      session.pty = pty;
      this.sessions.set(sessionId, session);

      // Notify client of successful spawn
      this.sendToClient(ws, {
        type: 'terminal:spawned',
        sessionId,
        pid: pty.pid
      });

      // Handle PTY output
      pty.onData((data: string) => {
        // Buffer for replay
        session.outputBuffer.append(data);

        // Broadcast to all connected clients
        const outputMsg: TerminalOutputMessage = {
          type: 'terminal:output',
          sessionId,
          data
        };
        this.broadcastToSession(sessionId, outputMsg);
      });

      // Handle PTY exit
      pty.onExit(({ exitCode, signal }) => {
        devLogger.debug('PTY exited', {
          component: 'TerminalPTYServer',
          sessionId,
          exitCode,
          signal
        });

        const exitMsg: TerminalExitMessage = {
          type: 'terminal:exit',
          sessionId,
          exitCode,
          signal
        };
        this.broadcastToSession(sessionId, exitMsg);

        // Cleanup after small delay (let exit message send)
        setTimeout(() => {
          this.sessions.delete(sessionId);
        }, 100);
      });

      devLogger.debug('PTY spawned', {
        component: 'TerminalPTYServer',
        sessionId,
        pid: pty.pid,
        shell,
        cwd: config.cwd
      });

    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : 'Failed to spawn PTY';
      devLogger.error('PTY spawn failed', {
        component: 'TerminalPTYServer',
        sessionId,
        error: errorMsg
      });

      this.sendToClient(ws, {
        type: 'terminal:error',
        sessionId,
        error: errorMsg
      });
    }
  }

  /**
   * Handle terminal input (keystrokes)
   */
  private handleInput(sessionId: string, data: string): void {
    const session = this.sessions.get(sessionId);
    if (!session?.pty) {
      devLogger.debug('Input for unknown session', {
        component: 'TerminalPTYServer',
        sessionId
      });
      return;
    }

    // Write raw data to PTY - no escaping needed, PTY handles it
    session.pty.write(data);
  }

  /**
   * Handle terminal resize
   */
  private handleResize(sessionId: string, cols: number, rows: number): void {
    const session = this.sessions.get(sessionId);
    if (!session?.pty) return;

    session.pty.resize(cols, rows);
    session.config.cols = cols;
    session.config.rows = rows;

    devLogger.debug('PTY resized', {
      component: 'TerminalPTYServer',
      sessionId,
      cols,
      rows
    });
  }

  /**
   * Handle replay request (reconnection)
   */
  private handleReplay(ws: WebSocket, sessionId: string): void {
    const session = this.sessions.get(sessionId);
    if (!session) {
      this.sendToClient(ws, {
        type: 'terminal:error',
        sessionId,
        error: 'Session not found'
      });
      return;
    }

    // Add client to session
    session.clients.add(ws);

    // Send buffered output
    const bufferedData = session.outputBuffer.getAll();
    if (bufferedData) {
      this.sendToClient(ws, {
        type: 'terminal:replay-data',
        sessionId,
        data: bufferedData
      });
    }

    devLogger.debug('Replay sent', {
      component: 'TerminalPTYServer',
      sessionId,
      bufferSize: session.outputBuffer.size()
    });
  }

  /**
   * Kill a PTY session
   */
  private async killSession(sessionId: string, signal?: string): Promise<void> {
    const session = this.sessions.get(sessionId);
    if (!session?.pty) return;

    const sig = signal || 'SIGTERM';
    session.pty.kill(sig);

    devLogger.debug('PTY killed', {
      component: 'TerminalPTYServer',
      sessionId,
      signal: sig
    });
  }

  /**
   * Remove a client from session tracking (on disconnect)
   */
  removeClient(ws: WebSocket): void {
    for (const session of this.sessions.values()) {
      session.clients.delete(ws);
    }
  }

  /**
   * Get active session count
   */
  getSessionCount(): number {
    return this.sessions.size;
  }

  /**
   * Cleanup all sessions (server shutdown)
   */
  cleanup(): void {
    for (const [sessionId, session] of this.sessions) {
      if (session.pty) {
        session.pty.kill('SIGTERM');
      }
      this.sessions.delete(sessionId);
    }
  }

  // Helper methods
  private sendToClient(ws: WebSocket, message: TerminalSpawnedMessage | TerminalExitMessage | TerminalErrorMessage | TerminalReplayDataMessage): void {
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify(message));
    }
  }

  private broadcastToSession(sessionId: string, message: TerminalOutputMessage | TerminalExitMessage): void {
    const session = this.sessions.get(sessionId);
    if (!session) return;

    const data = JSON.stringify(message);
    for (const client of session.clients) {
      if (client.readyState === WebSocket.OPEN) {
        client.send(data);
      }
    }
  }
}
```

Key security points:
- Shell whitelist validation (line 76-77)
- spawn() with empty args array, not string concat (line 83)
- No command string interpolation anywhere
  </action>
  <verify>
    Run `npm run typecheck` - no errors in terminalPTYServer.ts.
    Verify import of node-pty resolves correctly.
  </verify>
  <done>
    TerminalPTYServer spawns PTY sessions using node-pty.
    Output buffering implemented for reconnection replay.
    Secure: shell whitelist, no string interpolation.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add index export and basic unit test</name>
  <files>
    src/services/terminal/index.ts
    src/services/terminal/__tests__/outputBuffer.test.ts
  </files>
  <action>
Create index export and test for OutputBuffer.

**index.ts:**
```typescript
export { TerminalPTYServer } from './terminalPTYServer';
export type { PTYSessionState } from './terminalPTYServer';
export { OutputBuffer } from './outputBuffer';
export * from './terminalTypes';
```

**__tests__/outputBuffer.test.ts:**
```typescript
import { describe, it, expect, beforeEach } from 'vitest';
import { OutputBuffer } from '../outputBuffer';

describe('OutputBuffer', () => {
  let buffer: OutputBuffer;

  beforeEach(() => {
    buffer = new OutputBuffer(100); // 100 byte limit for tests
  });

  it('appends data correctly', () => {
    buffer.append('hello');
    buffer.append(' world');
    expect(buffer.getAll()).toBe('hello world');
    expect(buffer.size()).toBe(11);
  });

  it('evicts old data when over limit', () => {
    const chunk = 'x'.repeat(60);
    buffer.append(chunk);
    buffer.append(chunk); // Should evict first chunk

    expect(buffer.size()).toBeLessThanOrEqual(100);
    expect(buffer.getAll().length).toBeLessThanOrEqual(100);
  });

  it('handles single chunk larger than max', () => {
    const largeChunk = 'x'.repeat(200);
    buffer.append(largeChunk);

    expect(buffer.size()).toBe(100);
    expect(buffer.getAll().length).toBe(100);
  });

  it('clears buffer', () => {
    buffer.append('data');
    buffer.clear();

    expect(buffer.getAll()).toBe('');
    expect(buffer.size()).toBe(0);
  });

  it('handles empty append', () => {
    buffer.append('');
    expect(buffer.getAll()).toBe('');
    expect(buffer.size()).toBe(0);
  });
});
```

Run: `npm run test:run -- src/services/terminal/__tests__/outputBuffer.test.ts`
  </action>
  <verify>
    Test passes: `npm run test:run -- src/services/terminal/__tests__/outputBuffer.test.ts`
    Index exports compile: `npm run typecheck`
  </verify>
  <done>
    Index.ts exports all terminal service components.
    OutputBuffer has passing unit tests.
    `npm run typecheck` passes.
  </done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes with no errors
2. Files exist in `src/services/terminal/`:
   - terminalTypes.ts
   - outputBuffer.ts
   - terminalPTYServer.ts
   - index.ts
3. OutputBuffer test passes
4. TerminalPTYServer exports correctly
</verification>

<success_criteria>
- PTY types defined with proper security (no command string type)
- OutputBuffer provides 64KB circular buffer for replay
- TerminalPTYServer spawns node-pty processes with shell whitelist
- No TypeScript errors
- Unit test passes
</success_criteria>

<output>
After completion, create `.planning/phases/85-backend-terminal/85-01-SUMMARY.md`
</output>
