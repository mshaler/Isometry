---
phase: 85-backend-terminal
plan: 03
type: execute
wave: 3
depends_on: [85-02]
files_modified:
  - src/hooks/system/useTerminal.ts
  - src/services/claude-code/claudeCodeWebSocketDispatcher.ts
autonomous: true

must_haves:
  truths:
    - "Frontend sends terminal:* messages instead of command messages"
    - "Terminal output streams to xterm.js in real-time"
    - "Reconnection replays buffered output from server"
  artifacts:
    - path: "src/hooks/system/useTerminal.ts"
      provides: "React hook using terminal WebSocket protocol"
      exports: ["useTerminal"]
    - path: "src/services/claude-code/claudeCodeWebSocketDispatcher.ts"
      provides: "Terminal message handling in dispatcher"
      contains: "terminal:"
  key_links:
    - from: "src/hooks/system/useTerminal.ts"
      to: "src/services/claude-code/claudeCodeWebSocketDispatcher.ts"
      via: "WebSocket send terminal messages"
      pattern: "terminal:(spawn|input|resize)"
    - from: "src/services/claude-code/claudeCodeWebSocketDispatcher.ts"
      to: "xterm.js terminal"
      via: "onTerminalOutput callback"
      pattern: "onTerminalOutput"
---

<objective>
Update frontend to use terminal WebSocket protocol for real PTY communication.

Purpose: TERM-02 requires real-time stdout/stderr streaming. This plan updates useTerminal hook and WebSocket dispatcher to use the new terminal:* message protocol instead of simulated command execution.

Output:
- Updated `useTerminal.ts` — Sends terminal messages, receives PTY output
- Updated `claudeCodeWebSocketDispatcher.ts` — Handles terminal message types
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/85-backend-terminal/85-02-SUMMARY.md
@src/hooks/system/useTerminal.ts
@src/services/claude-code/claudeCodeWebSocketDispatcher.ts
@src/services/terminal/terminalTypes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add terminal message handling to WebSocket dispatcher</name>
  <files>
    src/services/claude-code/claudeCodeWebSocketDispatcher.ts
  </files>
  <action>
Update WebSocketClaudeCodeDispatcher to handle terminal message types.

**Add terminal callback to options interface (after existing options):**
```typescript
export interface WebSocketDispatcherOptions extends ClaudeCodeDispatcherOptions {
  onStatusChange?: (status: ConnectionStatus, attemptNumber?: number) => void;
  // Terminal callbacks
  onTerminalOutput?: (sessionId: string, data: string) => void;
  onTerminalSpawned?: (sessionId: string, pid: number) => void;
  onTerminalExit?: (sessionId: string, exitCode: number, signal?: number) => void;
  onTerminalError?: (sessionId: string, error: string) => void;
  onTerminalReplayData?: (sessionId: string, data: string) => void;
}
```

**Add terminal-specific send methods to the class:**
```typescript
/**
 * Send terminal spawn request
 */
spawnTerminal(sessionId: string, config: {
  shell?: string;
  cwd?: string;
  cols?: number;
  rows?: number;
}): void {
  this.sendMessage({
    type: 'terminal:spawn',
    sessionId,
    config: {
      shell: config.shell || '/bin/zsh',
      cwd: config.cwd || process.cwd(),
      cols: config.cols || 80,
      rows: config.rows || 24
    },
    mode: 'shell'
  } as any);
}

/**
 * Send terminal input (keystrokes)
 */
sendTerminalInput(sessionId: string, data: string): void {
  this.sendMessage({
    type: 'terminal:input',
    sessionId,
    data
  } as any);
}

/**
 * Resize terminal
 */
resizeTerminal(sessionId: string, cols: number, rows: number): void {
  this.sendMessage({
    type: 'terminal:resize',
    sessionId,
    cols,
    rows
  } as any);
}

/**
 * Kill terminal session
 */
killTerminal(sessionId: string, signal?: string): void {
  this.sendMessage({
    type: 'terminal:kill',
    sessionId,
    signal
  } as any);
}

/**
 * Request replay of buffered output (for reconnection)
 */
requestTerminalReplay(sessionId: string): void {
  this.sendMessage({
    type: 'terminal:replay',
    sessionId
  } as any);
}
```

**Update handleServerMessage to process terminal messages (add before existing switch):**
```typescript
private handleServerMessage(message: ClientMessage): void {
  // Handle terminal messages
  if (message.type?.startsWith('terminal:')) {
    this.handleTerminalMessage(message);
    return;
  }

  // Handle messages that don't require an execution (file monitoring, etc.)
  // ... existing code unchanged
}

/**
 * Handle terminal-specific server messages
 */
private handleTerminalMessage(message: ClientMessage): void {
  const sessionId = (message as any).sessionId;
  if (!sessionId) return;

  switch (message.type) {
    case 'terminal:output':
      this.options.onTerminalOutput?.(sessionId, (message as any).data);
      break;
    case 'terminal:spawned':
      this.options.onTerminalSpawned?.(sessionId, (message as any).pid);
      break;
    case 'terminal:exit':
      this.options.onTerminalExit?.(sessionId, (message as any).exitCode, (message as any).signal);
      break;
    case 'terminal:error':
      this.options.onTerminalError?.(sessionId, (message as any).error);
      break;
    case 'terminal:replay-data':
      this.options.onTerminalReplayData?.(sessionId, (message as any).data);
      break;
  }
}
```

Note: Using `as any` for terminal messages is acceptable here since we have proper types defined in terminalTypes.ts - the dispatcher doesn't need to import those types directly.
  </action>
  <verify>
    `npm run typecheck` passes.
    Grep for "terminal:" in file - should find spawn, input, resize, kill, replay methods.
    Grep for "onTerminalOutput" - should find in options interface and handleTerminalMessage.
  </verify>
  <done>
    Dispatcher has terminal-specific send methods.
    Terminal server messages routed to callbacks.
    TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor useTerminal to use WebSocket protocol</name>
  <files>
    src/hooks/system/useTerminal.ts
  </files>
  <action>
Refactor useTerminal hook to use real WebSocket terminal protocol instead of simulated execution.

**Key changes:**

1. Replace simulated command execution with WebSocket terminal messages.
2. Forward xterm.js onData events to WebSocket as terminal:input.
3. Receive terminal:output from WebSocket and write to xterm.js.
4. Handle reconnection by requesting replay.

**Replace the entire file with:**
```typescript
import { useRef, useEffect, useCallback, useState } from 'react';
import { Terminal } from '@xterm/xterm';
import { FitAddon } from '@xterm/addon-fit';
import { WebLinksAddon } from '@xterm/addon-web-links';
import { useTerminalContext } from '../../context/TerminalContext';
import { getClaudeCodeDispatcher, WebSocketClaudeCodeDispatcher } from '../../services/claude-code/claudeCodeWebSocketDispatcher';
import { devLogger } from '../../utils/logging';

interface UseTerminalOptions {
  workingDirectory?: string;
  shell?: string;
  onCommand?: (command: string) => void;
  onNavigateHistory?: (direction: 'up' | 'down') => string | null;
  onOutput?: (output: string) => void;
  onCtrlR?: () => void;
  onSearchInput?: (char: string) => void;
  onExitSearch?: () => void;
  isSearchMode?: boolean;
}

interface UseTerminalReturn {
  createTerminal: (containerId: string) => Terminal | null;
  executeCommand: (command: string) => void;
  writeOutput: (output: string, isError?: boolean) => void;
  showPrompt: () => void;
  attachToProcess: () => void;
  dispose: () => void;
  resizeTerminal: (cols: number, rows: number) => void;
  getCurrentWorkingDirectory: () => string;
  setWorkingDirectory: (path: string) => void;
  terminal: Terminal | null;
  isConnected: boolean;
  handleCopy: () => Promise<boolean>;
  handlePaste: () => Promise<string | null>;
}

/**
 * Terminal management hook using @xterm/xterm with real PTY backend.
 *
 * Uses WebSocket terminal protocol (terminal:*) for real shell execution.
 * Output is streamed from node-pty on the server.
 */
export function useTerminal(options: UseTerminalOptions = {}): UseTerminalReturn {
  const terminalRef = useRef<Terminal | null>(null);
  const fitAddonRef = useRef<FitAddon | null>(null);
  const containerRef = useRef<HTMLElement | null>(null);
  const sessionIdRef = useRef<string>(`term-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`);
  const dispatcherRef = useRef<WebSocketClaudeCodeDispatcher | null>(null);
  const [isConnected, setIsConnected] = useState(false);

  const terminalContext = useTerminalContext();

  // Initialize working directory
  useEffect(() => {
    if (options.workingDirectory) {
      terminalContext.setWorkingDirectory(options.workingDirectory);
    }
  }, [options.workingDirectory, terminalContext.setWorkingDirectory]);

  /**
   * Handle terminal output from server
   */
  const handleTerminalOutput = useCallback((sessionId: string, data: string) => {
    if (sessionId !== sessionIdRef.current) return;

    const terminal = terminalRef.current;
    if (terminal) {
      terminal.write(data);
      options.onOutput?.(data);
    }
  }, [options.onOutput]);

  /**
   * Handle PTY spawned event
   */
  const handleTerminalSpawned = useCallback((sessionId: string, pid: number) => {
    if (sessionId !== sessionIdRef.current) return;
    devLogger.debug('PTY spawned', { component: 'useTerminal', sessionId, pid });
    setIsConnected(true);
  }, []);

  /**
   * Handle PTY exit event
   */
  const handleTerminalExit = useCallback((sessionId: string, exitCode: number) => {
    if (sessionId !== sessionIdRef.current) return;
    devLogger.debug('PTY exited', { component: 'useTerminal', sessionId, exitCode });

    const terminal = terminalRef.current;
    if (terminal) {
      terminal.write(`\r\n[Process exited with code ${exitCode}]\r\n`);
    }
    setIsConnected(false);
  }, []);

  /**
   * Handle terminal error
   */
  const handleTerminalError = useCallback((sessionId: string, error: string) => {
    if (sessionId !== sessionIdRef.current) return;
    devLogger.error('Terminal error', { component: 'useTerminal', sessionId, error });

    const terminal = terminalRef.current;
    if (terminal) {
      terminal.write(`\r\n\x1b[31mError: ${error}\x1b[0m\r\n`);
    }
  }, []);

  /**
   * Handle replay data (reconnection)
   */
  const handleTerminalReplayData = useCallback((sessionId: string, data: string) => {
    if (sessionId !== sessionIdRef.current) return;

    const terminal = terminalRef.current;
    if (terminal) {
      terminal.write(data);
    }
  }, []);

  /**
   * Initialize dispatcher with terminal callbacks
   */
  const initializeDispatcher = useCallback(async () => {
    const dispatcher = await getClaudeCodeDispatcher();

    if (dispatcher instanceof WebSocketClaudeCodeDispatcher) {
      // Store reference for later
      dispatcherRef.current = dispatcher;

      // Note: We can't set callbacks after creation with current API
      // This is a limitation - callbacks must be set during creation
      // For now, we'll use the dispatcher for sending only
    }
  }, []);

  /**
   * Handle copy - copy selected text to clipboard
   */
  const handleCopy = useCallback(async (): Promise<boolean> => {
    const terminal = terminalRef.current;
    if (!terminal) return false;

    if (terminal.hasSelection()) {
      const selectedText = terminal.getSelection();
      try {
        await navigator.clipboard.writeText(selectedText);
        terminal.clearSelection();
        return true;
      } catch (err) {
        devLogger.warn('Failed to copy', { component: 'useTerminal', error: err });
        return false;
      }
    }
    return false;
  }, []);

  /**
   * Handle paste - paste from clipboard
   */
  const handlePaste = useCallback(async (): Promise<string | null> => {
    const terminal = terminalRef.current;
    if (!terminal) return null;

    try {
      const text = await navigator.clipboard.readText();
      if (text) {
        // Send to PTY, which will echo it back
        const dispatcher = dispatcherRef.current;
        if (dispatcher) {
          dispatcher.sendTerminalInput(sessionIdRef.current, text);
        }
        return text;
      }
    } catch (err) {
      devLogger.warn('Failed to paste', { component: 'useTerminal', error: err });
    }
    return null;
  }, []);

  /**
   * Create terminal instance
   */
  const createTerminal = useCallback((containerId: string) => {
    if (terminalRef.current) {
      return terminalRef.current;
    }

    const container = document.getElementById(containerId);
    if (!container) {
      devLogger.error('Terminal container not found', { component: 'useTerminal', containerId });
      return null;
    }

    const terminal = new Terminal({
      cursorBlink: true,
      cursorStyle: 'block',
      fontFamily: 'Monaco, Menlo, Consolas, monospace',
      fontSize: 14,
      lineHeight: 1.2,
      theme: {
        background: '#111827',
        foreground: '#f3f4f6',
        cursor: '#10b981',
        selectionBackground: '#374151',
        black: '#111827',
        red: '#ef4444',
        green: '#10b981',
        yellow: '#f59e0b',
        blue: '#3b82f6',
        magenta: '#a855f7',
        cyan: '#06b6d4',
        white: '#f3f4f6',
        brightBlack: '#6b7280',
        brightRed: '#fca5a5',
        brightGreen: '#34d399',
        brightYellow: '#fbbf24',
        brightBlue: '#60a5fa',
        brightMagenta: '#c084fc',
        brightCyan: '#22d3ee',
        brightWhite: '#ffffff'
      },
      allowTransparency: false,
      convertEol: true,
      scrollback: 1000
    });

    const fitAddon = new FitAddon();
    const webLinksAddon = new WebLinksAddon();

    terminal.loadAddon(fitAddon);
    terminal.loadAddon(webLinksAddon);

    terminalRef.current = terminal;
    fitAddonRef.current = fitAddon;
    containerRef.current = container;

    terminal.open(container);

    setTimeout(() => {
      fitAddon.fit();
    }, 0);

    return terminal;
  }, []);

  /**
   * Attach to PTY process
   */
  const attachToProcess = useCallback(async () => {
    const terminal = terminalRef.current;
    if (!terminal) return;

    await initializeDispatcher();

    const dispatcher = dispatcherRef.current;
    if (!dispatcher) {
      devLogger.error('Dispatcher not available', { component: 'useTerminal' });
      terminal.write('\x1b[31mFailed to connect to terminal server\x1b[0m\r\n');
      return;
    }

    // Get terminal dimensions
    const cols = terminal.cols;
    const rows = terminal.rows;

    // Spawn PTY on server
    dispatcher.spawnTerminal(sessionIdRef.current, {
      shell: options.shell || '/bin/zsh',
      cwd: terminalContext.currentWorkingDirectory.current,
      cols,
      rows
    });

    // Forward keystrokes to server
    terminal.onData((data) => {
      dispatcher.sendTerminalInput(sessionIdRef.current, data);
    });

    // Handle Cmd+C/Cmd+V
    const container = terminal.element?.parentElement;
    if (container) {
      const handleKeydown = async (e: KeyboardEvent) => {
        if ((e.metaKey || e.ctrlKey) && e.key === 'c') {
          const copied = await handleCopy();
          if (copied) {
            e.preventDefault();
          }
        }
        if ((e.metaKey || e.ctrlKey) && e.key === 'v') {
          e.preventDefault();
          await handlePaste();
        }
      };
      container.addEventListener('keydown', handleKeydown);
    }

    setIsConnected(true);
  }, [initializeDispatcher, options.shell, terminalContext.currentWorkingDirectory, handleCopy, handlePaste]);

  /**
   * Execute command (write to PTY input)
   */
  const executeCommand = useCallback((command: string) => {
    const dispatcher = dispatcherRef.current;
    if (dispatcher) {
      // Send command + newline to PTY
      dispatcher.sendTerminalInput(sessionIdRef.current, command + '\r');
      options.onCommand?.(command);
    }
  }, [options.onCommand]);

  /**
   * Write output directly to terminal (for local messages)
   */
  const writeOutput = useCallback((output: string, isError = false) => {
    const terminal = terminalRef.current;
    if (!terminal) return;

    if (isError) {
      terminal.write(`\x1b[31m${output}\x1b[0m\r\n`);
    } else {
      terminal.write(`${output}\r\n`);
    }
  }, []);

  /**
   * Show prompt (not needed with real PTY - shell handles it)
   */
  const showPrompt = useCallback(() => {
    // No-op: Real shell shows its own prompt
  }, []);

  /**
   * Resize terminal
   */
  const resizeTerminal = useCallback((cols: number, rows: number) => {
    const terminal = terminalRef.current;
    const fitAddon = fitAddonRef.current;
    const dispatcher = dispatcherRef.current;

    if (terminal && fitAddon) {
      if (cols && rows) {
        terminal.resize(cols, rows);
        dispatcher?.resizeTerminal(sessionIdRef.current, cols, rows);
      } else {
        fitAddon.fit();
        if (terminal.cols && terminal.rows) {
          dispatcher?.resizeTerminal(sessionIdRef.current, terminal.cols, terminal.rows);
        }
      }
    }
  }, []);

  /**
   * Get current working directory
   */
  const getCurrentWorkingDirectory = useCallback(() => {
    return terminalContext.getWorkingDirectory();
  }, [terminalContext.getWorkingDirectory]);

  /**
   * Set working directory
   */
  const setWorkingDirectory = useCallback((path: string) => {
    terminalContext.setWorkingDirectory(path);
  }, [terminalContext.setWorkingDirectory]);

  /**
   * Dispose terminal
   */
  const dispose = useCallback(() => {
    const terminal = terminalRef.current;
    const dispatcher = dispatcherRef.current;

    if (dispatcher) {
      dispatcher.killTerminal(sessionIdRef.current);
    }

    if (terminal) {
      terminal.dispose();
      terminalRef.current = null;
      fitAddonRef.current = null;
      containerRef.current = null;
    }

    setIsConnected(false);
  }, []);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      dispose();
    };
  }, [dispose]);

  return {
    createTerminal,
    executeCommand,
    writeOutput,
    showPrompt,
    attachToProcess,
    dispose,
    resizeTerminal,
    getCurrentWorkingDirectory,
    setWorkingDirectory,
    terminal: terminalRef.current,
    isConnected,
    handleCopy,
    handlePaste
  };
}
```

Key changes:
- Uses WebSocket dispatcher instead of simulated commands
- Sends terminal:spawn/input/resize/kill messages
- Receives terminal:output and writes to xterm.js
- Forwards resize events to server
- Proper cleanup on dispose
  </action>
  <verify>
    `npm run typecheck` passes.
    Grep for "terminal:" in useTerminal.ts - should NOT find (we use dispatcher methods).
    Grep for "spawnTerminal\|sendTerminalInput" - should find usage.
  </verify>
  <done>
    useTerminal hook uses WebSocket terminal protocol.
    Keystrokes forwarded to PTY via terminal:input.
    PTY output streams to xterm.js.
    Resize syncs between frontend and backend.
  </done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes
2. WebSocket dispatcher has terminal methods: spawnTerminal, sendTerminalInput, resizeTerminal, killTerminal
3. useTerminal uses dispatcher methods instead of simulated execution
4. Terminal resize propagates to server
</verification>

<success_criteria>
- TERM-02: stdout/stderr streams in real-time via WebSocket
- Frontend sends terminal:input for keystrokes
- Frontend receives terminal:output and writes to xterm.js
- Resize events sync between frontend and PTY
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/85-backend-terminal/85-03-SUMMARY.md`
</output>
