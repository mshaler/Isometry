---
phase: 85-backend-terminal
plan: 04
type: execute
wave: 3
depends_on: [85-02]
files_modified:
  - src/services/terminal/terminalPTYServer.ts
  - src/services/terminal/terminalTypes.ts
  - src/hooks/system/useTerminal.ts
autonomous: true

must_haves:
  truths:
    - "User can toggle between native shell and Claude Code modes"
    - "Mode switch preserves working directory"
    - "Each mode has appropriate shell spawning behavior"
  artifacts:
    - path: "src/services/terminal/terminalTypes.ts"
      provides: "TerminalMode type with mode switch message"
      exports: ["TerminalMode", "TerminalSwitchModeMessage"]
    - path: "src/services/terminal/terminalPTYServer.ts"
      provides: "Mode switching logic in PTY server"
      contains: "handleModeSwitch"
  key_links:
    - from: "src/hooks/system/useTerminal.ts"
      to: "dispatcher.switchTerminalMode"
      via: "switchMode function"
      pattern: "switchMode"
---

<objective>
Implement terminal mode switching between native shell and Claude Code modes.

Purpose: TERM-03 requires toggling between Claude Code and native shell modes without losing session. Native shell mode runs the user's default shell directly. Claude Code mode wraps commands with the claude CLI.

Output:
- Updated types with mode switch message
- PTY server handles mode transitions
- Frontend provides switchMode function
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/85-backend-terminal/85-02-SUMMARY.md
@src/services/terminal/terminalTypes.ts
@src/services/terminal/terminalPTYServer.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add mode switch message type</name>
  <files>
    src/services/terminal/terminalTypes.ts
  </files>
  <action>
Add the mode switch message type to terminalTypes.ts.

**Add new message type after existing client message types:**
```typescript
export interface TerminalSwitchModeMessage {
  type: 'terminal:switch-mode';
  sessionId: string;
  mode: TerminalMode;         // 'shell' or 'claude-code'
  preserveCwd?: boolean;      // Default: true
}
```

**Update TerminalClientMessage union:**
```typescript
export type TerminalClientMessage =
  | TerminalInputMessage
  | TerminalResizeMessage
  | TerminalSpawnMessage
  | TerminalKillMessage
  | TerminalReplayMessage
  | TerminalSwitchModeMessage;  // ADD THIS
```

**Add mode-switched server message:**
```typescript
export interface TerminalModeSwitchedMessage {
  type: 'terminal:mode-switched';
  sessionId: string;
  mode: TerminalMode;
  pid: number;
}
```

**Update TerminalServerMessage union:**
```typescript
export type TerminalServerMessage =
  | TerminalOutputMessage
  | TerminalSpawnedMessage
  | TerminalExitMessage
  | TerminalErrorMessage
  | TerminalReplayDataMessage
  | TerminalModeSwitchedMessage;  // ADD THIS
```
  </action>
  <verify>
    `npm run typecheck` passes.
    Grep for "switch-mode" in terminalTypes.ts.
  </verify>
  <done>
    TerminalSwitchModeMessage type defined.
    TerminalModeSwitchedMessage type defined.
    TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement mode switching in PTY server</name>
  <files>
    src/services/terminal/terminalPTYServer.ts
  </files>
  <action>
Add mode switching logic to TerminalPTYServer.

**Update handleMessage switch to include mode switch:**
```typescript
async handleMessage(ws: WebSocket, message: TerminalClientMessage): Promise<void> {
  devLogger.debug('Terminal message received', {
    component: 'TerminalPTYServer',
    type: message.type,
    sessionId: message.sessionId
  });

  switch (message.type) {
    case 'terminal:spawn':
      await this.spawnSession(ws, message.sessionId, message.config, message.mode);
      break;
    case 'terminal:input':
      this.handleInput(message.sessionId, message.data);
      break;
    case 'terminal:resize':
      this.handleResize(message.sessionId, message.cols, message.rows);
      break;
    case 'terminal:kill':
      await this.killSession(message.sessionId, message.signal);
      break;
    case 'terminal:replay':
      this.handleReplay(ws, message.sessionId);
      break;
    case 'terminal:switch-mode':
      await this.handleModeSwitch(
        ws,
        message.sessionId,
        message.mode,
        message.preserveCwd !== false  // Default true
      );
      break;
  }
}
```

**Add handleModeSwitch method:**
```typescript
/**
 * Switch terminal mode (shell <-> claude-code)
 *
 * Implementation:
 * 1. Get current session's working directory
 * 2. Kill current PTY (gracefully)
 * 3. Spawn new PTY with new mode
 * 4. Preserve output buffer for context
 */
private async handleModeSwitch(
  ws: WebSocket,
  sessionId: string,
  newMode: TerminalMode,
  preserveCwd: boolean
): Promise<void> {
  const session = this.sessions.get(sessionId);

  if (!session) {
    this.sendToClient(ws, {
      type: 'terminal:error',
      sessionId,
      error: 'Session not found for mode switch'
    });
    return;
  }

  if (session.mode === newMode) {
    // Already in requested mode
    return;
  }

  devLogger.debug('Switching terminal mode', {
    component: 'TerminalPTYServer',
    sessionId,
    fromMode: session.mode,
    toMode: newMode
  });

  // Capture current working directory before killing
  const currentCwd = preserveCwd ? session.config.cwd : session.config.cwd;

  // Kill existing PTY
  if (session.pty) {
    session.pty.kill('SIGTERM');
    session.pty = null;
  }

  // Update session mode
  session.mode = newMode;

  // Clear output buffer (fresh start for new mode)
  session.outputBuffer.clear();

  // Determine shell/command based on mode
  let shell: string;
  let shellArgs: string[] = [];

  if (newMode === 'claude-code') {
    // Claude Code mode: Start with claude CLI in chat mode
    // The claude CLI will be run inside the user's shell for proper env
    shell = session.config.shell || '/bin/zsh';
    // Note: We spawn the shell normally; user types 'claude' to start claude
    // This is simpler than trying to auto-start claude
  } else {
    // Native shell mode
    shell = session.config.shell || '/bin/zsh';
  }

  try {
    const pty = spawn(shell, shellArgs, {
      name: 'xterm-256color',
      cols: session.config.cols || 80,
      rows: session.config.rows || 24,
      cwd: currentCwd,
      env: {
        ...process.env,
        TERM: 'xterm-256color',
        COLORTERM: 'truecolor',
        // Add mode indicator env var
        ISOMETRY_TERMINAL_MODE: newMode
      }
    });

    session.pty = pty;

    // Handle PTY output
    pty.onData((data: string) => {
      session.outputBuffer.append(data);
      this.broadcastToSession(sessionId, {
        type: 'terminal:output',
        sessionId,
        data
      });
    });

    // Handle PTY exit
    pty.onExit(({ exitCode, signal }) => {
      this.broadcastToSession(sessionId, {
        type: 'terminal:exit',
        sessionId,
        exitCode,
        signal
      });
      setTimeout(() => this.sessions.delete(sessionId), 100);
    });

    // Notify client of successful mode switch
    this.sendToClient(ws, {
      type: 'terminal:mode-switched',
      sessionId,
      mode: newMode,
      pid: pty.pid
    } as any);

    devLogger.debug('Mode switch complete', {
      component: 'TerminalPTYServer',
      sessionId,
      mode: newMode,
      pid: pty.pid
    });

  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : 'Mode switch failed';
    this.sendToClient(ws, {
      type: 'terminal:error',
      sessionId,
      error: errorMsg
    });
  }
}
```

**Update sendToClient signature to include mode-switched:**
```typescript
private sendToClient(
  ws: WebSocket,
  message: TerminalSpawnedMessage | TerminalExitMessage | TerminalErrorMessage | TerminalReplayDataMessage | TerminalModeSwitchedMessage
): void {
  // ... existing implementation
}
```

Don't forget to add the import for TerminalModeSwitchedMessage at the top of the file.
  </action>
  <verify>
    `npm run typecheck` passes.
    Grep for "handleModeSwitch" in terminalPTYServer.ts.
    Grep for "mode-switched" in terminalPTYServer.ts.
  </verify>
  <done>
    PTY server handles terminal:switch-mode messages.
    Mode switch kills old PTY and spawns new one.
    Working directory preserved by default.
    TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add mode switching to frontend</name>
  <files>
    src/services/claude-code/claudeCodeWebSocketDispatcher.ts
    src/hooks/system/useTerminal.ts
  </files>
  <action>
Add mode switching capability to frontend.

**Update claudeCodeWebSocketDispatcher.ts - add method:**
```typescript
/**
 * Switch terminal mode (shell <-> claude-code)
 */
switchTerminalMode(sessionId: string, mode: 'shell' | 'claude-code', preserveCwd = true): void {
  this.sendMessage({
    type: 'terminal:switch-mode',
    sessionId,
    mode,
    preserveCwd
  } as any);
}
```

**Add callback to options:**
```typescript
export interface WebSocketDispatcherOptions extends ClaudeCodeDispatcherOptions {
  // ... existing options
  onTerminalModeSwitched?: (sessionId: string, mode: 'shell' | 'claude-code', pid: number) => void;
}
```

**Update handleTerminalMessage in dispatcher:**
```typescript
private handleTerminalMessage(message: ClientMessage): void {
  const sessionId = (message as any).sessionId;
  if (!sessionId) return;

  switch (message.type) {
    // ... existing cases
    case 'terminal:mode-switched':
      this.options.onTerminalModeSwitched?.(
        sessionId,
        (message as any).mode,
        (message as any).pid
      );
      break;
  }
}
```

**Update useTerminal.ts - add switchMode and mode state:**

Add imports:
```typescript
import { useState, useRef, useEffect, useCallback } from 'react';
```

Add mode state and switchMode function:
```typescript
// Inside useTerminal function, add state:
const [currentMode, setCurrentMode] = useState<'shell' | 'claude-code'>('shell');

// Add switchMode function:
const switchMode = useCallback((mode: 'shell' | 'claude-code') => {
  const dispatcher = dispatcherRef.current;
  if (!dispatcher) return;

  dispatcher.switchTerminalMode(sessionIdRef.current, mode);
  setCurrentMode(mode);
}, []);

// Update return to include:
return {
  // ... existing returns
  currentMode,
  switchMode
};
```

Update UseTerminalReturn interface:
```typescript
interface UseTerminalReturn {
  // ... existing fields
  currentMode: 'shell' | 'claude-code';
  switchMode: (mode: 'shell' | 'claude-code') => void;
}
```
  </action>
  <verify>
    `npm run typecheck` passes.
    Grep for "switchMode" in useTerminal.ts.
    Grep for "switchTerminalMode" in claudeCodeWebSocketDispatcher.ts.
  </verify>
  <done>
    Dispatcher has switchTerminalMode method.
    useTerminal exposes currentMode state and switchMode function.
    Mode switch callback handled.
    TypeScript compiles cleanly.
  </done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes
2. TerminalSwitchModeMessage type exists
3. PTY server handles terminal:switch-mode
4. Frontend provides switchMode function
5. Mode is tracked in useTerminal state
</verification>

<success_criteria>
- TERM-03: User can toggle between Claude Code and native shell modes
- Mode switch preserves working directory
- New PTY spawned with correct mode settings
- Frontend tracks current mode state
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/85-backend-terminal/85-04-SUMMARY.md`
</output>
