---
phase: 85-backend-terminal
plan: 02
type: execute
wave: 2
depends_on: [85-01]
files_modified:
  - src/services/claude-code/claudeCodeServer.ts
  - src/services/terminal/messageRouter.ts
autonomous: true

must_haves:
  truths:
    - "WebSocket server routes terminal messages to PTY server"
    - "Non-terminal messages still handled by existing logic"
    - "Ping/pong heartbeat works for terminal connections"
  artifacts:
    - path: "src/services/terminal/messageRouter.ts"
      provides: "Message type discrimination for WebSocket routing"
      exports: ["isTerminalMessage", "routeMessage"]
    - path: "src/services/claude-code/claudeCodeServer.ts"
      provides: "WebSocket server with terminal integration"
      contains: "TerminalPTYServer"
  key_links:
    - from: "src/services/claude-code/claudeCodeServer.ts"
      to: "src/services/terminal/terminalPTYServer.ts"
      via: "import TerminalPTYServer"
      pattern: "import.*TerminalPTYServer"
    - from: "src/services/claude-code/claudeCodeServer.ts"
      to: "src/services/terminal/messageRouter.ts"
      via: "import isTerminalMessage"
      pattern: "isTerminalMessage"
---

<objective>
Integrate terminal PTY server into existing WebSocket infrastructure with message routing.

Purpose: BACK-01 requires WebSocket to route messages by type (terminal/mcp/file). This plan adds terminal message routing to claudeCodeServer.ts, keeping existing command/file-monitoring functionality intact.

Output:
- `messageRouter.ts` — Type guard and routing logic for message discrimination
- Updated `claudeCodeServer.ts` — Terminal integration with PTY server
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/85-backend-terminal/85-01-SUMMARY.md
@src/services/claude-code/claudeCodeServer.ts
@src/services/terminal/terminalTypes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create message router with type guards</name>
  <files>
    src/services/terminal/messageRouter.ts
  </files>
  <action>
Create message router that discriminates between terminal and other message types.

**messageRouter.ts:**
```typescript
import type { TerminalClientMessage } from './terminalTypes';
import type { ServerMessage } from '../claude-code/claudeCodeServer';

/**
 * Message categories for WebSocket routing
 */
export type MessageCategory = 'terminal' | 'command' | 'file-monitoring' | 'unknown';

/**
 * Type guard: Is this a terminal message?
 */
export function isTerminalMessage(message: unknown): message is TerminalClientMessage {
  if (typeof message !== 'object' || message === null) return false;
  const msg = message as Record<string, unknown>;

  if (typeof msg.type !== 'string') return false;

  const terminalTypes = [
    'terminal:spawn',
    'terminal:input',
    'terminal:resize',
    'terminal:kill',
    'terminal:replay'
  ];

  return terminalTypes.includes(msg.type);
}

/**
 * Type guard: Is this a command execution message?
 */
export function isCommandMessage(message: unknown): message is ServerMessage {
  if (typeof message !== 'object' || message === null) return false;
  const msg = message as Record<string, unknown>;

  return msg.type === 'command' ||
         msg.type === 'cancel' ||
         msg.type === 'input';
}

/**
 * Type guard: Is this a file monitoring message?
 */
export function isFileMonitoringMessage(message: unknown): boolean {
  if (typeof message !== 'object' || message === null) return false;
  const msg = message as Record<string, unknown>;

  return msg.type === 'start_file_monitoring' ||
         msg.type === 'stop_file_monitoring';
}

/**
 * Type guard: Is this a ping message (heartbeat)?
 */
export function isPingMessage(message: unknown): boolean {
  if (typeof message !== 'object' || message === null) return false;
  const msg = message as Record<string, unknown>;
  return msg.type === 'ping';
}

/**
 * Categorize a message for routing
 */
export function categorizeMessage(message: unknown): MessageCategory {
  if (isTerminalMessage(message)) return 'terminal';
  if (isCommandMessage(message)) return 'command';
  if (isFileMonitoringMessage(message)) return 'file-monitoring';
  return 'unknown';
}
```

This provides clean type discrimination without any string interpolation risk.
  </action>
  <verify>
    `npm run typecheck` passes.
    File exports all type guards: isTerminalMessage, isCommandMessage, isPingMessage, categorizeMessage
  </verify>
  <done>
    Message router exports type guards for all message categories.
    categorizeMessage() provides single-point routing logic.
    TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate terminal server into WebSocket handler</name>
  <files>
    src/services/claude-code/claudeCodeServer.ts
  </files>
  <action>
Update claudeCodeServer.ts to integrate TerminalPTYServer with proper message routing.

**Changes to make:**

1. Add imports at top:
```typescript
import { TerminalPTYServer } from '../terminal/terminalPTYServer';
import {
  isTerminalMessage,
  isCommandMessage,
  isFileMonitoringMessage,
  isPingMessage
} from '../terminal/messageRouter';
import type { TerminalClientMessage } from '../terminal/terminalTypes';
```

2. Add terminal server instance to ClaudeCodeServer class:
```typescript
export class ClaudeCodeServer {
  private wss: WebSocketServer;
  private executions = new Map<string, CommandExecution & { process?: ChildProcess }>();
  private fileWatchers = new Map<string, FSWatcher>();
  private monitoredPaths = new Map<string, { path: string; sessionId: string }>();
  private port: number;
  private terminalServer: TerminalPTYServer;  // ADD THIS

  constructor(port: number = 8080) {
    this.port = port;
    this.wss = new WebSocketServer({ port });
    this.terminalServer = new TerminalPTYServer();  // ADD THIS
    this.setupWebSocketHandlers();
  }
```

3. Update handleMessage to use message router (replace existing switch):
```typescript
private async handleMessage(ws: WebSocket, message: unknown): Promise<void> {
  devLogger.debug('Processing message', {
    component: 'ClaudeCodeServer',
    type: (message as Record<string, unknown>)?.type || 'unknown'
  });

  // Handle ping (heartbeat) first
  if (isPingMessage(message)) {
    ws.send(JSON.stringify({ type: 'pong' }));
    return;
  }

  // Route terminal messages to PTY server
  if (isTerminalMessage(message)) {
    await this.terminalServer.handleMessage(ws, message as TerminalClientMessage);
    return;
  }

  // Route file monitoring messages
  if (isFileMonitoringMessage(message)) {
    const msg = message as ServerMessage;
    if (msg.type === 'start_file_monitoring' && msg.projectPath && msg.sessionId) {
      await this.startFileMonitoring(ws, msg.sessionId, msg.projectPath);
    } else if (msg.type === 'stop_file_monitoring' && msg.sessionId) {
      await this.stopFileMonitoring(ws, msg.sessionId);
    }
    return;
  }

  // Route command messages (existing behavior)
  if (isCommandMessage(message)) {
    const msg = message as ServerMessage;
    switch (msg.type) {
      case 'command':
        if (msg.command) {
          await this.executeCommand(ws, msg.command);
        }
        break;
      case 'cancel':
        if (msg.executionId) {
          await this.cancelExecution(ws, msg.executionId);
        }
        break;
      case 'input':
        if (msg.executionId && msg.input) {
          await this.sendInput(ws, msg.executionId, msg.input);
        }
        break;
    }
    return;
  }

  // Unknown message type
  ws.send(JSON.stringify({
    type: 'error',
    data: `Unknown message type: ${(message as Record<string, unknown>)?.type}`
  }));
}
```

4. Update ws.on('close') to cleanup terminal clients:
```typescript
ws.on('close', () => {
  devLogger.debug('GSD client disconnected', { component: 'ClaudeCodeServer' });
  this.terminalServer.removeClient(ws);  // ADD THIS
});
```

5. Update stop() to cleanup terminal server:
```typescript
stop(): void {
  // Cancel all running executions
  for (const [, execution] of this.executions) {
    if (execution.status === 'running' && execution.process) {
      execution.process.kill('SIGTERM');
    }
  }

  // Cleanup terminal sessions
  this.terminalServer.cleanup();  // ADD THIS

  // Close all file watchers
  for (const [sessionId, watcher] of this.fileWatchers) {
    try {
      watcher.close();
    } catch (error) {
      devLogger.error('Error closing file watcher', { sessionId, error });
    }
  }
  // ... rest unchanged
}
```

Note: Keep existing executeCommand/cancelExecution/sendInput methods unchanged - they handle the legacy command pattern which will be phased out later.
  </action>
  <verify>
    `npm run typecheck` passes.
    Grep for "TerminalPTYServer" in claudeCodeServer.ts - should find import and instantiation.
    Grep for "isTerminalMessage" in claudeCodeServer.ts - should find import and usage.
  </verify>
  <done>
    WebSocket server routes terminal:* messages to TerminalPTYServer.
    Ping/pong heartbeat still works.
    Existing command/file-monitoring paths unchanged.
    Terminal cleanup on disconnect.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update messageRouter exports and verify routing</name>
  <files>
    src/services/terminal/index.ts
  </files>
  <action>
Update index.ts to export message router:

```typescript
export { TerminalPTYServer } from './terminalPTYServer';
export type { PTYSessionState } from './terminalPTYServer';
export { OutputBuffer } from './outputBuffer';
export * from './terminalTypes';
export {
  isTerminalMessage,
  isCommandMessage,
  isFileMonitoringMessage,
  isPingMessage,
  categorizeMessage,
  type MessageCategory
} from './messageRouter';
```

Verify the complete routing path works by checking imports compile correctly.
  </action>
  <verify>
    `npm run typecheck` passes.
    All exports accessible from '@/services/terminal'.
  </verify>
  <done>
    Index exports all message router functions.
    TypeScript compiles cleanly.
    Message routing infrastructure complete.
  </done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes with no errors
2. claudeCodeServer.ts imports and uses TerminalPTYServer
3. Message routing handles all categories: terminal, command, file-monitoring, ping
4. Terminal cleanup happens on client disconnect and server stop
</verification>

<success_criteria>
- BACK-01: WebSocket server routes messages by type (terminal/mcp/file)
- Terminal messages routed to TerminalPTYServer.handleMessage()
- Existing command/file monitoring functionality preserved
- Ping/pong heartbeat works for all connections
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/85-backend-terminal/85-02-SUMMARY.md`
</output>
