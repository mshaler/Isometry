---
phase: 85-backend-terminal
plan: 05
type: execute
wave: 4
depends_on: [85-03, 85-04]
files_modified:
  - src/components/shell/Terminal.tsx
  - src/services/terminal/terminalPTYServer.ts
autonomous: false

must_haves:
  truths:
    - "User can type commands in terminal and see real output"
    - "Terminal reconnects and replays buffered output on connection loss"
    - "Mode toggle UI works correctly"
  artifacts:
    - path: "src/components/shell/Terminal.tsx"
      provides: "Terminal UI with mode toggle and reconnection"
      contains: "switchMode"
  key_links:
    - from: "src/components/shell/Terminal.tsx"
      to: "useTerminal hook"
      via: "hook usage"
      pattern: "useTerminal"
---

<objective>
Complete terminal UI integration with reconnection replay and mode toggle UI.

Purpose: TERM-05 requires automatic reconnection with output buffer replay. This plan adds reconnection handling to Terminal.tsx, plus a mode toggle UI for TERM-03. Ends with human verification checkpoint.

Output:
- Updated Terminal.tsx with reconnection and mode toggle
- Verification that full terminal flow works
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/85-backend-terminal/85-03-SUMMARY.md
@.planning/phases/85-backend-terminal/85-04-SUMMARY.md
@src/components/shell/Terminal.tsx
@src/hooks/system/useTerminal.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add reconnection handling and mode toggle to Terminal.tsx</name>
  <files>
    src/components/shell/Terminal.tsx
  </files>
  <action>
Update Terminal.tsx to include reconnection handling and mode toggle UI.

**Replace entire Terminal.tsx with:**
```typescript
import { useEffect, useRef, useState, useCallback } from 'react';
import { useTerminal } from '@/hooks';
import { ErrorBoundary } from '../ui/ErrorBoundary';
import { getClaudeCodeDispatcher, WebSocketClaudeCodeDispatcher } from '@/services/claude-code/claudeCodeWebSocketDispatcher';
import { devLogger } from '@/utils/logging';

interface TerminalProps {
  className?: string;
  onCommand?: (command: string) => void;
  initialDirectory?: string;
  shell?: string;
}

/**
 * Terminal component using @xterm/xterm with real PTY backend
 *
 * Features:
 * - Real shell execution via node-pty WebSocket
 * - Mode toggle: shell / claude-code
 * - Automatic reconnection with output replay
 * - Copy/paste support (Cmd+C/Cmd+V)
 */
export function Terminal({
  className = '',
  onCommand,
  initialDirectory,
  shell = '/bin/zsh'
}: TerminalProps) {
  const terminalContainerRef = useRef<HTMLDivElement>(null);
  const [terminalId] = useState(() => `terminal-${Math.random().toString(36).substr(2, 9)}`);
  const [isReady, setIsReady] = useState(false);
  const [reconnecting, setReconnecting] = useState(false);
  const sessionIdRef = useRef<string | null>(null);

  const {
    createTerminal,
    attachToProcess,
    dispose,
    resizeTerminal,
    getCurrentWorkingDirectory,
    terminal,
    isConnected,
    currentMode,
    switchMode
  } = useTerminal({
    workingDirectory: initialDirectory,
    shell,
    onCommand
  });

  /**
   * Handle reconnection with replay
   */
  const handleReconnect = useCallback(async () => {
    if (!sessionIdRef.current) return;

    setReconnecting(true);
    devLogger.debug('Attempting reconnection', { component: 'Terminal' });

    try {
      const dispatcher = await getClaudeCodeDispatcher();
      if (dispatcher instanceof WebSocketClaudeCodeDispatcher) {
        // Request replay of buffered output
        dispatcher.requestTerminalReplay(sessionIdRef.current);
      }
      setReconnecting(false);
    } catch (error) {
      devLogger.error('Reconnection failed', { component: 'Terminal', error });
      setReconnecting(false);
    }
  }, []);

  // Initialize terminal when container is ready
  useEffect(() => {
    if (!terminalContainerRef.current || isReady) return;

    terminalContainerRef.current.id = terminalId;

    const terminalInstance = createTerminal(terminalId);
    if (terminalInstance) {
      setIsReady(true);
      setTimeout(() => {
        attachToProcess();
      }, 100);
    }

    return () => {
      if (isReady) {
        dispose();
        setIsReady(false);
      }
    };
  }, [createTerminal, attachToProcess, dispose, terminalId, isReady]);

  // Handle resize on container size changes
  useEffect(() => {
    if (!isReady || !terminal) return;

    const handleResize = () => {
      resizeTerminal(0, 0); // Auto-fit
    };

    setTimeout(handleResize, 200);

    const resizeObserver = new ResizeObserver(handleResize);
    if (terminalContainerRef.current) {
      resizeObserver.observe(terminalContainerRef.current);
    }

    return () => {
      resizeObserver.disconnect();
    };
  }, [isReady, terminal, resizeTerminal]);

  // Handle connection status changes
  useEffect(() => {
    if (!isConnected && isReady && !reconnecting) {
      // Lost connection, attempt reconnect
      handleReconnect();
    }
  }, [isConnected, isReady, reconnecting, handleReconnect]);

  /**
   * Handle mode toggle
   */
  const handleModeToggle = useCallback(() => {
    const newMode = currentMode === 'shell' ? 'claude-code' : 'shell';
    switchMode(newMode);
  }, [currentMode, switchMode]);

  return (
    <ErrorBoundary level="component" name="Terminal">
      <div className={`terminal-wrapper h-full flex flex-col ${className}`}>
        {/* Terminal Header */}
        <div className="terminal-header flex-shrink-0 h-8 bg-gray-800 flex items-center justify-between px-3">
          <div className="flex items-center gap-2">
            <div className="flex gap-1">
              <div className="w-3 h-3 rounded-full bg-red-500"></div>
              <div className="w-3 h-3 rounded-full bg-yellow-500"></div>
              <div className="w-3 h-3 rounded-full bg-green-500"></div>
            </div>
            <span className="text-white text-sm font-mono">
              Terminal - {getCurrentWorkingDirectory().replace('/Users/mshaler', '~')}
            </span>
          </div>

          <div className="flex items-center gap-3">
            {/* Mode Toggle */}
            <button
              onClick={handleModeToggle}
              className={`px-2 py-0.5 text-xs rounded transition-colors ${
                currentMode === 'claude-code'
                  ? 'bg-purple-600 text-white'
                  : 'bg-gray-600 text-gray-200 hover:bg-gray-500'
              }`}
              title={`Switch to ${currentMode === 'shell' ? 'Claude Code' : 'Shell'} mode`}
            >
              {currentMode === 'claude-code' ? 'ü§ñ Claude' : 'üíª Shell'}
            </button>

            {/* Connection Status */}
            <div className="text-gray-400 text-xs flex items-center gap-1">
              <span className={isConnected ? 'text-green-400' : 'text-red-400'}>
                {isConnected ? '‚óè' : '‚óã'}
              </span>
              <span>
                {reconnecting ? 'Reconnecting...' : isConnected ? 'Connected' : 'Disconnected'}
              </span>
            </div>
          </div>
        </div>

        {/* Terminal Content */}
        <div
          ref={terminalContainerRef}
          className="terminal-content flex-1 bg-gray-900 overflow-hidden"
          style={{
            minHeight: '200px',
            fontFamily: 'Monaco, Menlo, Consolas, monospace'
          }}
        />

        {/* Terminal Footer */}
        <div className="terminal-footer flex-shrink-0 h-6 bg-gray-700 flex items-center justify-between px-2 text-xs text-gray-300">
          <span>Shell: {shell}</span>
          <span>Mode: {currentMode}</span>
        </div>
      </div>
    </ErrorBoundary>
  );
}

export { type TerminalProps };
export const TerminalUtils = {
  executeCommand: (terminalRef: React.RefObject<any>, cmd: string) => {
    if (terminalRef.current?.executeTerminalCommand) {
      terminalRef.current.executeTerminalCommand(cmd);
    }
  },
  writeOutput: (terminalRef: React.RefObject<any>, output: string, isError = false) => {
    if (terminalRef.current?.writeTerminalOutput) {
      terminalRef.current.writeTerminalOutput(output, isError);
    }
  }
};
```

Key changes:
- Mode toggle button in header
- Connection status indicator with reconnecting state
- Reconnection handler that requests output replay
- Footer shows current mode
  </action>
  <verify>
    `npm run typecheck` passes.
    Terminal.tsx contains mode toggle button.
    Terminal.tsx contains reconnection handling.
  </verify>
  <done>
    Terminal.tsx has mode toggle UI.
    Reconnection triggers output replay request.
    Connection status shown in header.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add ANSI escape sanitization</name>
  <files>
    src/services/terminal/outputBuffer.ts
  </files>
  <action>
Add ANSI escape sanitization to protect against xterm.js DCS sequence vulnerabilities.

**Add sanitization method to OutputBuffer:**
```typescript
/**
 * Sanitize ANSI escape sequences to prevent xterm.js RCE vulnerabilities.
 * Specifically blocks DCS (Device Control String) sequences that could
 * be exploited for code execution.
 *
 * @see https://doyensec.com/resources/Doyensec_Terminal_Emulators_RCE_blog.pdf
 */
export function sanitizeAnsiEscapes(data: string): string {
  // DCS sequences start with ESC P or 0x90
  // They're terminated by ST (ESC \\ or 0x9c)
  // Block entire DCS sequences

  // Pattern matches:
  // ESC P ... ESC \    (7-bit DCS)
  // 0x90 ... 0x9C      (8-bit DCS)
  const dcsPattern = /\x1bP[^\x1b]*\x1b\\|\x90[^\x9c]*\x9c/g;

  // Also block OSC 52 (clipboard write) which could be abused
  const osc52Pattern = /\x1b\]52;[^;]*;[^\x07\x1b]*(?:\x07|\x1b\\)/g;

  // Block DECSC/DECRC manipulation sequences that could affect state
  const stateManipPattern = /\x1b7|\x1b8|\x1b\[s|\x1b\[u/g;

  return data
    .replace(dcsPattern, '[DCS blocked]')
    .replace(osc52Pattern, '[OSC52 blocked]')
    .replace(stateManipPattern, '');
}
```

**Update append method to sanitize:**
```typescript
append(data: string): void {
  // Sanitize ANSI escapes before buffering
  const sanitized = sanitizeAnsiEscapes(data);
  const dataSize = sanitized.length;

  // ... rest of existing append logic using sanitized instead of data
}
```

Export the sanitization function for use elsewhere:
```typescript
export { sanitizeAnsiEscapes };
```
  </action>
  <verify>
    `npm run typecheck` passes.
    OutputBuffer.append calls sanitizeAnsiEscapes.
    sanitizeAnsiEscapes exported from file.
  </verify>
  <done>
    ANSI escape sanitization blocks DCS/OSC52 vulnerabilities.
    OutputBuffer sanitizes all incoming data.
    Security: xterm.js RCE vectors mitigated.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify terminal functionality end-to-end</name>
  <what-built>
    Complete terminal infrastructure with:
    - Real PTY execution via node-pty
    - WebSocket message routing
    - Output streaming to xterm.js
    - Mode toggle (shell/claude-code)
    - Reconnection with output replay
    - ANSI escape sanitization
  </what-built>
  <how-to-verify>
    1. Start the WebSocket server:
       ```bash
       cd /Users/mshaler/Developer/Projects/Isometry
       node -e "import('./src/services/claude-code/claudeCodeServer.ts').then(m => { const s = new m.ClaudeCodeServer(8080); s.start(); })"
       ```
       (Or use `npm run dev` if server auto-starts)

    2. Open the app: `npm run dev` -> http://localhost:5173

    3. Navigate to Shell tab (in Notebook panel)

    4. Test basic commands:
       - Type `ls -la` and press Enter -> should see file listing
       - Type `pwd` -> should show current directory
       - Type `echo "hello world"` -> should see output

    5. Test mode toggle:
       - Click the mode toggle button in header
       - Verify it switches between "Shell" and "Claude" labels
       - Terminal should restart in new mode

    6. Test copy/paste:
       - Select text in terminal output
       - Cmd+C to copy
       - Cmd+V to paste into command line

    7. Test reconnection (optional):
       - Kill WebSocket server (Ctrl+C in terminal running it)
       - Restart server
       - Verify terminal reconnects and shows reconnecting status

    Expected:
    - All commands execute and show real output
    - Mode toggle switches cleanly
    - Copy/paste works
    - Connection status accurate
  </how-to-verify>
  <resume-signal>Type "approved" if all tests pass, or describe issues to address</resume-signal>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes
2. Terminal executes real commands
3. Mode toggle switches between shell and claude-code
4. Reconnection replays buffered output
5. ANSI sanitization active
</verification>

<success_criteria>
- TERM-01: Shell commands execute via node-pty
- TERM-02: stdout/stderr streams in real-time
- TERM-03: Mode toggle works
- TERM-04: Process lifecycle handled (spawn/kill)
- TERM-05: Reconnection with replay works
- BACK-01: WebSocket routes terminal messages
- BACK-02: node-pty integrated
- BACK-05: No command string interpolation (secure)
- Human verification confirms working terminal
</success_criteria>

<output>
After completion, create `.planning/phases/85-backend-terminal/85-05-SUMMARY.md`
</output>
