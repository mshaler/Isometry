# Phase 30.1: Core Architecture Setup - Research

**Researched:** 2026-01-31
**Domain:** React TypeScript component architecture with D3.js grid systems
**Confidence:** HIGH

## Summary

Researched the implementation requirements for Phase 30.1: Core Architecture Setup, which involves building a complete 4-grid SuperGrid component structure integrating React TypeScript with D3.js visualization. The project has a solid existing foundation with D3SparsityLayer, coordinate systems, and PAFV context already implemented. The architecture follows a well-defined 4-quadrant structure: MiniNav (control), Column Headers, Row Headers, and Data Cells.

The standard approach is to create a modular React component hierarchy that leverages existing D3 integration patterns, TypeScript interfaces, and coordinate system utilities. The current codebase demonstrates mature patterns including hooks-based state management, proper D3/React integration via refs, and established PAFV (Planes → Axes → Facets → Values) architecture.

**Primary recommendation:** Build SuperGridContainer as a composition root that orchestrates existing components while adding enhanced MiniNav integration and coordinate system binding.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| React | 18+ | Component framework | Modern hooks-based API, excellent TypeScript integration |
| TypeScript | 5.0+ | Type safety | Industry standard for large React applications |
| D3.js | 7.x | Data visualization | Established pattern for complex grid visualizations |
| @types/d3 | Latest | D3 TypeScript types | Essential for TypeScript D3 integration |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| React.useRef | Built-in | D3/React DOM integration | Required for D3 DOM manipulation |
| React.useMemo | Built-in | Performance optimization | Coordinate calculations, data transformations |
| React.useCallback | Built-in | Event handler stability | D3 callbacks, parent component communication |
| CSS Grid/Flexbox | Native | Layout structure | Container positioning, responsive design |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| D3.js | Canvas-based solutions | Better performance but less DOM integration |
| Custom state | Zustand/Redux | More complexity for this use case |
| CSS-in-JS | Styled components | Current setup uses CSS modules effectively |

**Installation:**
```bash
# Core dependencies already installed
npm install --save-dev @types/node
```

## Architecture Patterns

### Recommended Project Structure
```
src/components/supergrid/
├── SuperGridContainer.tsx    # Main orchestrator component
├── MiniNav.tsx               # Enhanced navigation (existing, needs updates)
├── DataCellsQuadrant.tsx     # Data cells container (new)
└── hooks/
    └── useSupergridCoordinates.ts # Coordinate system integration (new)
```

### Pattern 1: Composition Root Container
**What:** SuperGridContainer acts as composition root, orchestrating all 4 quadrants
**When to use:** For complex components with multiple coordinated sub-systems
**Example:**
```typescript
// Source: Current codebase pattern + React composition best practices
const SuperGridContainer: FC<SuperGridProps> = ({ data, initialConfig }) => {
  const coordinateSystem = useSupergridCoordinates(initialConfig);
  const pafv = usePAFV();

  return (
    <div className="supergrid-container">
      <div className="quadrant-1">
        <MiniNav
          coordinateSystem={coordinateSystem.simple}
          pafvState={pafv.state}
          onPAFVChange={pafv.handleChange}
        />
      </div>
      <div className="quadrant-2">
        <ColumnHeadersQuadrant coordinates={coordinateSystem} />
      </div>
      <div className="quadrant-3">
        <RowHeadersQuadrant coordinates={coordinateSystem} />
      </div>
      <div className="quadrant-4">
        <DataCellsQuadrant
          data={data}
          coordinates={coordinateSystem}
          onCellClick={handleCellClick}
        />
      </div>
    </div>
  );
};
```

### Pattern 2: Enhanced Hook for Coordinate System
**What:** useSupergridCoordinates consolidates coordinate system logic
**When to use:** When multiple components need coordinated positioning data
**Example:**
```typescript
// Source: Existing useGridCoordinates.ts + coordinate-system.ts patterns
export function useSupergridCoordinates(config: CoordinateConfig) {
  const coordinateSystem = useMemo(() =>
    createCoordinateSystem(config.pattern, config.cellWidth, config.cellHeight),
    [config.pattern, config.cellWidth, config.cellHeight]
  );

  const simpleCoordinateSystem = useMemo(() => ({
    pattern: coordinateSystem.pattern || config.pattern,
    scale: coordinateSystem.scale || 1,
    viewportWidth: coordinateSystem.viewportWidth || window.innerWidth,
    viewportHeight: coordinateSystem.viewportHeight || window.innerHeight,
  }), [coordinateSystem, config.pattern]);

  return { full: coordinateSystem, simple: simpleCoordinateSystem };
}
```

### Pattern 3: D3 Integration via Refs
**What:** Each quadrant manages its own D3 rendering via React refs
**When to use:** For complex D3 visualizations that need React lifecycle coordination
**Example:**
```typescript
// Source: D3SparsityLayer.tsx pattern
const DataCellsQuadrant: FC<DataCellsProps> = ({ data, coordinates, onCellClick }) => {
  const svgRef = useD3Zoom({ onZoom: handleZoomChange });
  const containerRef = useRef<SVGGElement>(null);

  useEffect(() => {
    if (!containerRef.current) return;

    const container = d3.select(containerRef.current);
    renderDataCells({ container, cells: data, coordinateSystem: coordinates, onCellClick });
  }, [data, coordinates, onCellClick]);

  return (
    <svg ref={svgRef}>
      <g ref={containerRef} className="data-cells-container" />
    </svg>
  );
};
```

### Anti-Patterns to Avoid
- **Direct DOM Manipulation in React**: Use refs and useEffect for D3 integration
- **Prop Drilling**: Leverage context for shared state (PAFV context already exists)
- **Premature Optimization**: Start with clear component boundaries, optimize later

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Coordinate system transformation | Custom transform logic | existing `createCoordinateSystem` | Handles bipolar/anchor patterns, viewport calculations |
| D3/React integration | Custom DOM bridging | existing `useD3Zoom`, ref patterns | Properly manages React lifecycle with D3 |
| PAFV state management | Custom axis mapping | existing `PAFVContext`, `usePAFV` | Handles URL persistence, mapping logic |
| Grid coordinate calculations | Custom positioning logic | existing `useGridCoordinates` | Optimized with memoization, handles axis transformations |

**Key insight:** The project has mature utilities for coordinate systems, D3 integration, and PAFV state. Focus on composition and coordination rather than rebuilding foundational systems.

## Common Pitfalls

### Pitfall 1: D3/React DOM Conflicts
**What goes wrong:** Direct D3 DOM manipulation conflicts with React's virtual DOM
**Why it happens:** D3 and React both want to control the same DOM elements
**How to avoid:** Use React refs to give D3 specific DOM territories, coordinate via useEffect
**Warning signs:** Elements disappearing on re-render, event handlers not working

### Pitfall 2: Coordinate System Misalignment
**What goes wrong:** Different quadrants using inconsistent coordinate systems
**Why it happens:** Each quadrant creates its own coordinate transformation
**How to avoid:** Single source of truth via `useSupergridCoordinates` hook
**Warning signs:** Headers not aligning with data cells, zoom affecting quadrants differently

### Pitfall 3: PAFV State Synchronization Issues
**What goes wrong:** MiniNav changes not propagating to data quadrants
**Why it happens:** Multiple components subscribing to PAFV context inconsistently
**How to avoid:** Use existing `usePAFV` hook consistently, avoid local state duplication
**Warning signs:** Axis changes not updating grid, view mode switches failing

### Pitfall 4: Performance Issues with Large Data Sets
**What goes wrong:** Re-rendering entire grid on minor changes
**Why it happens:** Poor memoization, unnecessary re-calculations
**How to avoid:** Proper useCallback/useMemo usage, leverage existing coordinate caching
**Warning signs:** Lag during zoom/pan, slow axis changes

## Code Examples

Verified patterns from official sources:

### SuperGrid Container Structure
```typescript
// Source: Existing SuperGridDemo.tsx + architecture docs
interface SuperGridContainerProps {
  data: Node[];
  initialPAFVState?: PAFVState;
  onSelectionChange?: (nodes: Node[]) => void;
}

export const SuperGridContainer: FC<SuperGridContainerProps> = ({
  data,
  initialPAFVState,
  onSelectionChange
}) => {
  const coordinateSystem = useSupergridCoordinates({
    pattern: 'anchor',
    cellWidth: 120,
    cellHeight: 60,
  });

  return (
    <div className="supergrid-layout">
      <div className="supergrid-quadrant-1">
        <MiniNav
          coordinateSystem={coordinateSystem.simple}
          pafvState={pafv.state}
          onPAFVChange={pafv.handleStateChange}
          onOriginChange={coordinateSystem.setPattern}
          onZoom={coordinateSystem.setScale}
        />
      </div>
      <div className="supergrid-quadrant-4">
        <DataCellsQuadrant
          data={data}
          coordinateSystem={coordinateSystem.full}
          onCellClick={handleCellClick}
        />
      </div>
    </div>
  );
};
```

### Enhanced useSupergridCoordinates Hook
```typescript
// Source: coordinate-system.ts + useGridCoordinates.ts patterns
export function useSupergridCoordinates(initialConfig: CoordinateConfig) {
  const [config, setConfig] = useState(initialConfig);

  const fullCoordinateSystem = useMemo(() =>
    createCoordinateSystem(config.pattern, config.cellWidth, config.cellHeight),
    [config]
  );

  const simpleCoordinateSystem = useMemo<CoordinateSystem>(() => ({
    pattern: fullCoordinateSystem.pattern || config.pattern,
    scale: fullCoordinateSystem.scale || 1,
    viewportWidth: fullCoordinateSystem.viewportWidth || window.innerWidth,
    viewportHeight: fullCoordinateSystem.viewportHeight || window.innerHeight,
  }), [fullCoordinateSystem, config]);

  const updatePattern = useCallback((pattern: OriginPattern) => {
    setConfig(prev => ({ ...prev, pattern }));
  }, []);

  const updateCellSize = useCallback((width: number, height: number) => {
    setConfig(prev => ({ ...prev, cellWidth: width, cellHeight: height }));
  }, []);

  return {
    full: fullCoordinateSystem,
    simple: simpleCoordinateSystem,
    setPattern: updatePattern,
    setCellSize: updateCellSize,
    config,
  };
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Class components | Function components + hooks | React 16.8+ (2019) | Better reusability, cleaner code |
| Manual D3 lifecycle | useEffect + refs pattern | React integration maturity | Proper React/D3 coordination |
| Custom coordinate logic | Established coordinate-system.ts | Project evolution | Standardized positioning logic |
| Prop drilling | Context API for PAFV state | Recent refactoring | Cleaner component interfaces |

**Deprecated/outdated:**
- Direct DOM manipulation in React components: use refs and useEffect
- Class-based D3 integration: use hooks-based patterns

## Open Questions

Things that couldn't be fully resolved:

1. **MiniNav Enhancement Requirements**
   - What we know: Current MiniNav exists and works with PAFV context
   - What's unclear: Specific enhancements needed for 4-grid integration
   - Recommendation: Review current MiniNav implementation to identify gaps

2. **DataCellsQuadrant Performance Requirements**
   - What we know: D3SparsityLayer handles data cell rendering efficiently
   - What's unclear: Whether DataCellsQuadrant is wrapper or replacement
   - Recommendation: Clarify relationship with existing D3SparsityLayer

3. **Type Definition Enhancements**
   - What we know: Existing types support current implementation
   - What's unclear: Specific type enhancements needed for 4-grid structure
   - Recommendation: Audit existing types during implementation

## Sources

### Primary (HIGH confidence)
- `/src/components/SuperGridDemo.tsx` - Current implementation patterns verified
- `/src/components/D3SparsityLayer.tsx` - D3/React integration patterns verified
- `/src/hooks/useGridCoordinates.ts` - Coordinate calculation patterns verified
- `/src/utils/coordinate-system.ts` - Coordinate system utilities verified
- `/src/state/PAFVContext.tsx` - State management patterns verified
- `/docs/V1V2_Port/SuperGrid.md` - Architecture documentation verified

### Secondary (MEDIUM confidence)
- React TypeScript best practices 2026 - WebSearch verified with React community sources
- D3.js React integration patterns - WebSearch verified with multiple technical sources

### Tertiary (LOW confidence)
- None - all findings supported by primary project sources

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - based on existing project dependencies and patterns
- Architecture: HIGH - clear patterns exist in codebase with detailed documentation
- Pitfalls: HIGH - identified from existing code patterns and common D3/React issues

**Research date:** 2026-01-31
**Valid until:** 2026-03-02 (30 days - stable React/D3 patterns, established project architecture)