---
phase: 87-gsd-file-synchronization
plan: 05
type: execute
wave: 3
depends_on: ["87-03", "87-04"]
files_modified:
  - src/services/gsd/gsdConflictResolver.ts
  - src/components/shell/GSDConflictModal.tsx
  - src/services/gsd/gsdFileSyncService.ts
  - src/services/gsd/index.ts
  - src/components/shell/index.ts
  - src/hooks/useGSDFileSync.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "System detects concurrent edits when file changes externally while UI has pending changes"
    - "User sees conflict resolution modal with both versions"
    - "User can choose to keep file version, keep UI version, or cancel"
  artifacts:
    - path: "src/services/gsd/gsdConflictResolver.ts"
      provides: "Conflict detection comparing file vs UI state"
      exports: ["detectConflict", "ConflictData", "ConflictResolution"]
    - path: "src/components/shell/GSDConflictModal.tsx"
      provides: "Modal UI for conflict resolution choices"
      exports: ["GSDConflictModal"]
  key_links:
    - from: "src/services/gsd/gsdFileSyncService.ts"
      to: "src/services/gsd/gsdConflictResolver.ts"
      via: "conflict check before file update broadcast"
      pattern: "detectConflict"
    - from: "src/components/shell/GSDConflictModal.tsx"
      to: "useGSDTaskToggle"
      via: "resolution action"
      pattern: "onResolve.*keepUI"
    - from: "src/hooks/useGSDFileSync.ts"
      to: "src/components/shell/GSDConflictModal.tsx"
      via: "gsd_conflict message triggers modal open"
      pattern: "case 'gsd_conflict'"
---

<objective>
Implement conflict detection and resolution UI for concurrent GSD file edits.

Purpose: When Claude Code modifies a PLAN.md file while the user has unsaved UI changes, the system must detect this and allow the user to choose which version to keep.

Output: `gsdConflictResolver.ts` detection logic and `GSDConflictModal.tsx` resolution UI with WebSocket wiring.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/87-gsd-file-synchronization/87-03-SUMMARY.md
@.planning/phases/87-gsd-file-synchronization/87-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create conflict detection service</name>
  <files>
    src/services/gsd/gsdConflictResolver.ts
    src/services/gsd/index.ts
  </files>
  <action>
Create `gsdConflictResolver.ts`:

```typescript
import type { ParsedPlanFile, GSDTask, TaskStatus } from './gsdTypes';

export interface TaskDiff {
  taskIndex: number;
  taskName: string;
  field: 'status';
  fileValue: TaskStatus;
  uiValue: TaskStatus;
}

export interface ConflictData {
  planPath: string;
  fileVersion: ParsedPlanFile;
  uiVersion: ParsedPlanFile;
  timestamp: Date;
  diffs: TaskDiff[];
}

export type ConflictResolution = 'keep_file' | 'keep_ui' | 'cancel';

/**
 * Detect conflicts between file state and UI state
 *
 * A conflict exists when:
 * 1. File has changed since last sync (detected by file watcher)
 * 2. UI has unsaved changes (task statuses differ from last synced state)
 * 3. The changes affect the same tasks
 */
export function detectConflict(
  fileVersion: ParsedPlanFile,
  uiVersion: ParsedPlanFile
): ConflictData | null {
  const diffs: TaskDiff[] = [];

  // Compare task statuses
  const minLength = Math.min(fileVersion.tasks.length, uiVersion.tasks.length);

  for (let i = 0; i < minLength; i++) {
    const fileTask = fileVersion.tasks[i];
    const uiTask = uiVersion.tasks[i];

    if (fileTask.status !== uiTask.status) {
      diffs.push({
        taskIndex: i,
        taskName: fileTask.name,
        field: 'status',
        fileValue: fileTask.status,
        uiValue: uiTask.status
      });
    }
  }

  // If task count changed, that's also a conflict
  if (fileVersion.tasks.length !== uiVersion.tasks.length) {
    // Add a synthetic diff for task count change
    // This is a significant structural change
    return {
      planPath: fileVersion.filePath,
      fileVersion,
      uiVersion,
      timestamp: new Date(),
      diffs: [
        ...diffs,
        {
          taskIndex: -1,
          taskName: '(task count changed)',
          field: 'status',
          fileValue: `${fileVersion.tasks.length} tasks` as unknown as TaskStatus,
          uiValue: `${uiVersion.tasks.length} tasks` as unknown as TaskStatus
        }
      ]
    };
  }

  if (diffs.length === 0) {
    return null; // No conflict
  }

  return {
    planPath: fileVersion.filePath,
    fileVersion,
    uiVersion,
    timestamp: new Date(),
    diffs
  };
}

/**
 * Apply conflict resolution
 *
 * @returns The ParsedPlanFile to use based on resolution choice
 */
export function applyResolution(
  conflict: ConflictData,
  resolution: ConflictResolution
): ParsedPlanFile | null {
  switch (resolution) {
    case 'keep_file':
      // Use file version - UI will update to match
      return conflict.fileVersion;
    case 'keep_ui':
      // Use UI version - need to write back to file
      return conflict.uiVersion;
    case 'cancel':
      // User cancelled - keep current state, don't do anything
      return null;
    default:
      return null;
  }
}

/**
 * Format conflict for display
 */
export function formatConflictSummary(conflict: ConflictData): string {
  const taskDiffs = conflict.diffs.filter(d => d.taskIndex >= 0);
  const structuralDiffs = conflict.diffs.filter(d => d.taskIndex < 0);

  let summary = '';

  if (structuralDiffs.length > 0) {
    summary += 'Plan structure changed (tasks added/removed)\n\n';
  }

  if (taskDiffs.length > 0) {
    summary += `${taskDiffs.length} task(s) have different statuses:\n`;
    for (const diff of taskDiffs) {
      summary += `  - ${diff.taskName}: File="${diff.fileValue}" vs UI="${diff.uiValue}"\n`;
    }
  }

  return summary;
}
```

Update `index.ts` to export conflict resolver functions and types.
  </action>
  <verify>
Run `npm run typecheck` - no errors in gsdConflictResolver.ts.
  </verify>
  <done>Conflict detection service created with diff tracking and resolution logic</done>
</task>

<task type="auto">
  <name>Task 2: Create conflict resolution modal with WebSocket wiring</name>
  <files>
    src/components/shell/GSDConflictModal.tsx
    src/hooks/useGSDFileSync.ts
    src/components/shell/index.ts
  </files>
  <action>
Create `GSDConflictModal.tsx`:

```typescript
import React from 'react';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle
} from '../ui/dialog';
import { Button } from '../ui/button';
import { AlertTriangle, FileText, Monitor, X } from 'lucide-react';
import type { ConflictData, ConflictResolution } from '../../services/gsd/gsdConflictResolver';
import { formatConflictSummary } from '../../services/gsd/gsdConflictResolver';

interface GSDConflictModalProps {
  conflict: ConflictData | null;
  onResolve: (resolution: ConflictResolution) => void;
  isOpen: boolean;
}

const STATUS_COLORS: Record<string, string> = {
  pending: 'text-gray-500',
  in_progress: 'text-blue-500',
  complete: 'text-green-500'
};

export function GSDConflictModal({
  conflict,
  onResolve,
  isOpen
}: GSDConflictModalProps) {
  if (!conflict) return null;

  const taskDiffs = conflict.diffs.filter(d => d.taskIndex >= 0);

  return (
    <Dialog open={isOpen} onOpenChange={(open) => !open && onResolve('cancel')}>
      <DialogContent className="max-w-lg">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <AlertTriangle className="w-5 h-5 text-yellow-500" />
            Conflict Detected
          </DialogTitle>
          <DialogDescription>
            The plan file was modified externally while you had unsaved changes.
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-4 py-4">
          {/* Plan info */}
          <div className="text-sm text-gray-600">
            <span className="font-medium">File:</span> {conflict.planPath}
          </div>

          {/* Diff list */}
          <div className="border border-gray-200 rounded-lg overflow-hidden">
            <div className="bg-gray-50 px-3 py-2 text-sm font-medium text-gray-700 border-b">
              Conflicting Changes ({taskDiffs.length})
            </div>
            <ul className="divide-y divide-gray-100 max-h-48 overflow-y-auto">
              {taskDiffs.map((diff) => (
                <li key={diff.taskIndex} className="p-3">
                  <div className="text-sm font-medium text-gray-900 mb-1">
                    {diff.taskName}
                  </div>
                  <div className="flex items-center gap-4 text-xs">
                    <span className="flex items-center gap-1">
                      <FileText className="w-3 h-3" />
                      File: <span className={STATUS_COLORS[diff.fileValue]}>{diff.fileValue}</span>
                    </span>
                    <span className="flex items-center gap-1">
                      <Monitor className="w-3 h-3" />
                      UI: <span className={STATUS_COLORS[diff.uiValue]}>{diff.uiValue}</span>
                    </span>
                  </div>
                </li>
              ))}
            </ul>
          </div>

          {/* Warning about structural changes */}
          {conflict.diffs.some(d => d.taskIndex < 0) && (
            <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-3 text-sm text-yellow-800">
              <strong>Warning:</strong> The plan structure has changed (tasks were added or removed).
              Keeping your UI version may overwrite these changes.
            </div>
          )}
        </div>

        <DialogFooter className="flex gap-2">
          <Button
            variant="outline"
            onClick={() => onResolve('cancel')}
            className="flex items-center gap-2"
          >
            <X className="w-4 h-4" />
            Cancel
          </Button>
          <Button
            variant="secondary"
            onClick={() => onResolve('keep_file')}
            className="flex items-center gap-2"
          >
            <FileText className="w-4 h-4" />
            Keep File Version
          </Button>
          <Button
            variant="default"
            onClick={() => onResolve('keep_ui')}
            className="flex items-center gap-2"
          >
            <Monitor className="w-4 h-4" />
            Keep My Changes
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
```

**CRITICAL: Wire useGSDFileSync to handle gsd_conflict messages and expose conflict state:**

Update `src/hooks/useGSDFileSync.ts` to add conflict handling in the message listener:

```typescript
// Add to imports
import type { ConflictData, ConflictResolution } from '../services/gsd/gsdConflictResolver';

// Update the state interface
interface GSDFileSyncState {
  isConnected: boolean;
  isWatching: boolean;
  lastUpdate: Date | null;
  conflict: ConflictData | null;  // NEW: track active conflict
  isConflictModalOpen: boolean;   // NEW: modal visibility
}

// Update initial state
const [state, setState] = useState<GSDFileSyncState>({
  isConnected: false,
  isWatching: false,
  lastUpdate: null,
  conflict: null,
  isConflictModalOpen: false
});

// Add gsd_conflict case to message handler switch statement:
case 'gsd_conflict': {
  // Server detected conflict - show modal to user
  const conflictData = message.conflict as ConflictData;
  setState(prev => ({
    ...prev,
    conflict: conflictData,
    isConflictModalOpen: true
  }));
  break;
}

case 'gsd_conflict_resolved': {
  // Conflict resolved - close modal and update cache
  setState(prev => ({
    ...prev,
    conflict: null,
    isConflictModalOpen: false
  }));
  // Update query cache with resolved data
  queryClient.setQueryData(
    ['gsd-plan', message.planPath],
    message.data
  );
  break;
}

// Add resolveConflict callback to handle user's modal choice:
const resolveConflict = useCallback((resolution: ConflictResolution) => {
  if (ws?.readyState === WebSocket.OPEN && state.conflict) {
    ws.send(JSON.stringify({
      type: 'gsd_resolve_conflict',
      sessionId,
      planPath: state.conflict.planPath,
      resolution,
      conflict: state.conflict
    }));
    // Optimistically close modal
    setState(prev => ({
      ...prev,
      isConflictModalOpen: false
    }));
  }
}, [ws, sessionId, state.conflict]);

// Update return value to include conflict state and handler:
return {
  ...state,
  ws,
  requestPlan,
  resolveConflict  // NEW: expose for GSDConflictModal
};
```

Update `src/components/shell/index.ts` to export the modal.

Note: Uses shadcn/ui Dialog and Button components. If not available, the component structure is correct - just needs the right imports adjusted.
  </action>
  <verify>
Run `npm run typecheck` - no errors in GSDConflictModal.tsx or useGSDFileSync.ts.
Verify useGSDFileSync now:
1. Handles 'gsd_conflict' message type in switch
2. Exposes conflict, isConflictModalOpen, and resolveConflict in return value
3. Sends 'gsd_resolve_conflict' message when user chooses resolution
  </verify>
  <done>Conflict modal component created with diff display and resolution buttons, wired to useGSDFileSync via gsd_conflict WebSocket messages</done>
</task>

<task type="auto">
  <name>Task 3: Integrate conflict detection into sync service</name>
  <files>
    src/services/gsd/gsdFileSyncService.ts
  </files>
  <action>
Update `gsdFileSyncService.ts` to track last synced state and detect conflicts:

Add imports:
```typescript
import { detectConflict, applyResolution, ConflictData, ConflictResolution } from './gsdConflictResolver';
```

Add state tracking:
```typescript
export class GSDFileSyncService {
  private fileWatcher: GSDFileWatcher;
  private lastSyncedState = new Map<string, ParsedPlanFile>(); // planPath -> last synced state

  // ... existing constructor ...
```

Update the file change handling in `handleMessage` or add a new method:

```typescript
  /**
   * Handle file update from watcher - check for conflicts before broadcasting
   */
  async handleFileChange(
    ws: WebSocket,
    sessionId: string,
    planPath: string,
    newFileState: ParsedPlanFile
  ): Promise<{ hasConflict: boolean; conflict?: ConflictData }> {
    const lastSynced = this.lastSyncedState.get(planPath);

    if (!lastSynced) {
      // First load - no conflict possible
      this.lastSyncedState.set(planPath, newFileState);
      return { hasConflict: false };
    }

    // Check if there are pending UI changes (compare current query cache state)
    // This is a simplified check - in practice, we'd compare against the React Query cache
    // For now, we detect conflicts on task status changes
    const conflict = detectConflict(newFileState, lastSynced);

    if (conflict) {
      // Send conflict notification to client
      ws.send(JSON.stringify({
        type: 'gsd_conflict',
        sessionId,
        planPath,
        conflict
      }));
      return { hasConflict: true, conflict };
    }

    // No conflict - update synced state
    this.lastSyncedState.set(planPath, newFileState);
    return { hasConflict: false };
  }

  /**
   * Handle conflict resolution from client
   */
  async handleConflictResolution(
    ws: WebSocket,
    sessionId: string,
    planPath: string,
    resolution: ConflictResolution,
    conflict: ConflictData
  ): Promise<void> {
    const resolved = applyResolution(conflict, resolution);

    if (resolution === 'keep_ui' && resolved) {
      // Write UI version back to file
      this.fileWatcher.markWritePath(`.planning/${planPath}`);

      // Need to write the full file back
      // For now, we'll just update each differing task
      for (const diff of conflict.diffs.filter(d => d.taskIndex >= 0)) {
        await updateTaskStatus(
          this.projectPath,
          planPath,
          diff.taskIndex,
          diff.uiValue
        );
      }
    }

    // Update last synced state
    const newState = resolution === 'keep_ui' ? conflict.uiVersion : conflict.fileVersion;
    this.lastSyncedState.set(planPath, newState);

    // Notify client of resolution
    ws.send(JSON.stringify({
      type: 'gsd_conflict_resolved',
      sessionId,
      planPath,
      resolution,
      data: newState
    }));
  }
```

Add message handling for conflict resolution in the switch:
```typescript
case 'gsd_resolve_conflict':
  if (!message.planPath || !message.resolution || !message.conflict) {
    throw new Error('planPath, resolution, and conflict required');
  }
  await this.handleConflictResolution(
    ws,
    message.sessionId,
    message.planPath,
    message.resolution as ConflictResolution,
    message.conflict as ConflictData
  );
  break;
```
  </action>
  <verify>
Run `npm run typecheck` - no errors in gsdFileSyncService.ts.
  </verify>
  <done>Conflict detection and resolution integrated into sync service</done>
</task>

</tasks>

<verification>
- [ ] detectConflict identifies task status differences between file and UI versions
- [ ] GSDConflictModal displays diff list with file vs UI values
- [ ] Resolution buttons trigger correct actions (keep_file, keep_ui, cancel)
- [ ] useGSDFileSync handles 'gsd_conflict' WebSocket messages and opens modal
- [ ] useGSDFileSync exposes resolveConflict callback for modal to use
- [ ] Sync service tracks last synced state per plan
- [ ] Conflict resolution writes back to file when keeping UI version
- [ ] `npm run typecheck` passes
</verification>

<success_criteria>
- When file changes externally with pending UI changes, conflict modal appears
- User can see which tasks differ between file and UI
- "Keep File Version" discards UI changes and syncs to file state
- "Keep My Changes" writes UI state back to file
- After resolution, sync continues normally without repeated conflicts
- Frontend receives gsd_conflict messages via WebSocket and displays modal
</success_criteria>

<output>
After completion, create `.planning/phases/87-gsd-file-synchronization/87-05-SUMMARY.md`
</output>
