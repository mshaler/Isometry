---
phase: 87-gsd-file-synchronization
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/gsd/gsdFileWatcher.ts
  - src/services/terminal/messageRouter.ts
  - src/services/gsd/index.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "File watcher detects .planning/ changes with <500ms debounced update"
    - "Multiple rapid file saves trigger only one update event"
    - "WebSocket message routing dispatches gsd_file messages to handler"
  artifacts:
    - path: "src/services/gsd/gsdFileWatcher.ts"
      provides: "Chokidar-based file watcher with debouncing"
      exports: ["GSDFileWatcher", "GSDFileChangeEvent"]
    - path: "src/services/terminal/messageRouter.ts"
      provides: "Message type guard for GSD file messages"
      exports: ["isGSDFileMessage"]
  key_links:
    - from: "src/services/gsd/gsdFileWatcher.ts"
      to: "chokidar"
      via: "import chokidar"
      pattern: "chokidar\\.watch"
    - from: "src/services/gsd/gsdFileWatcher.ts"
      to: "src/services/claude-code/claudeCodeServer.ts"
      via: "WebSocket message emission"
      pattern: "ws\\.send.*gsd_file_update"
---

<objective>
Implement file watcher for `.planning/` directory using chokidar with debounced updates.

Purpose: Detect file changes in GSD planning directory and emit WebSocket messages for frontend consumption. Foundation for bidirectional sync.

Output: `gsdFileWatcher.ts` with chokidar integration and debounced event emission.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/87-gsd-file-synchronization/87-RESEARCH.md
@src/services/claude-code/claudeCodeServer.ts
@src/services/terminal/messageRouter.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GSD file watcher with chokidar</name>
  <files>
    src/services/gsd/gsdFileWatcher.ts
    src/services/gsd/index.ts
  </files>
  <action>
Note: chokidar is already installed from Phase 85 (verify with `npm ls chokidar`). If not present, install it.

Create `gsdFileWatcher.ts`:

```typescript
import chokidar, { FSWatcher } from 'chokidar';
import { WebSocket } from 'ws';
import { join, relative } from 'path';
import { devLogger } from '../../utils/logging';

export interface GSDFileChangeEvent {
  type: 'gsd_file_update';
  filePath: string;        // Relative to project root
  changeType: 'add' | 'change' | 'unlink';
  timestamp: string;
  sessionId: string;
}

export class GSDFileWatcher {
  private watcher: FSWatcher | null = null;
  private clients = new Map<string, WebSocket>(); // sessionId -> ws
  private skipWatchPaths = new Set<string>();     // Paths to skip (own writes)

  constructor(private projectPath: string) {}

  startWatching(sessionId: string, ws: WebSocket): void {
    // Store client
    this.clients.set(sessionId, ws);

    // Only create one watcher per project
    if (this.watcher) return;

    const planningPath = join(this.projectPath, '.planning');

    this.watcher = chokidar.watch(planningPath, {
      ignored: /(^|[\/\\])\../,  // Ignore dotfiles
      persistent: true,
      ignoreInitial: true,
      awaitWriteFinish: {
        stabilityThreshold: 400,  // 400ms debounce per research
        pollInterval: 100
      },
      depth: 10  // Watch nested phase directories
    });

    this.watcher
      .on('add', (path) => this.emitChange(path, 'add'))
      .on('change', (path) => this.emitChange(path, 'change'))
      .on('unlink', (path) => this.emitChange(path, 'unlink'))
      .on('error', (error) => {
        devLogger.error('GSD file watcher error', { component: 'GSDFileWatcher', error });
      });

    devLogger.debug('GSD file watcher started', { component: 'GSDFileWatcher', planningPath });
  }

  stopWatching(sessionId: string): void {
    this.clients.delete(sessionId);

    // Only close watcher when no clients remain
    if (this.clients.size === 0 && this.watcher) {
      this.watcher.close();
      this.watcher = null;
      devLogger.debug('GSD file watcher stopped', { component: 'GSDFileWatcher' });
    }
  }

  // Call before writing to prevent update loop
  markWritePath(filePath: string): void {
    this.skipWatchPaths.add(filePath);
    // Auto-clear after debounce window
    setTimeout(() => this.skipWatchPaths.delete(filePath), 600);
  }

  private emitChange(fullPath: string, changeType: 'add' | 'change' | 'unlink'): void {
    // Filter to only markdown files
    if (!fullPath.endsWith('.md')) return;

    const relativePath = relative(this.projectPath, fullPath);

    // Skip own writes to prevent update loop
    if (this.skipWatchPaths.has(relativePath)) {
      devLogger.debug('Skipping own write', { component: 'GSDFileWatcher', relativePath });
      return;
    }

    devLogger.debug('GSD file change detected', { component: 'GSDFileWatcher', relativePath, changeType });

    // Broadcast to all connected clients
    for (const [sessionId, ws] of this.clients) {
      if (ws.readyState === WebSocket.OPEN) {
        const event: GSDFileChangeEvent = {
          type: 'gsd_file_update',
          filePath: relativePath,
          changeType,
          timestamp: new Date().toISOString(),
          sessionId
        };
        ws.send(JSON.stringify(event));
      }
    }
  }

  cleanup(): void {
    if (this.watcher) {
      this.watcher.close();
      this.watcher = null;
    }
    this.clients.clear();
    this.skipWatchPaths.clear();
  }
}
```

Update `index.ts` to export GSDFileWatcher and GSDFileChangeEvent.
  </action>
  <verify>
Run `npm run typecheck` - no errors.
Import test: `import { GSDFileWatcher } from './services/gsd'` compiles.
  </verify>
  <done>GSDFileWatcher class implemented with chokidar, debouncing, and skipWatch mechanism</done>
</task>

<task type="auto">
  <name>Task 2: Add GSD message routing to messageRouter</name>
  <files>
    src/services/terminal/messageRouter.ts
  </files>
  <action>
Add type guard for GSD file sync messages to existing messageRouter.ts:

```typescript
// Add to existing type guards
export function isGSDFileMessage(message: unknown): boolean {
  return (
    typeof message === 'object' &&
    message !== null &&
    'type' in message &&
    (
      (message as Record<string, unknown>).type === 'start_gsd_watch' ||
      (message as Record<string, unknown>).type === 'stop_gsd_watch' ||
      (message as Record<string, unknown>).type === 'gsd_task_update'
    )
  );
}
```

Define local interface for GSD messages (to avoid circular dependency, per Phase 85 pattern):

```typescript
interface GSDClientMessage {
  type: 'start_gsd_watch' | 'stop_gsd_watch' | 'gsd_task_update';
  sessionId?: string;
  planPath?: string;
  taskIndex?: number;
  status?: 'pending' | 'in_progress' | 'complete';
}
```

Export the type guard from the module.
  </action>
  <verify>
Run `npm run typecheck` - messageRouter.ts has no errors.
  </verify>
  <done>isGSDFileMessage type guard added to message router for WebSocket dispatch</done>
</task>

</tasks>

<verification>
- [ ] GSDFileWatcher creates chokidar watcher with awaitWriteFinish config
- [ ] File changes emit WebSocket messages with relative paths
- [ ] skipWatchPaths mechanism prevents update loops
- [ ] messageRouter exports isGSDFileMessage type guard
- [ ] `npm run typecheck` passes
</verification>

<success_criteria>
- Editing a file in `.planning/` triggers WebSocket message to connected clients
- Multiple rapid saves (within 400ms) emit only one change event
- Own writes (via markWritePath) are ignored to prevent infinite loops
</success_criteria>

<output>
After completion, create `.planning/phases/87-gsd-file-synchronization/87-02-SUMMARY.md`
</output>
