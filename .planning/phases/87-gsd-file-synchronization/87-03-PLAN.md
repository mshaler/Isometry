---
phase: 87-gsd-file-synchronization
plan: 03
type: execute
wave: 2
depends_on: ["87-01", "87-02"]
files_modified:
  - src/services/gsd/gsdFileWriter.ts
  - src/services/gsd/gsdFileSyncService.ts
  - src/services/claude-code/claudeCodeServer.ts
  - src/services/gsd/index.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can toggle task status and changes write back to files"
    - "File writes use atomic pattern (write complete before rename)"
    - "ClaudeCodeServer routes GSD messages to sync service"
  artifacts:
    - path: "src/services/gsd/gsdFileWriter.ts"
      provides: "Write task status updates back to PLAN.md files"
      exports: ["updateTaskStatus", "writeGSDPlanFile"]
    - path: "src/services/gsd/gsdFileSyncService.ts"
      provides: "Orchestrate file reading, watching, and writing"
      exports: ["GSDFileSyncService"]
  key_links:
    - from: "src/services/claude-code/claudeCodeServer.ts"
      to: "src/services/gsd/gsdFileSyncService.ts"
      via: "handleMessage dispatch"
      pattern: "gsdSyncService\\.handle"
    - from: "src/services/gsd/gsdFileSyncService.ts"
      to: "src/services/gsd/gsdFileWriter.ts"
      via: "task update flow"
      pattern: "updateTaskStatus"
    - from: "src/services/gsd/gsdFileSyncService.ts"
      to: "src/services/gsd/gsdFileWatcher.ts"
      via: "markWritePath before write"
      pattern: "fileWatcher\\.markWritePath"
---

<objective>
Implement bidirectional sync: file writes for task status updates and integrate sync service into ClaudeCodeServer.

Purpose: Complete the read-write loop so UI task toggles persist to files and file changes update UI state.

Output: `gsdFileWriter.ts` for writes, `gsdFileSyncService.ts` for orchestration, updated `claudeCodeServer.ts` routing.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/87-gsd-file-synchronization/87-01-SUMMARY.md
@.planning/phases/87-gsd-file-synchronization/87-02-SUMMARY.md
@src/services/claude-code/claudeCodeServer.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GSD file writer with atomic writes</name>
  <files>
    src/services/gsd/gsdFileWriter.ts
    src/services/gsd/index.ts
  </files>
  <action>
Create `gsdFileWriter.ts`:

```typescript
import { readFile, writeFile, rename } from 'fs/promises';
import matter from 'gray-matter';
import { join } from 'path';
import { ParsedPlanFile, TaskStatus, PlanFrontmatter } from './gsdTypes';
import { parseGSDPlanFile, extractTasks } from './gsdFileParser';
import { devLogger } from '../../utils/logging';

/**
 * Update a task's status in a PLAN.md file
 *
 * Task status is represented by presence of <done> element:
 * - 'complete': <done> element with content
 * - 'in_progress': Add <!-- status: in_progress --> comment before task
 * - 'pending': No <done> element, no status comment
 */
export async function updateTaskStatus(
  projectPath: string,
  planPath: string,      // Relative path like 'phases/87-xxx/87-01-PLAN.md'
  taskIndex: number,
  newStatus: TaskStatus
): Promise<void> {
  const fullPath = join(projectPath, '.planning', planPath);
  const fileContent = await readFile(fullPath, 'utf-8');
  const { data: frontmatter, content } = matter(fileContent);

  // Find and update the specific task
  let taskCount = 0;
  let updatedContent = content;

  // Track task positions for accurate replacement
  const taskRegex = /<task type="([^"]+)">([\s\S]*?)<\/task>/g;
  let match;
  const tasks: Array<{ start: number; end: number; content: string; type: string }> = [];

  while ((match = taskRegex.exec(content)) !== null) {
    tasks.push({
      start: match.index,
      end: match.index + match[0].length,
      content: match[2],
      type: match[1]
    });
  }

  if (taskIndex < 0 || taskIndex >= tasks.length) {
    throw new Error(`Task index ${taskIndex} out of bounds (${tasks.length} tasks)`);
  }

  const task = tasks[taskIndex];
  let newTaskContent = task.content;

  // Remove existing status comment if present
  newTaskContent = newTaskContent.replace(/<!--\s*status:\s*\w+\s*-->\n?/g, '');

  // Update based on new status
  if (newStatus === 'complete') {
    // Add <done> if not present
    if (!/<done>/.test(newTaskContent)) {
      // Find insertion point (after <verify> or at end before </task>)
      const verifyMatch = /<\/verify>/.exec(newTaskContent);
      const insertPos = verifyMatch
        ? verifyMatch.index + verifyMatch[0].length
        : newTaskContent.length;

      newTaskContent =
        newTaskContent.slice(0, insertPos) +
        '\n  <done>Task completed</done>' +
        newTaskContent.slice(insertPos);
    }
  } else if (newStatus === 'in_progress') {
    // Add status comment at start of task content
    newTaskContent = `\n  <!-- status: in_progress -->` + newTaskContent;
  } else if (newStatus === 'pending') {
    // Remove <done> element if present
    newTaskContent = newTaskContent.replace(/<done>[\s\S]*?<\/done>\n?/g, '');
  }

  // Reconstruct full task
  const newTask = `<task type="${task.type}">${newTaskContent}</task>`;

  // Replace in content
  updatedContent =
    content.slice(0, task.start) +
    newTask +
    content.slice(task.end);

  // Reconstruct file with frontmatter
  const fullContent = matter.stringify(updatedContent, frontmatter as PlanFrontmatter);

  // Atomic write: write to temp, then rename
  const tempPath = `${fullPath}.tmp`;
  await writeFile(tempPath, fullContent, 'utf-8');
  await rename(tempPath, fullPath);

  devLogger.debug('Updated task status', {
    component: 'gsdFileWriter',
    planPath,
    taskIndex,
    newStatus
  });
}

/**
 * Write a complete ParsedPlanFile back to disk
 */
export async function writeGSDPlanFile(
  projectPath: string,
  planPath: string,
  parsed: ParsedPlanFile
): Promise<void> {
  const fullPath = join(projectPath, '.planning', planPath);
  const fullContent = matter.stringify(parsed.rawContent, parsed.frontmatter as object);

  const tempPath = `${fullPath}.tmp`;
  await writeFile(tempPath, fullContent, 'utf-8');
  await rename(tempPath, fullPath);
}
```

Update `index.ts` to export file writer functions.
  </action>
  <verify>
Run `npm run typecheck` - no errors in gsdFileWriter.ts.
  </verify>
  <done>File writer implemented with atomic writes and task status update logic</done>
</task>

<task type="auto">
  <name>Task 2: Create GSD file sync service and integrate with ClaudeCodeServer</name>
  <files>
    src/services/gsd/gsdFileSyncService.ts
    src/services/claude-code/claudeCodeServer.ts
    src/services/gsd/index.ts
  </files>
  <action>
Create `gsdFileSyncService.ts`:

```typescript
import { WebSocket } from 'ws';
import { GSDFileWatcher } from './gsdFileWatcher';
import { parseGSDPlanFile } from './gsdFileParser';
import { updateTaskStatus } from './gsdFileWriter';
import { ParsedPlanFile, TaskStatus } from './gsdTypes';
import { devLogger } from '../../utils/logging';

export interface GSDSyncMessage {
  type: 'start_gsd_watch' | 'stop_gsd_watch' | 'gsd_task_update' | 'gsd_read_plan';
  sessionId: string;
  planPath?: string;
  taskIndex?: number;
  status?: TaskStatus;
}

export interface GSDSyncResponse {
  type: 'gsd_plan_data' | 'gsd_task_updated' | 'gsd_error';
  sessionId: string;
  planPath?: string;
  data?: ParsedPlanFile;
  error?: string;
}

export class GSDFileSyncService {
  private fileWatcher: GSDFileWatcher;

  constructor(private projectPath: string) {
    this.fileWatcher = new GSDFileWatcher(projectPath);
  }

  async handleMessage(ws: WebSocket, message: GSDSyncMessage): Promise<void> {
    try {
      switch (message.type) {
        case 'start_gsd_watch':
          this.fileWatcher.startWatching(message.sessionId, ws);
          ws.send(JSON.stringify({
            type: 'gsd_watch_started',
            sessionId: message.sessionId
          }));
          break;

        case 'stop_gsd_watch':
          this.fileWatcher.stopWatching(message.sessionId);
          ws.send(JSON.stringify({
            type: 'gsd_watch_stopped',
            sessionId: message.sessionId
          }));
          break;

        case 'gsd_read_plan':
          if (!message.planPath) {
            throw new Error('planPath required for gsd_read_plan');
          }
          const parsed = await parseGSDPlanFile(
            `${this.projectPath}/.planning/${message.planPath}`
          );
          ws.send(JSON.stringify({
            type: 'gsd_plan_data',
            sessionId: message.sessionId,
            planPath: message.planPath,
            data: parsed
          } as GSDSyncResponse));
          break;

        case 'gsd_task_update':
          if (!message.planPath || message.taskIndex === undefined || !message.status) {
            throw new Error('planPath, taskIndex, and status required for gsd_task_update');
          }

          // Mark path to prevent update loop from our own write
          this.fileWatcher.markWritePath(
            `.planning/${message.planPath}`
          );

          await updateTaskStatus(
            this.projectPath,
            message.planPath,
            message.taskIndex,
            message.status
          );

          ws.send(JSON.stringify({
            type: 'gsd_task_updated',
            sessionId: message.sessionId,
            planPath: message.planPath
          } as GSDSyncResponse));
          break;

        default:
          throw new Error(`Unknown GSD message type: ${(message as { type: string }).type}`);
      }
    } catch (error) {
      devLogger.error('GSD sync error', {
        component: 'GSDFileSyncService',
        error,
        messageType: message.type
      });
      ws.send(JSON.stringify({
        type: 'gsd_error',
        sessionId: message.sessionId,
        error: error instanceof Error ? error.message : 'Unknown error'
      } as GSDSyncResponse));
    }
  }

  cleanup(): void {
    this.fileWatcher.cleanup();
  }
}
```

Update `claudeCodeServer.ts`:

1. Import `isGSDFileMessage` from messageRouter
2. Import `GSDFileSyncService` from gsd
3. Create instance in constructor: `this.gsdSyncService = new GSDFileSyncService(process.cwd());`
4. In `handleMessage()`, add routing after file monitoring check:

```typescript
// Route GSD file sync messages
if (isGSDFileMessage(message)) {
  await this.gsdSyncService.handleMessage(ws, message as GSDSyncMessage);
  return;
}
```

5. In `stop()`, call `this.gsdSyncService.cleanup()`

Update `index.ts` to export GSDFileSyncService.
  </action>
  <verify>
Run `npm run typecheck` - no errors in gsd/ or claude-code/ directories.
  </verify>
  <done>GSD sync service created and integrated into WebSocket message routing</done>
</task>

</tasks>

<verification>
- [ ] gsdFileWriter.ts exports updateTaskStatus and writeGSDPlanFile
- [ ] gsdFileSyncService.ts handles all message types
- [ ] claudeCodeServer.ts routes GSD messages to sync service
- [ ] File writes use atomic pattern (temp file + rename)
- [ ] markWritePath called before writes to prevent loops
- [ ] `npm run typecheck` passes
</verification>

<success_criteria>
- WebSocket message `gsd_task_update` results in file being updated on disk
- Task status changes persist correctly (pending/in_progress/complete)
- No infinite update loops when writing files that are being watched
</success_criteria>

<output>
After completion, create `.planning/phases/87-gsd-file-synchronization/87-03-SUMMARY.md`
</output>
