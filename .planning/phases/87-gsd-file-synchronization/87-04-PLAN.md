---
phase: 87-gsd-file-synchronization
plan: 04
type: execute
wave: 2
depends_on: ["87-01"]
files_modified:
  - src/hooks/useGSDFileSync.ts
  - src/hooks/useGSDTaskToggle.ts
  - src/hooks/index.ts
  - src/components/shell/GSDProgressDisplay.tsx
  - src/components/shell/index.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User sees phase progress display auto-updated when files change"
    - "User can toggle task status (pending/in_progress/complete)"
    - "Progress percentage updates in real-time as tasks complete"
  artifacts:
    - path: "src/hooks/useGSDFileSync.ts"
      provides: "React hook for WebSocket file sync subscription"
      exports: ["useGSDFileSync"]
    - path: "src/hooks/useGSDTaskToggle.ts"
      provides: "React hook for task status mutations with optimistic updates"
      exports: ["useGSDTaskToggle"]
    - path: "src/components/shell/GSDProgressDisplay.tsx"
      provides: "Phase and task progress UI component"
      exports: ["GSDProgressDisplay"]
  key_links:
    - from: "src/hooks/useGSDFileSync.ts"
      to: "WebSocket"
      via: "message event listener"
      pattern: "ws\\.addEventListener.*gsd_file_update"
    - from: "src/components/shell/GSDProgressDisplay.tsx"
      to: "src/hooks/useGSDFileSync.ts"
      via: "hook consumption"
      pattern: "useGSDFileSync"
---

<objective>
Create React hooks and progress display component for GSD file synchronization.

Purpose: Frontend consumers need hooks to subscribe to file changes and trigger task updates. Progress display shows phase completion status.

Output: `useGSDFileSync.ts`, `useGSDTaskToggle.ts` hooks and `GSDProgressDisplay.tsx` component.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/87-gsd-file-synchronization/87-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GSD sync React hooks</name>
  <files>
    src/hooks/useGSDFileSync.ts
    src/hooks/useGSDTaskToggle.ts
    src/hooks/index.ts
  </files>
  <action>
Create `useGSDFileSync.ts`:

```typescript
import { useEffect, useCallback, useState } from 'react';
import { useQueryClient } from '@tanstack/react-query';
import type { ParsedPlanFile, GSDTask } from '../services/gsd/gsdTypes';

interface UseGSDFileSyncOptions {
  wsUrl?: string;
  sessionId: string;
  enabled?: boolean;
}

interface GSDFileSyncState {
  isConnected: boolean;
  isWatching: boolean;
  lastUpdate: Date | null;
}

export function useGSDFileSync(options: UseGSDFileSyncOptions) {
  const { wsUrl = 'ws://localhost:8080', sessionId, enabled = true } = options;
  const queryClient = useQueryClient();
  const [ws, setWs] = useState<WebSocket | null>(null);
  const [state, setState] = useState<GSDFileSyncState>({
    isConnected: false,
    isWatching: false,
    lastUpdate: null
  });

  useEffect(() => {
    if (!enabled) return;

    const socket = new WebSocket(wsUrl);

    socket.addEventListener('open', () => {
      setState(prev => ({ ...prev, isConnected: true }));
      // Start watching after connection
      socket.send(JSON.stringify({
        type: 'start_gsd_watch',
        sessionId
      }));
    });

    socket.addEventListener('close', () => {
      setState(prev => ({ ...prev, isConnected: false, isWatching: false }));
    });

    socket.addEventListener('message', (event) => {
      try {
        const message = JSON.parse(event.data);

        switch (message.type) {
          case 'gsd_watch_started':
            setState(prev => ({ ...prev, isWatching: true }));
            break;

          case 'gsd_file_update':
            // Invalidate queries for the changed file
            queryClient.invalidateQueries({
              queryKey: ['gsd-plan', message.filePath]
            });
            setState(prev => ({ ...prev, lastUpdate: new Date() }));
            break;

          case 'gsd_plan_data':
            // Update query cache with new plan data
            queryClient.setQueryData(
              ['gsd-plan', message.planPath],
              message.data
            );
            break;
        }
      } catch (error) {
        console.error('Failed to parse GSD message:', error);
      }
    });

    setWs(socket);

    return () => {
      if (socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({
          type: 'stop_gsd_watch',
          sessionId
        }));
      }
      socket.close();
    };
  }, [wsUrl, sessionId, enabled, queryClient]);

  const requestPlan = useCallback((planPath: string) => {
    if (ws?.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({
        type: 'gsd_read_plan',
        sessionId,
        planPath
      }));
    }
  }, [ws, sessionId]);

  return {
    ...state,
    ws,
    requestPlan
  };
}
```

Create `useGSDTaskToggle.ts`:

```typescript
import { useMutation, useQueryClient } from '@tanstack/react-query';
import type { TaskStatus, ParsedPlanFile } from '../services/gsd/gsdTypes';

interface UseGSDTaskToggleOptions {
  ws: WebSocket | null;
  sessionId: string;
  planPath: string;
}

interface TaskUpdateVariables {
  taskIndex: number;
  status: TaskStatus;
}

export function useGSDTaskToggle(options: UseGSDTaskToggleOptions) {
  const { ws, sessionId, planPath } = options;
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ taskIndex, status }: TaskUpdateVariables) => {
      if (!ws || ws.readyState !== WebSocket.OPEN) {
        throw new Error('WebSocket not connected');
      }

      return new Promise<void>((resolve, reject) => {
        const timeout = setTimeout(() => {
          reject(new Error('Task update timeout'));
        }, 5000);

        const handler = (event: MessageEvent) => {
          try {
            const message = JSON.parse(event.data);
            if (message.type === 'gsd_task_updated' && message.planPath === planPath) {
              clearTimeout(timeout);
              ws.removeEventListener('message', handler);
              resolve();
            } else if (message.type === 'gsd_error') {
              clearTimeout(timeout);
              ws.removeEventListener('message', handler);
              reject(new Error(message.error));
            }
          } catch {
            // Ignore parse errors for other messages
          }
        };

        ws.addEventListener('message', handler);
        ws.send(JSON.stringify({
          type: 'gsd_task_update',
          sessionId,
          planPath,
          taskIndex,
          status
        }));
      });
    },

    // Optimistic update
    onMutate: async ({ taskIndex, status }) => {
      await queryClient.cancelQueries({ queryKey: ['gsd-plan', planPath] });
      const previous = queryClient.getQueryData<ParsedPlanFile>(['gsd-plan', planPath]);

      if (previous) {
        queryClient.setQueryData<ParsedPlanFile>(['gsd-plan', planPath], {
          ...previous,
          tasks: previous.tasks.map((task, i) =>
            i === taskIndex ? { ...task, status } : task
          )
        });
      }

      return { previous };
    },

    // Rollback on error
    onError: (_err, _variables, context) => {
      if (context?.previous) {
        queryClient.setQueryData(['gsd-plan', planPath], context.previous);
      }
    },

    // Refetch to ensure consistency
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: ['gsd-plan', planPath] });
    }
  });
}

/**
 * Helper to cycle through task statuses
 */
export function nextTaskStatus(current: TaskStatus): TaskStatus {
  switch (current) {
    case 'pending':
      return 'in_progress';
    case 'in_progress':
      return 'complete';
    case 'complete':
      return 'pending';
    default:
      return 'pending';
  }
}
```

Update `src/hooks/index.ts` to export both hooks.
  </action>
  <verify>
Run `npm run typecheck` - no errors in hooks directory.
  </verify>
  <done>GSD sync hooks created with WebSocket subscription and optimistic updates</done>
</task>

<task type="auto">
  <name>Task 2: Create GSD progress display component</name>
  <files>
    src/components/shell/GSDProgressDisplay.tsx
    src/components/shell/index.ts
  </files>
  <action>
Create `GSDProgressDisplay.tsx`:

```typescript
import React, { useMemo } from 'react';
import { useQuery } from '@tanstack/react-query';
import { useGSDFileSync, useGSDTaskToggle, nextTaskStatus } from '../../hooks';
import type { ParsedPlanFile, GSDTask, TaskStatus } from '../../services/gsd/gsdTypes';
import { CheckCircle, Circle, Clock, AlertCircle } from 'lucide-react';

interface GSDProgressDisplayProps {
  sessionId: string;
  planPath: string;
  className?: string;
}

const STATUS_ICONS: Record<TaskStatus, React.ReactNode> = {
  pending: <Circle className="w-4 h-4 text-gray-400" />,
  in_progress: <Clock className="w-4 h-4 text-blue-500 animate-pulse" />,
  complete: <CheckCircle className="w-4 h-4 text-green-500" />
};

const STATUS_LABELS: Record<TaskStatus, string> = {
  pending: 'Pending',
  in_progress: 'In Progress',
  complete: 'Complete'
};

export function GSDProgressDisplay({
  sessionId,
  planPath,
  className = ''
}: GSDProgressDisplayProps) {
  const { isConnected, isWatching, ws, requestPlan } = useGSDFileSync({
    sessionId,
    enabled: true
  });

  const { data: plan, isLoading, error } = useQuery<ParsedPlanFile>({
    queryKey: ['gsd-plan', planPath],
    queryFn: async () => {
      requestPlan(planPath);
      // The actual data will come via WebSocket and update the cache
      // Return a loading state initially
      return new Promise((resolve) => {
        // This will be replaced by WebSocket message handling
        setTimeout(() => {
          resolve(undefined as unknown as ParsedPlanFile);
        }, 100);
      });
    },
    enabled: isConnected && isWatching
  });

  const { mutate: toggleTask, isPending: isToggling } = useGSDTaskToggle({
    ws,
    sessionId,
    planPath
  });

  const progress = useMemo(() => {
    if (!plan?.tasks) return { completed: 0, total: 0, percentage: 0 };
    const completed = plan.tasks.filter(t => t.status === 'complete').length;
    const total = plan.tasks.length;
    return {
      completed,
      total,
      percentage: total > 0 ? Math.round((completed / total) * 100) : 0
    };
  }, [plan?.tasks]);

  const handleTaskClick = (taskIndex: number, task: GSDTask) => {
    if (isToggling) return;
    toggleTask({
      taskIndex,
      status: nextTaskStatus(task.status)
    });
  };

  if (!isConnected) {
    return (
      <div className={`p-4 bg-yellow-50 border border-yellow-200 rounded ${className}`}>
        <div className="flex items-center gap-2">
          <AlertCircle className="w-5 h-5 text-yellow-500" />
          <span className="text-yellow-700">Connecting to GSD server...</span>
        </div>
      </div>
    );
  }

  if (isLoading) {
    return (
      <div className={`p-4 bg-gray-50 border border-gray-200 rounded animate-pulse ${className}`}>
        <div className="h-4 bg-gray-200 rounded w-1/3 mb-2" />
        <div className="h-2 bg-gray-200 rounded w-full" />
      </div>
    );
  }

  if (error || !plan) {
    return (
      <div className={`p-4 bg-red-50 border border-red-200 rounded ${className}`}>
        <div className="flex items-center gap-2">
          <AlertCircle className="w-5 h-5 text-red-500" />
          <span className="text-red-700">
            {error instanceof Error ? error.message : 'Failed to load plan'}
          </span>
        </div>
      </div>
    );
  }

  return (
    <div className={`bg-white border border-gray-200 rounded-lg ${className}`}>
      {/* Header */}
      <div className="p-4 border-b border-gray-200">
        <div className="flex items-center justify-between">
          <h3 className="font-semibold text-gray-900">
            {plan.frontmatter.phase} - Plan {plan.frontmatter.plan}
          </h3>
          <span className="text-sm text-gray-500">
            Wave {plan.frontmatter.wave}
          </span>
        </div>
        {/* Progress bar */}
        <div className="mt-2">
          <div className="flex items-center justify-between text-sm text-gray-600 mb-1">
            <span>{progress.completed}/{progress.total} tasks</span>
            <span>{progress.percentage}%</span>
          </div>
          <div className="h-2 bg-gray-200 rounded-full overflow-hidden">
            <div
              className="h-full bg-green-500 transition-all duration-300"
              style={{ width: `${progress.percentage}%` }}
            />
          </div>
        </div>
      </div>

      {/* Task list */}
      <ul className="divide-y divide-gray-100">
        {plan.tasks.map((task, index) => (
          <li
            key={`${task.name}-${index}`}
            className="p-3 hover:bg-gray-50 cursor-pointer transition-colors"
            onClick={() => handleTaskClick(index, task)}
            role="button"
            tabIndex={0}
            aria-label={`Toggle ${task.name} (${STATUS_LABELS[task.status]})`}
            onKeyDown={(e) => {
              if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                handleTaskClick(index, task);
              }
            }}
          >
            <div className="flex items-start gap-3">
              <span className="mt-0.5">{STATUS_ICONS[task.status]}</span>
              <div className="flex-1 min-w-0">
                <p className={`text-sm font-medium ${
                  task.status === 'complete' ? 'text-gray-500 line-through' : 'text-gray-900'
                }`}>
                  {task.name}
                </p>
                <p className="text-xs text-gray-500 mt-0.5">
                  {task.type === 'auto' ? 'Autonomous' : task.type}
                </p>
              </div>
            </div>
          </li>
        ))}
      </ul>

      {/* Footer */}
      <div className="p-3 bg-gray-50 border-t border-gray-200 text-xs text-gray-500">
        <div className="flex items-center gap-2">
          <span className={`w-2 h-2 rounded-full ${isWatching ? 'bg-green-500' : 'bg-gray-300'}`} />
          <span>{isWatching ? 'Live sync active' : 'Sync paused'}</span>
        </div>
      </div>
    </div>
  );
}
```

Update or create `src/components/shell/index.ts` to export the component.

Note: Import lucide-react icons (should already be installed). If not, the component will work without icons - replace with text fallbacks.
  </action>
  <verify>
Run `npm run typecheck` - no errors in GSDProgressDisplay.tsx.
  </verify>
  <done>GSD progress display component created with task list, progress bar, and click-to-toggle</done>
</task>

</tasks>

<verification>
- [ ] useGSDFileSync subscribes to WebSocket and invalidates queries on file changes
- [ ] useGSDTaskToggle performs optimistic updates with rollback
- [ ] GSDProgressDisplay shows progress bar and task list
- [ ] Clicking task cycles through pending -> in_progress -> complete -> pending
- [ ] Live sync indicator shows connection status
- [ ] `npm run typecheck` passes
</verification>

<success_criteria>
- Progress bar updates in real-time when tasks complete
- Task status toggles are instant (optimistic) with server confirmation
- Disconnection state shows warning message
- Component is accessible (keyboard navigation, ARIA labels)
</success_criteria>

<output>
After completion, create `.planning/phases/87-gsd-file-synchronization/87-04-SUMMARY.md`
</output>
