---
phase: 14-pafv-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [
  "native/Sources/Isometry/WebView/WebViewBridge.swift",
  "native/Sources/Isometry/WebView/PAFVMessageHandler.swift",
  "native/Sources/Isometry/Models/ViewConfig.swift",
  "native/Sources/Isometry/Views/SuperGridView.swift",
  "native/Sources/Isometry/Views/SuperGridViewModel.swift",
  "native/Sources/Isometry/Utils/CoordinateTransformer.swift",
  "src/contexts/PAFVContext.tsx",
  "src/utils/pafv-bridge.ts"
]
autonomous: true
user_setup: []

must_haves:
  truths:
    - "React PAFV axis changes instantly reflect in native SuperGridView"
    - "Native coordinate transformations correctly position nodes from React D3 calculations"
    - "Bridge maintains 60fps performance with 1000+ nodes"
    - "ViewConfig persists PAFV state across app restarts via CloudKit"
    - "Zoom/pan operations sync between React and native coordinate systems"
  artifacts:
    - path: "native/Sources/Isometry/WebView/PAFVMessageHandler.swift"
      provides: "PAFV-specific WebView message handling"
      exports: ["PAFVMessageHandler"]
      min_lines: 150
    - path: "native/Sources/Isometry/Utils/CoordinateTransformer.swift"
      provides: "React D3 to native Canvas coordinate transformation"
      exports: ["CoordinateTransformer"]
      min_lines: 200
    - path: "src/utils/pafv-bridge.ts"
      provides: "React PAFV to native bridge communication"
      exports: ["PAFVBridge"]
      min_lines: 100
    - path: "native/Sources/Isometry/Models/ViewConfig.swift"
      provides: "Enhanced ViewConfig with PAFV mapping support"
      contains: "fromPAFVState"
      min_lines: 150
  key_links:
    - from: "src/contexts/PAFVContext.tsx"
      to: "native WebView bridge"
      via: "window._isometryBridge.sendMessage"
      pattern: "sendMessage.*pafv"
    - from: "native PAFVMessageHandler"
      to: "SuperGridViewModel"
      via: "ViewConfig updates"
      pattern: "updateViewConfig"
    - from: "native CoordinateTransformer"
      to: "SuperGridView Canvas"
      via: "GridCellData coordinate mapping"
      pattern: "transformCoordinates.*GridCellData"
---

<objective>
Bridge React PAFV spatial projection system to native SuperGridView with real-time coordinate synchronization.

Purpose: Enable seamless PAFV axis mapping changes in React to instantly update native SuperGrid rendering while maintaining 60fps performance and coordinate precision.
Output: Bidirectional PAFV bridge infrastructure with coordinate transformation pipeline, debounced updates, and CloudKit persistence integration.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-pafv-integration/14-RESEARCH.md

# Core infrastructure
@native/Sources/Isometry/WebView/WebViewBridge.swift
@native/Sources/Isometry/Models/ViewConfig.swift
@native/Sources/Isometry/Views/SuperGridView.swift
@native/Sources/Isometry/Views/SuperGridViewModel.swift

# React PAFV system
@src/types/pafv.ts
@src/contexts/PAFVContext.tsx
@src/utils/pafv-serialization.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PAFV Message Handler for WebView Bridge</name>
  <files>native/Sources/Isometry/WebView/PAFVMessageHandler.swift</files>
  <action>
    Create dedicated PAFVMessageHandler class implementing WKScriptMessageHandler to handle PAFV-specific bridge messages between React and native.

    Key features:
    - Handle "updateAxisMapping", "updateViewport", "syncCoordinates" message types
    - Sequence ID tracking for message ordering (prevent out-of-order updates)
    - Debounced coordinate updates (16ms/60fps max frequency)
    - Performance monitoring with bridge latency tracking
    - Type-safe parameter parsing with fallback to defaults
    - Integration with SuperGridViewModel for ViewConfig updates

    Message handlers:
    - updateAxisMapping: Convert React AxisMapping to native ViewConfig fields
    - updateViewport: Sync zoom/pan state between coordinate systems
    - syncCoordinates: Batch update GridCellData positions from React D3 calculations

    Use research pattern from 14-RESEARCH.md for bridge message structure with error handling, timeouts, and async-aware processing. Include performance monitoring to track bridge latency and frame rate impact.
  </action>
  <verify>Swift build passes with no errors, PAFVMessageHandler can be imported in WebViewBridge.swift</verify>
  <done>PAFVMessageHandler class exists with three message type handlers and performance monitoring</done>
</task>

<task type="auto">
  <name>Task 2: Create Coordinate Transformation System</name>
  <files>native/Sources/Isometry/Utils/CoordinateTransformer.swift</files>
  <action>
    Create CoordinateTransformer utility class to handle React D3 continuous coordinates to native discrete grid coordinates conversion.

    Core functionality:
    - Transform D3 scale outputs (float) to Canvas grid positions (Int)
    - Handle hierarchical LATCH axis transformations (L/A/T/C/H to x/y grid coordinates)
    - Viewport-based coordinate mapping with zoom/pan support
    - Precision management to prevent accumulated rounding errors
    - Memory-efficient LRU cache for coordinate calculations (1000 node limit)

    Transformation pipeline:
    1. Parse React AxisMapping (plane->axis->facet) to grid dimensions
    2. Apply LATCH-specific coordinate calculation rules:
       - Time: chronological ordering with date-based spacing
       - Category: categorical clusters with alphabetical sub-ordering
       - Hierarchy: priority-based vertical positioning
       - Location/Alphabet: standard lexicographic sorting
    3. Convert continuous D3 coordinates to discrete Canvas cell positions
    4. Apply ViewConfig zoom/pan transforms for viewport consistency

    Include coordinate precision validation and warning logs for significant rounding errors. Use research insights about D3 edge cases and performance optimization patterns.
  </action>
  <verify>CoordinateTransformer builds, includes LRU cache, and has methods for all 5 LATCH axis types</verify>
  <done>CoordinateTransformer class transforms React coordinates to native grid positions with precision management</done>
</task>

<task type="auto">
  <name>Task 3: Enhance ViewConfig with PAFV Integration</name>
  <files>native/Sources/Isometry/Models/ViewConfig.swift</files>
  <action>
    Extend ViewConfig struct with PAFV state mapping and React bridge integration support.

    New functionality:
    - Add `fromPAFVState()` static method to create ViewConfig from React PAFVState
    - Add `toPAFVMapping()` method to export native state back to React
    - Add `sequenceId` field for bridge message ordering
    - Add `lastPAFVUpdate` timestamp for conflict resolution
    - Enhance axis mapping validation for LATCH axis types

    Integration points:
    - Map React AxisMapping[] to native xAxisMapping/yAxisMapping strings
    - Handle React viewMode ('grid'/'list') to native ViewConfig settings
    - Preserve React facet names in new `facetMappings` JSON field
    - Add CloudKit sync support for PAFV-derived configurations

    State translation rules:
    - React plane 'x' -> ViewConfig.xAxisMapping
    - React plane 'y' -> ViewConfig.yAxisMapping
    - React axis values -> ViewConfig LATCH axis abbreviations (L/A/T/C/H)
    - React facet names -> ViewConfig.facetMappings JSON storage

    Include validation logic to ensure ViewConfig remains consistent when updated via bridge vs direct native changes. Add Codable conformance for CloudKit persistence.
  </action>
  <verify>ViewConfig struct includes fromPAFVState method and compiles with GRDB conformance maintained</verify>
  <done>ViewConfig supports PAFV state mapping with CloudKit persistence and bridge integration</done>
</task>

<task type="auto">
  <name>Task 4: Integrate PAFV Bridge with SuperGrid System</name>
  <files>
    native/Sources/Isometry/Views/SuperGridView.swift,
    native/Sources/Isometry/Views/SuperGridViewModel.swift,
    native/Sources/Isometry/WebView/WebViewBridge.swift
  </files>
  <action>
    Integrate PAFV message handling into SuperGrid rendering pipeline and WebView bridge infrastructure.

    SuperGridViewModel enhancements:
    - Add `updateFromPAFV(_ config: ViewConfig)` method for bridge-triggered updates
    - Add coordinate transformer integration for GridCellData positioning
    - Add debounced viewport update publishing for React synchronization
    - Add performance monitoring for PAFV coordinate transformation overhead

    SuperGridView enhancements:
    - Connect PAFV coordinate updates to Canvas rendering pipeline
    - Add viewport change detection for reverse sync to React
    - Ensure gesture handling (zoom/pan) triggers PAFV bridge updates
    - Maintain 60fps performance target with PAFV coordinate recalculation

    WebViewBridge integration:
    - Add PAFVMessageHandler registration in bridge initialization
    - Add "pafv" message handler routing to PAFVMessageHandler
    - Include PAFV bridge in JavaScript initialization script
    - Add development tools integration for PAFV bridge debugging

    Coordinate system synchronization:
    - SuperGridView gesture changes -> PAFVMessageHandler -> React bridge updates
    - React PAFV changes -> PAFVMessageHandler -> SuperGridViewModel -> Canvas re-render
    - Viewport transforms applied consistently in both directions

    Follow research recommendations for performance-aware bridge communication and debounced updates at 60fps maximum frequency.
  </action>
  <verify>SuperGrid system integrates with PAFV bridge, JavaScript bridge includes pafv handler, builds successfully</verify>
  <done>SuperGrid renders with PAFV coordinate system integration and bidirectional bridge communication</done>
</task>

<task type="auto">
  <name>Task 5: Create React PAFV Bridge Client</name>
  <files>
    src/utils/pafv-bridge.ts,
    src/contexts/PAFVContext.tsx
  </files>
  <action>
    Create React-side PAFV bridge client and integrate with existing PAFVContext for seamless native synchronization.

    PAFVBridge class features:
    - Debounced native message sending (16ms/60fps limit)
    - Sequence ID management for ordered updates
    - Coordinate batch updates for GridCellData synchronization
    - Performance monitoring and bridge latency tracking
    - TypeScript integration with PAFVState and AxisMapping types

    PAFVContext integration:
    - Modify setMapping to trigger bridge updates via PAFVBridge
    - Add native ViewConfig -> PAFVState synchronization handler
    - Add viewport update receiver for native zoom/pan changes
    - Maintain React as UI source of truth with native as renderer

    Bridge message types:
    - updateAxisMapping: Send AxisMapping changes to native ViewConfig
    - updateViewport: Send D3 zoom/pan state to native coordinate system
    - syncCoordinates: Batch send GridCellData positions for native rendering

    React integration:
    - Hook into existing PAFV state changes via useCallback
    - Add bridge initialization to PAFVProvider setup
    - Add error boundary for bridge communication failures
    - Maintain URL persistence as primary React state storage

    Performance optimization:
    - Debounce rapid axis changes during drag operations
    - Batch coordinate updates to prevent bridge flooding
    - Use requestAnimationFrame for smooth visual updates

    Follow research patterns for async bridge communication and avoid synchronous bridge calls that could block React rendering.
  </action>
  <verify>PAFVBridge class compiles, PAFVContext imports and uses bridge, TypeScript types are maintained</verify>
  <done>React PAFV system communicates with native bridge for real-time SuperGrid synchronization</done>
</task>

</tasks>

<verification>
Overall integration verification:
1. React PAFV axis changes trigger immediate native SuperGrid updates
2. Native coordinate transformations correctly position all GridCellData nodes
3. Bridge maintains 60fps performance with 1000+ nodes under stress testing
4. ViewConfig persists PAFV state and restores correctly after app restart
5. Zoom/pan operations remain synchronized between React and native views
6. No memory leaks during rapid PAFV state changes
7. CloudKit sync handles PAFV ViewConfig changes without conflicts
</verification>

<success_criteria>
- [ ] React axis drag-and-drop instantly updates native SuperGrid layout
- [ ] Native SuperGrid zoom/pan reflects in React PAFV coordinate system
- [ ] Bridge latency remains under 5ms for axis mapping changes
- [ ] Coordinate transformation maintains precision across 1000+ nodes
- [ ] PAFV ViewConfig persists and restores correctly via CloudKit
- [ ] Performance maintains 60fps during active PAFV manipulation
- [ ] Bridge handles out-of-order messages gracefully with sequence IDs
- [ ] All TypeScript types remain strict with no 'any' fallbacks
</success_criteria>

<output>
After completion, create `.planning/phases/14-pafv-integration/14-01-SUMMARY.md` documenting the PAFV integration bridge architecture, performance characteristics, and usage patterns.
</output>