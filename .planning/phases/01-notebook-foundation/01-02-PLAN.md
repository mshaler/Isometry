---
phase: 01-notebook-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified: [
  "src/contexts/NotebookContext.tsx",
  "src/contexts/index.ts",
  "src/App.tsx"
]
autonomous: true

must_haves:
  truths:
    - "NotebookContext provides shared state across all components"
    - "Context integrates with existing provider hierarchy"
    - "Notebook mode can be toggled from main application"
  artifacts:
    - path: "src/contexts/NotebookContext.tsx"
      provides: "Notebook state management"
      exports: ["NotebookProvider", "useNotebook"]
      min_lines: 50
    - path: "src/contexts/index.ts"
      provides: "Context exports"
      contains: "NotebookProvider"
    - path: "src/App.tsx"
      provides: "Notebook mode integration"
      contains: "notebook"
  key_links:
    - from: "src/contexts/NotebookContext.tsx"
      to: "src/types/notebook.ts"
      via: "import notebook types"
      pattern: "import.*from.*notebook"
    - from: "src/App.tsx"
      to: "src/contexts/NotebookContext.tsx"
      via: "NotebookProvider in hierarchy"
      pattern: "NotebookProvider"
---

<objective>
Create NotebookContext for shared state management and integrate notebook mode toggle into main application interface.

Purpose: Establish notebook state management that works seamlessly with existing context providers
Output: Working context provider and UI toggle for accessing notebook sidecar
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/01-notebook-foundation/01-01-SUMMARY.md
@/Users/mshaler/Developer/Projects/Isometry/src/contexts/AppStateContext.tsx
@/Users/mshaler/Developer/Projects/Isometry/src/contexts/FilterContext.tsx
@/Users/mshaler/Developer/Projects/Isometry/src/contexts/ThemeContext.tsx
@/Users/mshaler/Developer/Projects/Isometry/src/App.tsx
@/Users/mshaler/Developer/Projects/Isometry/src/types/notebook.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create NotebookContext with state management</name>
  <files>src/contexts/NotebookContext.tsx</files>
  <action>
    Create NotebookContext following the established patterns from other contexts:

    State to manage:
    - activeCard: NotebookCard | null (currently edited card)
    - cards: NotebookCard[] (all notebook cards)
    - layout: { capture: LayoutPosition, shell: LayoutPosition, preview: LayoutPosition }
    - isNotebookMode: boolean (toggle between main app and notebook)
    - templates: NotebookTemplate[] (available card templates)

    Methods to provide:
    - createCard: (type: NotebookCardType, template?: string) => Promise<NotebookCard>
    - updateCard: (id: string, updates: Partial<NotebookCard>) => Promise<void>
    - deleteCard: (id: string) => Promise<void>
    - setActiveCard: (card: NotebookCard | null) => void
    - updateLayout: (component: string, position: LayoutPosition) => void
    - toggleNotebookMode: () => void
    - loadCards: () => Promise<void>

    Use useDatabase hook to interact with SQLite.
    Follow error handling patterns from existing contexts.
    Implement localStorage persistence for layout state.
  </action>
  <verify>
    Run `npm run typecheck` to ensure TypeScript compilation.
    Verify context exports useNotebook hook and NotebookProvider.
    Check that all methods have proper error handling.
  </verify>
  <done>NotebookContext provides comprehensive state management for notebook operations</done>
</task>

<task type="auto">
  <name>Task 2: Add NotebookContext to context exports</name>
  <files>src/contexts/index.ts</files>
  <action>
    Add NotebookContext exports to src/contexts/index.ts if it exists, or create the file:

    Export both NotebookProvider and useNotebook:
    ```typescript
    export { NotebookProvider, useNotebook } from './NotebookContext';
    ```

    Follow the pattern of other context exports in the file.
    If file doesn't exist, create it with all context exports for cleaner imports.
  </action>
  <verify>
    Run `npm run typecheck` to ensure exports work correctly.
    Verify imports resolve from 'src/contexts' path.
  </verify>
  <done>NotebookContext exports are available from contexts barrel file</done>
</task>

<task type="auto">
  <name>Task 3: Integrate notebook mode toggle in main app</name>
  <files>src/App.tsx</files>
  <action>
    Integrate NotebookContext into the provider hierarchy and add notebook mode toggle:

    1. Add NotebookProvider to provider hierarchy (after DatabaseProvider, before AppStateProvider)
    2. Extend ViewMode type to include 'notebook': 'app' | 'd3demo' | 'supergrid' | 'components' | 'notebook'
    3. Add "Notebook" button to the view toggle section (after Components button)
    4. Style notebook button consistently with existing buttons
    5. Add placeholder for notebook content in the main canvas area:
       ```tsx
       ) : viewMode === 'notebook' ? (
         <div className="flex-1 p-4">
           <div className="text-center text-gray-500">
             <h2>Notebook Sidecar</h2>
             <p>Three-component layout coming soon...</p>
           </div>
         </div>
       ```

    Use useNotebook hook to sync viewMode with NotebookContext.isNotebookMode.
  </action>
  <verify>
    Run `npm run dev` and verify app loads without errors.
    Click "Notebook" button and verify placeholder content displays.
    Verify other view modes still work correctly.
    Check that NotebookProvider is in correct position in hierarchy.
  </verify>
  <done>Main application includes notebook mode toggle with placeholder content</done>
</task>

</tasks>

<verification>
1. NotebookContext provides all required state management methods
2. Context integrates cleanly with existing provider hierarchy
3. Notebook mode toggle appears and functions in main app UI
4. Layout state persists across browser sessions via localStorage
5. No breaking changes to existing app functionality
</verification>

<success_criteria>
1. User can click "Notebook" button to enter notebook mode
2. NotebookContext state is accessible from any component
3. Layout preferences persist across browser refresh
4. Context follows established patterns from existing providers
5. Placeholder content displays when notebook mode is selected
</success_criteria>

<output>
After completion, create `.planning/phases/01-notebook-foundation/01-02-SUMMARY.md`
</output>