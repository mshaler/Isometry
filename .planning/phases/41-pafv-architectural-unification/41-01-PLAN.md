---
phase: 41-pafv-architectural-unification
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [
  "src/engine/IsometryViewEngine.ts",
  "src/engine/contracts/ViewEngine.ts",
  "src/engine/contracts/ViewConfig.ts",
  "src/engine/contracts/PAFVProjection.ts",
  "src/engine/renderers/GridRenderer.ts"
]
autonomous: true

must_haves:
  truths:
    - "IsometryViewEngine class exists with render() and transition() methods"
    - "ViewConfig interface drives rendering decisions"
    - "Grid renderer implements D3-only data visualization"
    - "No data rendering logic exists in React components"
  artifacts:
    - path: "src/engine/IsometryViewEngine.ts"
      provides: "Unified rendering engine class"
      exports: ["IsometryViewEngine"]
    - path: "src/engine/contracts/ViewEngine.ts"
      provides: "ViewEngine interface contract"
      exports: ["ViewEngine"]
    - path: "src/engine/contracts/ViewConfig.ts"
      provides: "ViewConfig interface for rendering configuration"
      exports: ["ViewConfig"]
    - path: "src/engine/renderers/GridRenderer.ts"
      provides: "Grid view D3 renderer implementation"
      exports: ["GridRenderer"]
  key_links:
    - from: "src/engine/IsometryViewEngine.ts"
      to: "src/engine/contracts/ViewEngine.ts"
      via: "implements ViewEngine interface"
      pattern: "implements ViewEngine"
    - from: "src/engine/renderers/GridRenderer.ts"
      to: "D3 data binding with .join()"
      via: "d3 selection data join"
      pattern: "\\.data\\(.*\\)\\.join\\("
---

<objective>
Create unified ViewEngine architecture foundation that will replace dual D3/CSS rendering paths.

Purpose: Establish the core architectural contract for "D3 renders, React controls" principle that eliminates rendering split identified in Canvas.tsx useD3Mode toggle.
Output: ViewEngine interface and IsometryViewEngine class with Grid renderer as proof of concept.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/41-pafv-architectural-unification/41-RESEARCH.md
@src/components/Canvas.tsx
@src/d3/SuperGridV4.ts
@src/state/PAFVContext.tsx
@src/types/pafv.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ViewEngine interface contracts</name>
  <files>
    src/engine/contracts/ViewEngine.ts
    src/engine/contracts/ViewConfig.ts
    src/engine/contracts/PAFVProjection.ts
  </files>
  <action>
    Create TypeScript interfaces for unified rendering architecture:

    ViewEngine.ts - Core interface with render(), transition(), destroy() methods matching PAFV implementation plan Phase 0.1 specification. Must accept container element, data array, and ViewConfig.

    ViewConfig.ts - Configuration interface with viewType enum ('list' | 'grid' | 'kanban' | 'graph'), projection (PAFVProjection), filters (LATCHFilter[]), sort config, zoom state. Use existing types from src/types/pafv.ts and src/types/supergrid.ts for compatibility.

    PAFVProjection.ts - Interface for PAFV axis-to-plane mapping extending existing AxisMapping from src/types/pafv.ts. Must support all LATCH dimensions (Location, Alphabet, Time, Category, Hierarchy) mapping to visual planes.

    Import and extend existing PAFV types to maintain compatibility with current PAFVContext and SuperGrid implementations.
  </action>
  <verify>
    TypeScript compilation succeeds with no errors for new interface files.
    `npm run typecheck` passes.
    Interfaces can be imported without circular dependencies.
  </verify>
  <done>
    Three interface files created defining ViewEngine contract, ViewConfig parameters, and PAFVProjection structure that will drive all rendering decisions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement IsometryViewEngine class</name>
  <files>src/engine/IsometryViewEngine.ts</files>
  <action>
    Create IsometryViewEngine class implementing ViewEngine interface:

    - Constructor accepts container HTMLElement, initializes renderer map for view types
    - render(data: Node[], config: ViewConfig) method dispatches to appropriate renderer based on config.viewType
    - transition(fromConfig: ViewConfig, toConfig: ViewConfig, duration?: number) method handles animated transitions between view configurations
    - destroy() method cleans up D3 selections and renderer state
    - Private renderers Map stores view-specific renderer instances (initially just GridRenderer)
    - Error handling for unsupported view types with descriptive messages

    Use defensive programming - validate inputs, handle missing renderers gracefully, provide clear error messages. Follow existing D3 patterns from SuperGridV4.ts and D3Canvas.tsx for container management.
  </action>
  <verify>
    Class compiles without TypeScript errors.
    Can instantiate IsometryViewEngine with valid container element.
    render() method accepts valid data and config without runtime errors.
    destroy() method cleans up without throwing exceptions.
  </verify>
  <done>
    IsometryViewEngine class exists implementing unified rendering contract with renderer dispatch, transition support, and proper cleanup.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Grid renderer with D3 data binding</name>
  <files>src/engine/renderers/GridRenderer.ts</files>
  <action>
    Implement GridRenderer class for D3-only grid visualization:

    - Implements ViewRenderer interface (subset of ViewEngine for single view type)
    - render(container: HTMLElement, data: Node[], config: ViewConfig) creates SVG grid
    - Use D3 .data().join() pattern with key functions (d => d.id) for proper element lifecycle
    - Create grid cells with enter/update/exit animations matching current SuperGrid patterns
    - Apply PAFV positioning using config.projection to map data to screen coordinates
    - Handle cell hover and click events, dispatch through config event handlers
    - No React JSX rendering - pure D3 DOM manipulation only

    Reference existing D3Canvas.tsx and SuperGridV4.ts for grid layout patterns. Use d3.select() for container, d3.selectAll() for data binding, apply transforms for positioning. Include basic styling through D3 .style() calls.
  </action>
  <verify>
    GridRenderer compiles without errors.
    render() creates SVG elements in provided container.
    D3 data joins work correctly with sample Node data.
    Grid cells appear positioned according to PAFV projection.
    Click events trigger without runtime errors.
  </verify>
  <done>
    GridRenderer implements pure D3 grid visualization with proper data binding, PAFV positioning, and event handling without any React rendering logic.
  </done>
</task>

</tasks>

<verification>
Run TypeScript compilation to ensure no errors in new engine architecture.
Verify ViewEngine interface can be imported and implemented.
Test IsometryViewEngine instantiation with DOM container element.
Confirm GridRenderer creates visual elements using D3 without React.
</verification>

<success_criteria>
- ViewEngine architecture foundation exists as TypeScript interfaces
- IsometryViewEngine class implements unified rendering contract
- GridRenderer demonstrates D3-only visualization approach
- No data rendering logic mixed with React component code
- Foundation ready for eliminating Canvas.tsx useD3Mode toggle
</success_criteria>

<output>
After completion, create `.planning/phases/41-pafv-architectural-unification/41-01-SUMMARY.md`
</output>