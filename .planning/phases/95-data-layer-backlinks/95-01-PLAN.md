---
phase: 95-data-layer-backlinks
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/schema.sql
  - src/utils/editor/templates.ts
  - src/db/migrations/add-templates-table.sql
  - src/db/SQLiteProvider.tsx
autonomous: true

must_haves:
  truths:
    - "Templates table exists in sql.js database with FTS5 for search"
    - "Template CRUD operations (create, read, update, delete) work against sql.js"
    - "Built-in templates are seeded on first load"
  artifacts:
    - path: "src/db/schema.sql"
      provides: "Templates table definition with FTS5"
      contains: "CREATE TABLE IF NOT EXISTS templates"
    - path: "src/utils/editor/templates.ts"
      provides: "Template CRUD operations"
      exports: ["queryTemplates", "createTemplate", "updateTemplate", "deleteTemplate", "incrementTemplateUsage", "seedBuiltInTemplates"]
  key_links:
    - from: "src/utils/editor/templates.ts"
      to: "sql.js database"
      via: "db.exec() and db.run() calls"
      pattern: "db\\.exec\\(|db\\.run\\("
---

<objective>
Create templates data layer with sql.js storage and built-in template seeding.

Purpose: Templates must persist in the database (per CAPTURE-03 decision), not localStorage. This enables FTS5 search and consistency with other card data.

Output: Templates table in schema, CRUD operations in templates.ts, built-in templates seeded.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/95-data-layer-backlinks/95-RESEARCH.md

# Existing patterns to follow
@src/db/schema.sql
@src/utils/editor/backlinks.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add templates table to schema.sql</name>
  <files>src/db/schema.sql, src/db/migrations/add-templates-table.sql</files>
  <action>
Add templates table to schema.sql after the notebook_cards section:

```sql
-- ============================================================================
-- Templates: Saved content templates for /template slash command
-- ============================================================================

CREATE TABLE IF NOT EXISTS templates (
    id TEXT PRIMARY KEY NOT NULL,
    name TEXT NOT NULL,
    description TEXT,
    category TEXT,  -- 'meeting', 'project', 'note', 'daily', 'custom'
    content TEXT NOT NULL,  -- Markdown content
    variables TEXT,  -- JSON array of variable placeholders
    created_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%SZ', 'now')),
    modified_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%SZ', 'now')),
    usage_count INTEGER NOT NULL DEFAULT 0
);

CREATE INDEX IF NOT EXISTS idx_templates_category ON templates(category);
CREATE INDEX IF NOT EXISTS idx_templates_usage ON templates(usage_count DESC);
CREATE INDEX IF NOT EXISTS idx_templates_name ON templates(name);

-- FTS5 for template search
CREATE VIRTUAL TABLE IF NOT EXISTS templates_fts USING fts5(
    name,
    description,
    content,
    content='templates',
    content_rowid='rowid'
);

-- FTS5 triggers for templates
CREATE TRIGGER IF NOT EXISTS trg_templates_fts_insert AFTER INSERT ON templates BEGIN
    INSERT INTO templates_fts(rowid, name, description, content)
    VALUES (NEW.rowid, NEW.name, NEW.description, NEW.content);
END;

CREATE TRIGGER IF NOT EXISTS trg_templates_fts_delete AFTER DELETE ON templates BEGIN
    INSERT INTO templates_fts(templates_fts, rowid, name, description, content)
    VALUES ('delete', OLD.rowid, OLD.name, OLD.description, OLD.content);
END;

CREATE TRIGGER IF NOT EXISTS trg_templates_fts_update AFTER UPDATE ON templates BEGIN
    INSERT INTO templates_fts(templates_fts, rowid, name, description, content)
    VALUES ('delete', OLD.rowid, OLD.name, OLD.description, OLD.content);
    INSERT INTO templates_fts(rowid, name, description, content)
    VALUES (NEW.rowid, NEW.name, NEW.description, NEW.content);
END;
```

Also create a migration file at `src/db/migrations/add-templates-table.sql` with the same SQL for existing databases.
  </action>
  <verify>
Run `npm run typecheck` to ensure no type errors. Grep for "CREATE TABLE IF NOT EXISTS templates" in schema.sql to confirm table was added.
  </verify>
  <done>
Templates table definition exists in schema.sql with:
- id, name, description, category, content, variables, timestamps, usage_count columns
- Indexes on category, usage_count, name
- FTS5 virtual table templates_fts with sync triggers
  </done>
</task>

<task type="auto">
  <name>Task 2: Create template CRUD operations</name>
  <files>src/utils/editor/templates.ts</files>
  <action>
Create new file `src/utils/editor/templates.ts` following the pattern from backlinks.ts:

```typescript
import type { Database } from 'sql.js';

export interface Template {
  id: string;
  name: string;
  description?: string;
  category?: string;
  content: string;
  variables?: TemplateVariable[];
  createdAt: string;
  modifiedAt: string;
  usageCount: number;
}

export interface TemplateVariable {
  key: string;
  label: string;
  defaultValue: string;
}

/**
 * Query all templates, optionally filtered by category.
 * Orders by usage_count DESC, then name ASC (most used first).
 */
export function queryTemplates(
  db: Database | null,
  category?: string
): Template[] {
  if (!db) return [];

  try {
    const sql = category
      ? `SELECT id, name, description, category, content, variables, created_at, modified_at, usage_count
         FROM templates WHERE category = ? ORDER BY usage_count DESC, name ASC`
      : `SELECT id, name, description, category, content, variables, created_at, modified_at, usage_count
         FROM templates ORDER BY usage_count DESC, name ASC`;

    const params = category ? [category] : [];
    const results = db.exec(sql, params);

    if (!results[0]?.values) return [];

    return results[0].values.map(row => ({
      id: String(row[0]),
      name: String(row[1]),
      description: row[2] ? String(row[2]) : undefined,
      category: row[3] ? String(row[3]) : undefined,
      content: String(row[4]),
      variables: row[5] ? JSON.parse(String(row[5])) : undefined,
      createdAt: String(row[6]),
      modifiedAt: String(row[7]),
      usageCount: Number(row[8]),
    }));
  } catch (error) {
    console.error('Failed to query templates:', error);
    return [];
  }
}

/**
 * Search templates using FTS5.
 */
export function searchTemplates(
  db: Database | null,
  query: string
): Template[] {
  if (!db || !query.trim()) return queryTemplates(db);

  try {
    const results = db.exec(
      `SELECT t.id, t.name, t.description, t.category, t.content, t.variables,
              t.created_at, t.modified_at, t.usage_count
       FROM templates t
       JOIN templates_fts fts ON t.rowid = fts.rowid
       WHERE templates_fts MATCH ?
       ORDER BY rank, t.usage_count DESC`,
      [query + '*']
    );

    if (!results[0]?.values) return [];

    return results[0].values.map(row => ({
      id: String(row[0]),
      name: String(row[1]),
      description: row[2] ? String(row[2]) : undefined,
      category: row[3] ? String(row[3]) : undefined,
      content: String(row[4]),
      variables: row[5] ? JSON.parse(String(row[5])) : undefined,
      createdAt: String(row[6]),
      modifiedAt: String(row[7]),
      usageCount: Number(row[8]),
    }));
  } catch (error) {
    console.error('Failed to search templates:', error);
    return queryTemplates(db);
  }
}

/**
 * Create a new template.
 */
export function createTemplate(
  db: Database | null,
  template: Omit<Template, 'id' | 'createdAt' | 'modifiedAt' | 'usageCount'>
): string | null {
  if (!db) return null;

  try {
    const id = `template-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    const now = new Date().toISOString();

    db.run(
      `INSERT INTO templates (id, name, description, category, content, variables, created_at, modified_at)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        id,
        template.name,
        template.description ?? null,
        template.category ?? null,
        template.content,
        template.variables ? JSON.stringify(template.variables) : null,
        now,
        now,
      ]
    );

    return id;
  } catch (error) {
    console.error('Failed to create template:', error);
    return null;
  }
}

/**
 * Update an existing template.
 */
export function updateTemplate(
  db: Database | null,
  id: string,
  updates: Partial<Omit<Template, 'id' | 'createdAt' | 'modifiedAt' | 'usageCount'>>
): boolean {
  if (!db) return false;

  try {
    const setClauses: string[] = [];
    const params: (string | null)[] = [];

    if (updates.name !== undefined) {
      setClauses.push('name = ?');
      params.push(updates.name);
    }
    if (updates.description !== undefined) {
      setClauses.push('description = ?');
      params.push(updates.description ?? null);
    }
    if (updates.category !== undefined) {
      setClauses.push('category = ?');
      params.push(updates.category ?? null);
    }
    if (updates.content !== undefined) {
      setClauses.push('content = ?');
      params.push(updates.content);
    }
    if (updates.variables !== undefined) {
      setClauses.push('variables = ?');
      params.push(updates.variables ? JSON.stringify(updates.variables) : null);
    }

    if (setClauses.length === 0) return true;

    setClauses.push("modified_at = strftime('%Y-%m-%dT%H:%M:%SZ', 'now')");
    params.push(id);

    db.run(
      `UPDATE templates SET ${setClauses.join(', ')} WHERE id = ?`,
      params
    );

    return true;
  } catch (error) {
    console.error('Failed to update template:', error);
    return false;
  }
}

/**
 * Delete a template.
 */
export function deleteTemplate(db: Database | null, id: string): boolean {
  if (!db) return false;

  try {
    db.run('DELETE FROM templates WHERE id = ?', [id]);
    return true;
  } catch (error) {
    console.error('Failed to delete template:', error);
    return false;
  }
}

/**
 * Increment template usage count when template is inserted.
 */
export function incrementTemplateUsage(db: Database | null, id: string): void {
  if (!db) return;

  try {
    db.run(
      `UPDATE templates
       SET usage_count = usage_count + 1,
           modified_at = strftime('%Y-%m-%dT%H:%M:%SZ', 'now')
       WHERE id = ?`,
      [id]
    );
  } catch (error) {
    console.error('Failed to increment template usage:', error);
  }
}

/**
 * Seed built-in templates if they don't exist.
 * Call this on database initialization.
 */
export function seedBuiltInTemplates(db: Database | null): void {
  if (!db) return;

  const builtInTemplates = [
    {
      id: 'template-builtin-meeting',
      name: 'Meeting Notes',
      description: 'Structured meeting notes with agenda and action items',
      category: 'meeting',
      content: `# Meeting: [Title]

**Date:** {{date}}
**Attendees:**
**Duration:**

## Agenda
- [ ]

## Discussion Notes



## Action Items
- [ ] **[Name]** -

## Next Steps

`,
    },
    {
      id: 'template-builtin-daily',
      name: 'Daily Note',
      description: 'Daily journaling and task tracking',
      category: 'daily',
      content: `# {{date}}

## Today's Focus
-

## Tasks
- [ ]
- [ ]
- [ ]

## Notes



## End of Day Reflection

`,
    },
    {
      id: 'template-builtin-project',
      name: 'Project',
      description: 'Project planning with objectives and milestones',
      category: 'project',
      content: `# Project: [Name]

**Start Date:** {{date}}
**Target Completion:**
**Status:** Not Started

## Objective


## Key Results
1.
2.
3.

## Milestones
- [ ] Milestone 1
- [ ] Milestone 2
- [ ] Milestone 3

## Resources


## Notes

`,
    },
    {
      id: 'template-builtin-task',
      name: 'Task',
      description: 'Simple task with checklist and notes',
      category: 'note',
      content: `# Task: [Title]

**Due:**
**Priority:**

## Description


## Checklist
- [ ]
- [ ]

## Notes

`,
    },
  ];

  try {
    for (const template of builtInTemplates) {
      // Use INSERT OR IGNORE to skip if already exists
      db.run(
        `INSERT OR IGNORE INTO templates (id, name, description, category, content, created_at, modified_at)
         VALUES (?, ?, ?, ?, ?, strftime('%Y-%m-%dT%H:%M:%SZ', 'now'), strftime('%Y-%m-%dT%H:%M:%SZ', 'now'))`,
        [template.id, template.name, template.description, template.category, template.content]
      );
    }
  } catch (error) {
    console.error('Failed to seed built-in templates:', error);
  }
}
```

Key implementation notes:
- Follow the same pattern as backlinks.ts (same error handling, same db access pattern)
- Use INSERT OR IGNORE for built-in templates so they're only seeded once
- Variables support {{date}} and {{time}} placeholders (substitution handled in UI layer)
- FTS5 search falls back to queryTemplates on empty query or error
  </action>
  <verify>
Run `npm run typecheck` - should pass with 0 errors. Run `npm run lint` to check for style issues. Check that all exported functions match the pattern in backlinks.ts.
  </verify>
  <done>
templates.ts exists with:
- Template and TemplateVariable interfaces
- queryTemplates (optionally filtered by category)
- searchTemplates (FTS5 search)
- createTemplate, updateTemplate, deleteTemplate
- incrementTemplateUsage
- seedBuiltInTemplates (4 built-in templates: Meeting Notes, Daily Note, Project, Task)
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire template seeding to database initialization</name>
  <files>src/db/SQLiteProvider.tsx</files>
  <action>
Add template seeding to the database initialization flow in SQLiteProvider.tsx.

Import the seedBuiltInTemplates function and call it after schema is loaded:

```typescript
import { seedBuiltInTemplates } from '../utils/editor/templates';

// In the initialization flow, after db.run(schema):
seedBuiltInTemplates(db);
```

Look for where the schema is executed (likely after initSqlJs() and loading the database) and add the seeding call there.

Note: The seeding uses INSERT OR IGNORE, so it's safe to call on every init - it won't duplicate templates.
  </action>
  <verify>
Run `npm run dev` and open browser console. Look for any "Failed to seed built-in templates" errors. Query the database to verify templates exist:

```javascript
// In browser console
const results = db.exec("SELECT name FROM templates");
console.log(results); // Should show 4 built-in templates
```
  </verify>
  <done>
SQLiteProvider calls seedBuiltInTemplates after schema initialization. Built-in templates (Meeting Notes, Daily Note, Project, Task) are present in database on app load.
  </done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes with 0 errors
2. `npm run lint` passes (or only pre-existing warnings)
3. Schema includes templates table and FTS5 virtual table
4. templates.ts exports all required functions
5. Built-in templates appear in database after app startup
</verification>

<success_criteria>
- Templates table exists in sql.js with FTS5 search capability
- CRUD operations work correctly (create, read, update, delete)
- 4 built-in templates seeded on first load
- No TypeScript or lint errors introduced
</success_criteria>

<output>
After completion, create `.planning/phases/95-data-layer-backlinks/95-01-SUMMARY.md`
</output>
