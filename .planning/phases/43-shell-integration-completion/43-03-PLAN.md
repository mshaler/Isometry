---
phase: 43-shell-integration-completion
plan: 03
type: execute
wave: 2
depends_on: ["43-01"]
files_modified:
  - src/components/gsd/GSDInterface.tsx
  - src/components/gsd/ExecutionProgress.tsx
  - src/components/gsd/RichCommandBuilder.tsx
  - src/components/gsd/ClaudeCodeTerminal.tsx
autonomous: true

must_haves:
  truths:
    - "User can execute GSD commands from Command Builder and see them start"
    - "User sees real-time execution progress with phase indicators"
    - "User sees activity indicator when Claude is working"
    - "User receives toast notification when task completes"
  artifacts:
    - path: "src/components/gsd/GSDInterface.tsx"
      provides: "GSD orchestration with real execution tracking"
      contains: "handleExecutionProgress"
    - path: "src/components/gsd/ExecutionProgress.tsx"
      provides: "Live execution progress display"
      contains: "activeToolUse"
    - path: "src/components/gsd/RichCommandBuilder.tsx"
      provides: "Command builder wired to execution"
      contains: "onCommandExecute"
    - path: "src/components/gsd/ClaudeCodeTerminal.tsx"
      provides: "Terminal with collapsed tool calls"
      contains: "ToolCallRenderer"
  key_links:
    - from: "src/components/gsd/GSDInterface.tsx"
      to: "src/services/claude-code/claudeCodeWebSocketDispatcher.ts"
      via: "dispatcher.onOutput subscription"
      pattern: "getClaudeCodeDispatcher"
    - from: "src/components/gsd/RichCommandBuilder.tsx"
      to: "src/components/gsd/GSDInterface.tsx"
      via: "onCommandExecute callback"
      pattern: "onCommandExecute"
---

<objective>
Wire GSD Command Builder to real execution with live progress tracking and completion notifications.

Purpose: SHELL-05 (GSD command execution) and SHELL-06 (execution progress) connect the GSD GUI to actual Claude Code CLI execution. This transforms the UI from mock data to functional workflow orchestration.

Output: Command Builder executes real commands, ExecutionProgress shows live updates, activity indicator animates during work, and toast notifications appear on completion.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing implementation to enhance
@src/components/gsd/GSDInterface.tsx
@src/components/gsd/ExecutionProgress.tsx
@src/components/gsd/RichCommandBuilder.tsx
@src/components/gsd/ClaudeCodeTerminal.tsx
@src/services/claude-code/claudeCodeWebSocketDispatcher.ts

# Phase 43-01 provides the WebSocket connection infrastructure
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire Command Builder to real execution flow</name>
  <files>src/components/gsd/RichCommandBuilder.tsx, src/components/gsd/GSDInterface.tsx</files>
  <action>
Connect RichCommandBuilder to actual command execution via the WebSocket dispatcher:

1. **In RichCommandBuilder.tsx:**
   - Ensure onCommandExecute callback is properly typed and invoked
   - Add execution state feedback: disable button during execution
   - Show "Executing..." state while command runs
   - Clear command input after successful execution

2. **In GSDInterface.tsx:**
   - Enhance handleBuiltCommandExecute to track execution state:
     ```typescript
     const handleBuiltCommandExecute = async (command: BuiltCommand) => {
       setIsExecuting(true);
       try {
         const dispatcher = await getClaudeCodeDispatcher();
         const execution = await dispatcher.executeAsync({
           command: 'claude',
           args: [command.finalCommand],
           workingDirectory: sessionState?.projectPath || projectRoot
         });
         setCurrentExecutionId(execution.id);

         // Subscribe to output for live updates
         dispatcher.onOutput?.((chunk, execId) => {
           if (execId === execution.id) {
             handleExecutionOutput(chunk);
           }
         });
       } catch (error) {
         setError(`Failed to execute: ${error.message}`);
       }
     };
     ```

3. **Add output subscription:**
   - Parse output for phase transitions (spec -> plan -> implement)
   - Parse output for tool uses (Read, Write, Bash calls)
   - Update sessionState based on parsed output
   - Track active tool use for progress display

4. **Error handling:**
   - Show toast notification on error (per user decision)
   - Load failed command into input for retry editing (per user decision)

Per user decisions:
- GSD commands invoked via slash prefix AND Cmd+K keyboard shortcut
- Command timeout/failure: toast notification plus error details inline
- Failed commands: load into input for editing before retry
  </action>
  <verify>
Run `npm run check:types` to verify no TypeScript errors.
Verify command execution invokes dispatcher.executeAsync().
  </verify>
  <done>
Command Builder executes commands via WebSocket, tracks execution state, and handles errors with retry editing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement live execution progress with activity indicator</name>
  <files>src/components/gsd/ExecutionProgress.tsx, src/components/gsd/GSDInterface.tsx</files>
  <action>
Enhance ExecutionProgress to show real-time execution status:

1. **In ExecutionProgress.tsx:**
   - Add animated cursor indicator when status is 'executing'
   - Show current active tool use (e.g., "Reading src/components/App.tsx...")
   - Update phase indicator based on parsed output
   - Add pulsing animation to active phase

2. **Activity indicator implementation:**
   ```typescript
   {status === 'executing' && (
     <div className="flex items-center gap-2">
       <div className="w-2 h-2 bg-blue-400 rounded-full animate-pulse" />
       <span className="text-blue-300">{activeToolUse || 'Working...'}</span>
     </div>
   )}
   ```

3. **Phase progress parsing in GSDInterface:**
   - Detect phase transitions from output patterns:
     - "Starting spec phase" -> phase: 'spec'
     - "Planning complete" -> phase: 'plan'
     - "Implementing..." -> phase: 'implement'
   - Update phaseHistory with timing data
   - Calculate elapsed time per phase

4. **Status bar updates:**
   - Show current phase prominently
   - Display execution time counter
   - Show file change counts (created/modified/deleted)

Per user decisions:
- Activity indicated by both animated cursor AND status text in toolbar
- Tool calls displayed collapsed by default (click to expand)
  </action>
  <verify>
Run `npm run check:types` to verify no TypeScript errors.
Verify pulsing animation class exists in Tailwind.
  </verify>
  <done>
ExecutionProgress shows animated activity indicator, current tool use, phase transitions, and execution timing.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add completion notifications and collapsed tool calls</name>
  <files>src/components/gsd/GSDInterface.tsx, src/components/gsd/ClaudeCodeTerminal.tsx</files>
  <action>
Add completion notifications and implement collapsed tool call display:

1. **Completion notifications in GSDInterface:**
   - Import toast library or implement simple toast component
   - On execution complete, show success toast:
     ```typescript
     dispatcher.onComplete?.((execId) => {
       if (execId === currentExecutionId) {
         showToast({ type: 'success', message: 'Task completed successfully' });
         setIsExecuting(false);
       }
     });
     ```
   - Toast auto-dismisses after 3 seconds
   - Include brief summary (files changed, duration)

2. **Toast implementation (simple overlay):**
   ```typescript
   const [toasts, setToasts] = useState<Toast[]>([]);

   const showToast = (toast: Toast) => {
     const id = Date.now().toString();
     setToasts(prev => [...prev, { ...toast, id }]);
     setTimeout(() => {
       setToasts(prev => prev.filter(t => t.id !== id));
     }, 3000);
   };
   ```

3. **Collapsed tool calls in ClaudeCodeTerminal.tsx:**
   - Parse output for tool call markers (Read, Write, Bash)
   - Create ToolCallRenderer component:
     ```typescript
     function ToolCallRenderer({ toolCall }: { toolCall: ToolCall }) {
       const [collapsed, setCollapsed] = useState(true);
       return (
         <div className="border-l-2 border-blue-500 pl-2 my-1">
           <button onClick={() => setCollapsed(!collapsed)}>
             <ChevronRight className={collapsed ? '' : 'rotate-90'} />
             <span>{toolCall.type} {toolCall.path}</span>
           </button>
           {!collapsed && <pre>{toolCall.output}</pre>}
         </div>
       );
     }
     ```
   - Default collapsed, click to expand details
   - Show tool type icon and summary in collapsed state

4. **Tool call parsing:**
   - Detect tool patterns in output stream
   - Extract tool type, path/command, and output
   - Group consecutive tool output into single block

Per user decisions:
- Task completion shown via toast notification (brief overlay)
- Tool calls collapsed by default, click to expand
  </action>
  <verify>
Run `npm run check:types` to verify no TypeScript errors.
Verify toast appears on completion and auto-dismisses.
Verify tool calls render collapsed by default.
  </verify>
  <done>
Completion shows toast notification, tool calls render collapsed with expand functionality, and execution provides full feedback loop.
  </done>
</task>

</tasks>

<verification>
1. Run `npm run check:types` - should pass with no errors
2. Run `npm run check:lint` - should have no new lint errors
3. Verify Command Builder executes commands when submitted
4. Verify activity indicator animates during execution
5. Verify toast notification appears on task completion
6. Verify tool calls display collapsed with expand toggle
</verification>

<success_criteria>
- Command Builder executes GSD commands via WebSocket
- ExecutionProgress shows live phase updates and activity indicator
- Toast notification appears on task completion
- Tool calls display collapsed by default with click-to-expand
- All TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/43-shell-integration-completion/43-03-SUMMARY.md`
</output>
