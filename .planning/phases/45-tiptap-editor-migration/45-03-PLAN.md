---
phase: 45-tiptap-editor-migration
plan: 03
type: execute
wave: 2
depends_on: ["45-01"]
files_modified:
  - src/components/notebook/editor/extensions/wiki-links.ts
  - src/components/notebook/editor/WikiLinkMenu.tsx
  - src/components/notebook/editor/TipTapEditor.tsx
  - src/utils/editor/backlinks.ts
autonomous: true

must_haves:
  truths:
    - "User types [[ and sees autocomplete menu with card suggestions"
    - "User selects card from menu and [[Card Title]] appears as clickable link"
    - "User can navigate autocomplete with arrow keys and select with Enter"
    - "User sees suggestions filter as they type within [["
  artifacts:
    - path: "src/components/notebook/editor/extensions/wiki-links.ts"
      provides: "TipTap mark extension for [[wikilink]] syntax"
      exports: ["WikiLink", "createWikiLinkSuggestion"]
    - path: "src/components/notebook/editor/WikiLinkMenu.tsx"
      provides: "React component for wiki link autocomplete popup"
      exports: ["WikiLinkMenu"]
    - path: "src/utils/editor/backlinks.ts"
      provides: "sql.js query utilities for card suggestions"
      exports: ["queryCardsForSuggestions", "queryBacklinks"]
  key_links:
    - from: "src/components/notebook/editor/extensions/wiki-links.ts"
      to: "@tiptap/suggestion"
      via: "Suggestion utility for autocomplete"
      pattern: "Suggestion\\("
    - from: "src/utils/editor/backlinks.ts"
      to: "sql.js"
      via: "db.exec for card queries"
      pattern: "db.exec"
    - from: "src/components/notebook/editor/TipTapEditor.tsx"
      to: "src/components/notebook/editor/extensions/wiki-links.ts"
      via: "extension registration"
      pattern: "WikiLink"
---

<objective>
Implement bidirectional wiki-style links with [[page]] syntax, autocomplete suggestions from sql.js, and clickable link rendering.

Purpose: Enable Zettelkasten-style linking between cards in the notebook, supporting the GRAPH edge creation workflow.
Output: WikiLink TipTap extension that converts [[page]] to linked cards with autocomplete suggestions.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/45-tiptap-editor-migration/45-RESEARCH.md
@.planning/phases/45-tiptap-editor-migration/45-01-SUMMARY.md

@src/db/SQLiteProvider.tsx
@src/db/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create backlinks utility for sql.js queries</name>
  <files>
    src/utils/editor/backlinks.ts
    src/utils/editor/index.ts
    src/utils/index.ts
  </files>
  <action>
1. Create `src/utils/editor/backlinks.ts`:

```typescript
import type { Database } from 'sql.js';

export interface CardSuggestion {
  id: string;
  name: string;
  modifiedAt: string;
}

export interface BacklinkInfo {
  id: string;
  name: string;
  createdAt: string;
}

/**
 * Query sql.js for card suggestions matching the search query.
 * Returns up to 10 most recently modified cards.
 */
export function queryCardsForSuggestions(
  db: Database | null,
  query: string,
  limit: number = 10
): CardSuggestion[] {
  if (!db) return [];

  try {
    const results = db.exec(
      `SELECT id, name, modified_at
       FROM nodes
       WHERE name LIKE ? AND deleted_at IS NULL
       ORDER BY modified_at DESC
       LIMIT ?`,
      [`%${query}%`, limit]
    );

    if (!results[0]?.values) return [];

    return results[0].values.map(([id, name, modifiedAt]) => ({
      id: String(id),
      name: String(name),
      modifiedAt: String(modifiedAt),
    }));
  } catch (error) {
    console.error('Failed to query cards for suggestions:', error);
    return [];
  }
}

/**
 * Query all cards (no filter) for initial display.
 * Returns up to 10 most recently modified cards.
 */
export function queryRecentCards(
  db: Database | null,
  limit: number = 10
): CardSuggestion[] {
  if (!db) return [];

  try {
    const results = db.exec(
      `SELECT id, name, modified_at
       FROM nodes
       WHERE deleted_at IS NULL AND name IS NOT NULL AND name != ''
       ORDER BY modified_at DESC
       LIMIT ?`,
      [limit]
    );

    if (!results[0]?.values) return [];

    return results[0].values.map(([id, name, modifiedAt]) => ({
      id: String(id),
      name: String(name),
      modifiedAt: String(modifiedAt),
    }));
  } catch (error) {
    console.error('Failed to query recent cards:', error);
    return [];
  }
}

/**
 * Query backlinks for a given card - cards that link TO this card.
 * Used for future backlinks panel feature.
 */
export function queryBacklinks(
  db: Database | null,
  cardId: string
): BacklinkInfo[] {
  if (!db) return [];

  try {
    const results = db.exec(
      `SELECT DISTINCT n.id, n.name, e.created_at
       FROM nodes n
       JOIN edges e ON e.source_id = n.id
       WHERE e.target_id = ? AND e.edge_type = 'LINK' AND n.deleted_at IS NULL
       ORDER BY e.created_at DESC`,
      [cardId]
    );

    if (!results[0]?.values) return [];

    return results[0].values.map(([id, name, createdAt]) => ({
      id: String(id),
      name: String(name),
      createdAt: String(createdAt),
    }));
  } catch (error) {
    console.error('Failed to query backlinks:', error);
    return [];
  }
}

/**
 * Create a LINK edge when a wiki link is created.
 * Called when user selects a card from the wiki link autocomplete.
 */
export function createLinkEdge(
  db: Database | null,
  sourceCardId: string,
  targetCardId: string
): boolean {
  if (!db) return false;

  try {
    const now = new Date().toISOString();
    const edgeId = `edge-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

    db.run(
      `INSERT OR IGNORE INTO edges (id, source_id, target_id, edge_type, created_at)
       VALUES (?, ?, ?, 'LINK', ?)`,
      [edgeId, sourceCardId, targetCardId, now]
    );

    return true;
  } catch (error) {
    console.error('Failed to create link edge:', error);
    return false;
  }
}
```

2. Create `src/utils/editor/index.ts`:
```typescript
export * from './backlinks';
```

3. Update `src/utils/index.ts` to include editor exports:
```typescript
// Add to existing exports
export * from './editor';
```
  </action>
  <verify>
- `npm run typecheck` passes
- backlinks.ts exports all functions without errors
  </verify>
  <done>Backlinks utility functions for sql.js card queries and edge creation</done>
</task>

<task type="auto">
  <name>Task 2: Create WikiLink extension and WikiLinkMenu component</name>
  <files>
    src/components/notebook/editor/extensions/wiki-links.ts
    src/components/notebook/editor/WikiLinkMenu.tsx
    src/components/notebook/editor/extensions/index.ts
  </files>
  <action>
1. Create `src/components/notebook/editor/extensions/wiki-links.ts`:

```typescript
import { Mark, mergeAttributes } from '@tiptap/core';
import Suggestion, { SuggestionOptions, SuggestionProps } from '@tiptap/suggestion';
import type { CardSuggestion } from '@/utils/editor/backlinks';

declare module '@tiptap/core' {
  interface Commands<ReturnType> {
    wikiLink: {
      setWikiLink: (attributes: { href: string; title: string }) => ReturnType;
      unsetWikiLink: () => ReturnType;
    };
  }
}

export const WikiLink = Mark.create({
  name: 'wikiLink',

  addOptions() {
    return {
      HTMLAttributes: {},
      suggestion: {} as Partial<SuggestionOptions<CardSuggestion>>,
    };
  },

  addAttributes() {
    return {
      href: {
        default: null,
        parseHTML: (element) => element.getAttribute('href'),
        renderHTML: (attributes) => ({ href: attributes.href }),
      },
      title: {
        default: null,
        parseHTML: (element) => element.getAttribute('title'),
        renderHTML: (attributes) => ({ title: attributes.title }),
      },
    };
  },

  parseHTML() {
    return [
      {
        tag: 'a[data-type="wiki-link"]',
      },
    ];
  },

  renderHTML({ HTMLAttributes }) {
    return [
      'a',
      mergeAttributes(
        this.options.HTMLAttributes,
        HTMLAttributes,
        {
          'data-type': 'wiki-link',
          class: 'wiki-link text-blue-600 underline cursor-pointer hover:text-blue-800',
        }
      ),
      0,
    ];
  },

  addCommands() {
    return {
      setWikiLink:
        (attributes) =>
        ({ commands }) => {
          return commands.setMark(this.name, attributes);
        },
      unsetWikiLink:
        () =>
        ({ commands }) => {
          return commands.unsetMark(this.name);
        },
    };
  },

  addProseMirrorPlugins() {
    return [
      Suggestion({
        editor: this.editor,
        ...this.options.suggestion,
      }),
    ];
  },
});

export interface WikiLinkSuggestionProps extends SuggestionProps<CardSuggestion> {
  // Extend if needed
}

export function createWikiLinkSuggestion(
  queryFn: (query: string) => CardSuggestion[],
  onSelectFn: (item: CardSuggestion, sourceCardId: string | undefined) => void,
  sourceCardId: string | undefined,
  renderConfig: Partial<SuggestionOptions<CardSuggestion>['render']>
): Partial<SuggestionOptions<CardSuggestion>> {
  return {
    char: '[[',
    allowSpaces: true,
    items: ({ query }) => {
      return queryFn(query);
    },
    command: ({ editor, range, props }) => {
      // Insert the link text with wiki link mark
      editor
        .chain()
        .focus()
        .deleteRange(range)
        .insertContent([
          {
            type: 'text',
            text: props.name,
            marks: [
              {
                type: 'wikiLink',
                attrs: {
                  href: `#card-${props.id}`,
                  title: props.name,
                },
              },
            ],
          },
        ])
        .run();

      // Create the LINK edge in sql.js
      onSelectFn(props, sourceCardId);
    },
    render: renderConfig,
  };
}
```

2. Create `src/components/notebook/editor/WikiLinkMenu.tsx`:

```typescript
import React, { forwardRef, useEffect, useImperativeHandle, useState, useCallback } from 'react';
import { FileText, Clock } from 'lucide-react';
import { useTheme } from '@/contexts/ThemeContext';
import type { CardSuggestion } from '@/utils/editor/backlinks';

export interface WikiLinkMenuRef {
  onKeyDown: (props: { event: KeyboardEvent }) => boolean;
}

interface WikiLinkMenuProps {
  items: CardSuggestion[];
  command: (item: CardSuggestion) => void;
}

function formatRelativeTime(dateString: string): string {
  const date = new Date(dateString);
  const now = new Date();
  const diffMs = now.getTime() - date.getTime();
  const diffMins = Math.floor(diffMs / 60000);
  const diffHours = Math.floor(diffMins / 60);
  const diffDays = Math.floor(diffHours / 24);

  if (diffMins < 1) return 'just now';
  if (diffMins < 60) return `${diffMins}m ago`;
  if (diffHours < 24) return `${diffHours}h ago`;
  if (diffDays < 7) return `${diffDays}d ago`;
  return date.toLocaleDateString();
}

export const WikiLinkMenu = forwardRef<WikiLinkMenuRef, WikiLinkMenuProps>(
  ({ items, command }, ref) => {
    const { theme } = useTheme();
    const [selectedIndex, setSelectedIndex] = useState(0);

    useEffect(() => {
      setSelectedIndex(0);
    }, [items]);

    const selectItem = useCallback((index: number) => {
      const item = items[index];
      if (item) {
        command(item);
      }
    }, [items, command]);

    useImperativeHandle(ref, () => ({
      onKeyDown: ({ event }) => {
        if (event.key === 'ArrowUp') {
          setSelectedIndex((prev) => (prev <= 0 ? items.length - 1 : prev - 1));
          return true;
        }

        if (event.key === 'ArrowDown') {
          setSelectedIndex((prev) => (prev >= items.length - 1 ? 0 : prev + 1));
          return true;
        }

        if (event.key === 'Enter' || event.key === 'Tab') {
          selectItem(selectedIndex);
          return true;
        }

        return false;
      },
    }), [items.length, selectedIndex, selectItem]);

    if (items.length === 0) {
      return (
        <div className={`z-50 ${
          theme === 'NeXTSTEP'
            ? 'bg-[#c0c0c0] border-[#707070] shadow-md'
            : 'bg-white border-gray-300 shadow-lg'
        } border rounded-lg min-w-[280px] p-4 text-center text-gray-500 text-sm`}>
          <FileText size={24} className="mx-auto mb-2 text-gray-400" />
          <div className="mb-1">No cards found</div>
          <div className="text-xs">Type to search for cards</div>
        </div>
      );
    }

    return (
      <div className={`z-50 ${
        theme === 'NeXTSTEP'
          ? 'bg-[#c0c0c0] border-[#707070] shadow-md'
          : 'bg-white border-gray-300 shadow-lg'
      } border rounded-lg min-w-[280px] max-h-[250px] overflow-y-auto`}>
        <div className={`p-2 text-xs text-gray-500 border-b ${
          theme === 'NeXTSTEP' ? 'border-[#707070] bg-[#d4d4d4]' : 'border-gray-200 bg-gray-50'
        }`}>
          <div className="flex items-center gap-1">
            <span>Link to card...</span>
          </div>
        </div>
        <div className="py-1">
          {items.map((item, index) => (
            <button
              key={item.id}
              onClick={() => selectItem(index)}
              className={`w-full text-left p-2 flex items-center gap-2 transition-colors ${
                index === selectedIndex
                  ? theme === 'NeXTSTEP' ? 'bg-[#0066cc] text-white' : 'bg-blue-500 text-white'
                  : `hover:${theme === 'NeXTSTEP' ? 'bg-[#b0b0b0]' : 'bg-gray-100'}`
              }`}
            >
              <FileText
                size={14}
                className={index === selectedIndex ? 'text-white' : 'text-gray-500'}
              />
              <div className="flex-1 min-w-0">
                <div className="font-medium text-sm truncate">{item.name}</div>
                <div className={`text-xs flex items-center gap-1 ${
                  index === selectedIndex ? 'text-white/70' : 'text-gray-400'
                }`}>
                  <Clock size={10} />
                  <span>{formatRelativeTime(item.modifiedAt)}</span>
                </div>
              </div>
            </button>
          ))}
        </div>
        <div className={`p-2 text-xs text-gray-500 border-t ${
          theme === 'NeXTSTEP' ? 'border-[#707070] bg-[#d4d4d4]' : 'border-gray-200 bg-gray-50'
        }`}>
          <div className="flex justify-between">
            <span>Arrow keys: Navigate</span>
            <span>Enter: Link | Esc: Cancel</span>
          </div>
        </div>
      </div>
    );
  }
);

WikiLinkMenu.displayName = 'WikiLinkMenu';
```

3. Update `src/components/notebook/editor/extensions/index.ts`:
```typescript
export { SlashCommands, SLASH_COMMANDS, createSlashCommandSuggestion } from './slash-commands';
export type { SlashCommand, SlashCommandSuggestionProps } from './slash-commands';
export { WikiLink, createWikiLinkSuggestion } from './wiki-links';
export type { WikiLinkSuggestionProps } from './wiki-links';
```
  </action>
  <verify>
- `npm run typecheck` passes
- wiki-links.ts exports correctly
- WikiLinkMenu.tsx has no TypeScript errors
  </verify>
  <done>WikiLink extension and autocomplete menu component created</done>
</task>

<task type="auto">
  <name>Task 3: Integrate WikiLink into TipTapEditor with sql.js queries</name>
  <files>
    src/components/notebook/editor/TipTapEditor.tsx
    src/components/notebook/editor/index.ts
  </files>
  <action>
1. Update `src/components/notebook/editor/TipTapEditor.tsx`:

Add imports:
```typescript
import { WikiLink, createWikiLinkSuggestion } from './extensions';
import { WikiLinkMenu, WikiLinkMenuRef } from './WikiLinkMenu';
import { queryCardsForSuggestions, queryRecentCards, createLinkEdge } from '@/utils/editor/backlinks';
import { useSQLite } from '@/db/SQLiteProvider';
import { useNotebook } from '@/contexts/NotebookContext';
```

Inside the TipTapEditor component:
```typescript
const { db } = useSQLite();
const { activeCard } = useNotebook();

// Query function for wiki link suggestions
const queryCards = useCallback((query: string) => {
  if (!query) {
    return queryRecentCards(db, 10);
  }
  return queryCardsForSuggestions(db, query, 10);
}, [db]);

// Handler when user selects a card to link
const handleLinkSelect = useCallback((item: CardSuggestion, sourceCardId: string | undefined) => {
  if (sourceCardId && item.id !== sourceCardId) {
    createLinkEdge(db, sourceCardId, item.id);
  }
}, [db]);

// Add WikiLink to extensions array:
const editor = useEditor({
  extensions: [
    StarterKit,
    Placeholder.configure({
      placeholder: 'Type / for commands, [[ for links...',
    }),
    Markdown,
    SlashCommands.configure({
      // ... existing config
    }),
    WikiLink.configure({
      suggestion: createWikiLinkSuggestion(
        queryCards,
        handleLinkSelect,
        activeCard?.nodeId,
        {
          render: () => {
            let component: ReactRenderer<WikiLinkMenuRef>;
            let popup: Instance[];

            return {
              onStart: (props) => {
                component = new ReactRenderer(WikiLinkMenu, {
                  props,
                  editor: props.editor,
                });

                if (!props.clientRect) return;

                popup = tippy('body', {
                  getReferenceClientRect: props.clientRect as () => DOMRect,
                  appendTo: () => document.body,
                  content: component.element,
                  showOnCreate: true,
                  interactive: true,
                  trigger: 'manual',
                  placement: 'bottom-start',
                });
              },

              onUpdate(props) {
                component.updateProps(props);

                if (!props.clientRect) return;

                popup[0]?.setProps({
                  getReferenceClientRect: props.clientRect as () => DOMRect,
                });
              },

              onKeyDown(props) {
                if (props.event.key === 'Escape') {
                  popup[0]?.hide();
                  return true;
                }

                return component.ref?.onKeyDown(props) ?? false;
              },

              onExit() {
                popup[0]?.destroy();
                component.destroy();
              },
            };
          },
        }
      ),
    }),
  ],
  // ... rest of config
});
```

2. Add CSS for wiki links in the editor styles (or inline):
```typescript
// Add to TipTapEditor component or create separate CSS
const wikiLinkStyles = `
  .wiki-link {
    color: #2563eb;
    text-decoration: underline;
    cursor: pointer;
  }
  .wiki-link:hover {
    color: #1d4ed8;
  }
`;

// Include in component render
<style>{wikiLinkStyles}</style>
```

3. Update `src/components/notebook/editor/index.ts`:
```typescript
export { TipTapEditor } from './TipTapEditor';
export { EditorToolbar } from './EditorToolbar';
export { SlashCommandMenu } from './SlashCommandMenu';
export { WikiLinkMenu } from './WikiLinkMenu';
export * from './extensions';
```
  </action>
  <verify>
- `npm run typecheck` passes
- `npm run dev` starts without errors
- Typing "[[" shows autocomplete menu with recent cards
- Typing "[[proj" filters to cards containing "proj"
- Arrow keys navigate suggestions
- Enter/Tab inserts link with wiki-link styling
- Link edge is created in sql.js edges table
  </verify>
  <done>WikiLink extension integrated with sql.js queries and edge creation</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Type check: `npm run typecheck` - zero errors
2. Dev server: `npm run dev` - starts without errors
3. Manual tests:
   - Type "[[" - menu appears with recent cards
   - Type "[[test" - filters to cards with "test" in name
   - Arrow down/up - navigates suggestions
   - Press Enter - inserts card name as clickable link
   - Link text is styled (blue, underline)
   - Check edges table - new LINK edge exists
4. Round-trip test:
   - Create wiki link to a card
   - Save the content
   - Reload page
   - Wiki link still renders correctly
</verification>

<success_criteria>
- [[ triggers autocomplete popup with card suggestions
- Suggestions query sql.js nodes table
- Filtering works as user types after [[
- Keyboard navigation works (up/down arrows)
- Enter/Tab inserts selected card as clickable link
- Link styled with wiki-link class (blue, underline)
- LINK edge created in sql.js edges table
- Wiki links persist in Markdown and re-render correctly
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/45-tiptap-editor-migration/45-03-SUMMARY.md`
</output>
