---
phase: 60-supergrid-stacked-headers
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/grid.ts
  - src/types/pafv.ts
  - src/services/supergrid/HeaderLayoutService.ts
autonomous: true

must_haves:
  truths:
    - "PAFV projection can assign multiple facets to a single plane (stacked axis)"
    - "Multi-level header hierarchy computes correct parent-child relationships from card data"
    - "Parent header span equals sum of child spans (verified by test assertion)"
  artifacts:
    - path: "src/types/grid.ts"
      provides: "Extended AxisProjection with facets?: string[] for stacked axes"
      contains: "facets?: string[]"
    - path: "src/types/pafv.ts"
      provides: "StackedAxisConfig interface for multi-facet configuration"
      contains: "StackedAxisConfig"
    - path: "src/services/supergrid/HeaderLayoutService.ts"
      provides: "generateStackedHierarchy method for multi-facet hierarchies"
      exports: ["generateStackedHierarchy"]
  key_links:
    - from: "src/services/supergrid/HeaderLayoutService.ts"
      to: "d3-hierarchy stratify"
      via: "stratify().id().parentId()"
      pattern: "stratify.*parentId"
    - from: "src/types/grid.ts"
      to: "src/types/pafv.ts"
      via: "AxisProjection uses LATCHAxis"
      pattern: "import.*LATCHAxis"
---

<objective>
Extend PAFV type system and HeaderLayoutService to support multi-facet (stacked) axis hierarchies.

Purpose: Enable hierarchical headers when multiple facets are assigned to the same plane (e.g., Year -> Quarter -> Month on Y-axis). This is the foundation for Excel-style pivot table headers.

Output: Extended types and new `generateStackedHierarchy()` method that produces parent-child HeaderNode trees from multiple facets.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/60-supergrid-stacked-headers/60-RESEARCH.md

Key files:
@src/types/grid.ts — AxisProjection type (extend with facets?: string[])
@src/types/pafv.ts — AxisMapping, LATCHAxis types
@src/services/supergrid/HeaderLayoutService.ts — Existing generateHeaderHierarchy (add generateStackedHierarchy)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend AxisProjection type with stacked facets support</name>
  <files>src/types/grid.ts, src/types/pafv.ts</files>
  <action>
1. In `src/types/grid.ts`, extend `AxisProjection` interface:
```typescript
export interface AxisProjection {
  axis: LATCHAxis;
  facet: string; // Primary facet (backward compatible)
  facets?: string[]; // Optional array for stacked hierarchy (e.g., ['year', 'quarter', 'month'])
}
```

2. In `src/types/pafv.ts`, add StackedAxisConfig interface:
```typescript
/** Configuration for multi-facet stacked axis hierarchy */
export interface StackedAxisConfig {
  axis: LATCHAxis;
  facets: string[]; // Ordered from parent to child (e.g., ['year', 'quarter', 'month'])
}
```

3. Update `mappingsToProjection()` function in `src/types/grid.ts` to preserve facets array if present in mapping.

4. Ensure HeaderNode interface in grid.ts has the `facet` field documented (already exists but verify).
  </action>
  <verify>
```bash
npm run typecheck
grep -n "facets?" src/types/grid.ts
grep -n "StackedAxisConfig" src/types/pafv.ts
```
  </verify>
  <done>AxisProjection has optional `facets?: string[]` field. StackedAxisConfig interface exists in pafv.ts. Types compile without errors.</done>
</task>

<task type="auto">
  <name>Task 2a: Add generateStackedHierarchy skeleton with d3.stratify</name>
  <files>src/services/supergrid/HeaderLayoutService.ts</files>
  <action>
Add the public method signature and core structure using d3.stratify:

1. Add import at top of file:
```typescript
import { stratify, HierarchyNode } from 'd3-hierarchy';
```

2. Add method skeleton:
```typescript
/**
 * Generate header hierarchy from multiple stacked facets
 * @param cards - Array of card records
 * @param stackedConfig - Axis with ordered facets (parent to child)
 * @returns HeaderHierarchy with computed spans and positions
 */
public generateStackedHierarchy(
  cards: unknown[],
  stackedConfig: StackedAxisConfig
): HeaderHierarchy {
  const flatNodes: HeaderNode[] = [];
  const { axis, facets } = stackedConfig;

  // Root node
  flatNodes.push({
    id: `${axis}-root`,
    label: axis.toUpperCase(),
    parentId: undefined,
    level: 0,
    span: 0, // Will be computed
    // ... other required HeaderNode fields
  });

  // Build nodes for each facet level (implemented in Task 2b)
  facets.forEach((facet, levelIndex) => {
    const uniqueValues = this.extractUniqueFacetValues(cards, facet);
    uniqueValues.forEach(value => {
      const parentId = levelIndex > 0
        ? this.findParentNodeId(cards, facets, levelIndex, value, axis)
        : `${axis}-root`;
      flatNodes.push({
        id: `${axis}-${facet}-${value}`,
        label: this.formatLabel(value, facet),
        parentId,
        level: levelIndex + 1,
        facet,
        span: 1, // Leaf default
      });
    });
  });

  // Use d3.stratify to build hierarchy
  const stratifyFn = stratify<HeaderNode>()
    .id(d => d.id)
    .parentId(d => d.parentId);
  const root = stratifyFn(flatNodes);

  // Calculate spans bottom-up
  this.calculateStackedSpans(root);

  return this.buildHeaderHierarchyResult(root, axis, flatNodes);
}
```

Note: d3-hierarchy is included in the main d3 package (already installed).
  </action>
  <verify>
```bash
# Verify d3 is installed (includes d3-hierarchy)
grep '"d3":' package.json
npm run typecheck
grep -n "generateStackedHierarchy" src/services/supergrid/HeaderLayoutService.ts
```
  </verify>
  <done>generateStackedHierarchy method exists with stratify-based hierarchy building. d3 dependency verified.</done>
</task>

<task type="auto">
  <name>Task 2b: Implement helper methods for stacked hierarchy</name>
  <files>src/services/supergrid/HeaderLayoutService.ts</files>
  <action>
Add the helper methods required by generateStackedHierarchy:

```typescript
/** Extract unique values for a facet from cards */
private extractUniqueFacetValues(cards: unknown[], facet: string): string[] {
  const values = new Set<string>();
  cards.forEach(card => {
    const value = (card as Record<string, unknown>)[facet];
    if (value != null) values.add(String(value));
  });
  return Array.from(values).sort();
}

/** Find parent node ID for a child value at given level */
private findParentNodeId(
  cards: unknown[],
  facets: string[],
  levelIndex: number,
  childValue: string,
  axis: string
): string {
  const parentFacet = facets[levelIndex - 1];
  const childFacet = facets[levelIndex];
  // Find a card with this child value and get its parent value
  const card = cards.find(c =>
    String((c as Record<string, unknown>)[childFacet]) === childValue
  );
  if (card) {
    const parentValue = (card as Record<string, unknown>)[parentFacet];
    return `${axis}-${parentFacet}-${parentValue}`;
  }
  return `${axis}-root`;
}

/** Calculate spans bottom-up using d3-hierarchy eachAfter */
private calculateStackedSpans(root: HierarchyNode<HeaderNode>): void {
  root.eachAfter(node => {
    if (!node.children || node.children.length === 0) {
      node.data.span = 1; // Leaf nodes have span of 1
    } else {
      node.data.span = node.children.reduce((sum, child) => sum + child.data.span, 0);
    }
  });
}

/** Format value for display (date formatting, etc.) */
private formatLabel(value: string, facet: string): string {
  // Basic formatting - could be enhanced for dates
  return value;
}

/** Build final HeaderHierarchy result object */
private buildHeaderHierarchyResult(
  root: HierarchyNode<HeaderNode>,
  axis: string,
  flatNodes: HeaderNode[]
): HeaderHierarchy {
  return {
    axis,
    rootNodes: root.children?.map(c => c.data) || [],
    allNodes: flatNodes,
    maxDepth: root.height,
    totalWidth: this.calculateTotalWidth(root),
    totalHeight: (root.height + 1) * 40,
    expandedNodeIds: new Set(),
    collapsedSubtrees: new Set(),
    config: this.config,
    lastUpdated: Date.now()
  };
}
```
  </action>
  <verify>
```bash
npm run typecheck
grep -n "calculateStackedSpans" src/services/supergrid/HeaderLayoutService.ts
grep -n "extractUniqueFacetValues" src/services/supergrid/HeaderLayoutService.ts
```
  </verify>
  <done>Helper methods implemented: extractUniqueFacetValues, findParentNodeId, calculateStackedSpans, formatLabel, buildHeaderHierarchyResult. Types compile.</done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for stacked hierarchy generation (including STACK-02 span verification)</name>
  <files>src/services/supergrid/__tests__/HeaderLayoutService.test.ts</files>
  <action>
Create or extend test file with tests for stacked hierarchy generation. CRITICAL: Include test assertion that verifies STACK-02 requirement (parent span = sum of child spans).

```typescript
describe('HeaderLayoutService.generateStackedHierarchy', () => {
  let service: HeaderLayoutService;

  beforeEach(() => {
    service = new HeaderLayoutService();
  });

  it('generates two-level hierarchy from Year -> Quarter facets', () => {
    const cards = [
      { year: '2024', quarter: 'Q1' },
      { year: '2024', quarter: 'Q2' },
      { year: '2023', quarter: 'Q4' },
    ];

    const hierarchy = service.generateStackedHierarchy(cards, {
      axis: 'time',
      facets: ['year', 'quarter']
    });

    // Root + 2 years + 3 quarters = 6 nodes
    expect(hierarchy.allNodes.length).toBe(6);
    expect(hierarchy.maxDepth).toBe(2);

    // 2024 should have span of 2 (Q1 + Q2)
    const year2024 = hierarchy.allNodes.find(n => n.id.includes('year-2024'));
    expect(year2024?.span).toBe(2);
  });

  // STACK-02 VERIFICATION: Parent header cells visually span across their child headers
  it('verifies STACK-02: parent span equals sum of child spans', () => {
    const cards = [
      { category: 'A', subcategory: 'A1' },
      { category: 'A', subcategory: 'A2' },
      { category: 'A', subcategory: 'A3' },
      { category: 'B', subcategory: 'B1' },
    ];

    const hierarchy = service.generateStackedHierarchy(cards, {
      axis: 'category',
      facets: ['category', 'subcategory']
    });

    // Find parent nodes (level 1) and verify their spans
    const parentNodes = hierarchy.allNodes.filter(n => n.level === 1);

    parentNodes.forEach(parent => {
      // Find children of this parent
      const children = hierarchy.allNodes.filter(n => n.parentId === parent.id);
      const sumOfChildSpans = children.reduce((sum, child) => sum + (child.span || 0), 0);

      // STACK-02 REQUIREMENT: parent.span === sum(child.span)
      expect(parent.span).toBe(sumOfChildSpans);
    });

    // Explicit assertions for clarity
    const catA = hierarchy.allNodes.find(n => n.id.includes('category-A'));
    const catB = hierarchy.allNodes.find(n => n.id.includes('category-B'));

    expect(catA?.span).toBe(3); // A1(1) + A2(1) + A3(1) = 3
    expect(catB?.span).toBe(1); // B1(1) = 1
  });

  it('handles single-facet gracefully (backwards compatible)', () => {
    const cards = [{ status: 'todo' }, { status: 'done' }];

    const hierarchy = service.generateStackedHierarchy(cards, {
      axis: 'category',
      facets: ['status'] // Single facet
    });

    expect(hierarchy.maxDepth).toBe(1);
    expect(hierarchy.allNodes.filter(n => n.level === 1).length).toBe(2);
  });
});
```

Ensure tests run and pass.
  </action>
  <verify>
```bash
npm run test -- --testPathPattern="HeaderLayoutService" --run
```
  </verify>
  <done>Unit tests for generateStackedHierarchy exist and pass. STACK-02 requirement verified: test asserts parent.span equals sum(child.span) at runtime.</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npm run typecheck` passes
2. Extended types work: grep confirms facets? in AxisProjection, StackedAxisConfig in pafv.ts
3. Service method exists: grep confirms generateStackedHierarchy in HeaderLayoutService
4. Tests pass: vitest runs HeaderLayoutService tests successfully
</verification>

<success_criteria>
1. AxisProjection interface has `facets?: string[]` field for stacked axis support
2. StackedAxisConfig interface defined in pafv.ts
3. HeaderLayoutService.generateStackedHierarchy() produces correct hierarchy with spans
4. Unit tests verify span calculation (parent span = sum of child spans)
5. All TypeScript compilation passes
</success_criteria>

<output>
After completion, create `.planning/phases/60-supergrid-stacked-headers/60-01-SUMMARY.md`
</output>
