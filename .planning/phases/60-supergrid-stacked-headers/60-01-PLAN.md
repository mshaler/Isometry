---
phase: 60-supergrid-stacked-headers
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/grid.ts
  - src/types/pafv.ts
  - src/services/supergrid/HeaderLayoutService.ts
autonomous: true

must_haves:
  truths:
    - "AxisProjection supports multiple stacked facets via optional facets array"
    - "HeaderLayoutService.generateStackedHierarchy() produces parent-child HeaderNode tree from multiple facets"
    - "Parent nodes have correct span values equal to sum of child spans"
  artifacts:
    - path: "src/types/grid.ts"
      provides: "Extended AxisProjection with facets?: string[] for stacked axes"
      contains: "facets?: string[]"
    - path: "src/types/pafv.ts"
      provides: "StackedAxisConfig interface for multi-facet configuration"
      contains: "StackedAxisConfig"
    - path: "src/services/supergrid/HeaderLayoutService.ts"
      provides: "generateStackedHierarchy method for multi-facet hierarchies"
      exports: ["generateStackedHierarchy"]
  key_links:
    - from: "src/services/supergrid/HeaderLayoutService.ts"
      to: "d3-hierarchy stratify"
      via: "stratify().id().parentId()"
      pattern: "stratify.*parentId"
    - from: "src/types/grid.ts"
      to: "src/types/pafv.ts"
      via: "AxisProjection uses LATCHAxis"
      pattern: "import.*LATCHAxis"
---

<objective>
Extend PAFV type system and HeaderLayoutService to support multi-facet (stacked) axis hierarchies.

Purpose: Enable hierarchical headers when multiple facets are assigned to the same plane (e.g., Year -> Quarter -> Month on Y-axis). This is the foundation for Excel-style pivot table headers.

Output: Extended types and new `generateStackedHierarchy()` method that produces parent-child HeaderNode trees from multiple facets.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/60-supergrid-stacked-headers/60-RESEARCH.md

Key files:
@src/types/grid.ts — AxisProjection type (extend with facets?: string[])
@src/types/pafv.ts — AxisMapping, LATCHAxis types
@src/services/supergrid/HeaderLayoutService.ts — Existing generateHeaderHierarchy (add generateStackedHierarchy)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend AxisProjection type with stacked facets support</name>
  <files>src/types/grid.ts, src/types/pafv.ts</files>
  <action>
1. In `src/types/grid.ts`, extend `AxisProjection` interface:
```typescript
export interface AxisProjection {
  axis: LATCHAxis;
  facet: string; // Primary facet (backward compatible)
  facets?: string[]; // Optional array for stacked hierarchy (e.g., ['year', 'quarter', 'month'])
}
```

2. In `src/types/pafv.ts`, add StackedAxisConfig interface:
```typescript
/** Configuration for multi-facet stacked axis hierarchy */
export interface StackedAxisConfig {
  axis: LATCHAxis;
  facets: string[]; // Ordered from parent to child (e.g., ['year', 'quarter', 'month'])
}
```

3. Update `mappingsToProjection()` function in `src/types/grid.ts` to preserve facets array if present in mapping.

4. Ensure HeaderNode interface in grid.ts has the `facet` field documented (already exists but verify).
  </action>
  <verify>
```bash
npm run typecheck
grep -n "facets?" src/types/grid.ts
grep -n "StackedAxisConfig" src/types/pafv.ts
```
  </verify>
  <done>AxisProjection has optional `facets?: string[]` field. StackedAxisConfig interface exists in pafv.ts. Types compile without errors.</done>
</task>

<task type="auto">
  <name>Task 2: Implement generateStackedHierarchy in HeaderLayoutService</name>
  <files>src/services/supergrid/HeaderLayoutService.ts</files>
  <action>
Add new public method `generateStackedHierarchy()` that builds multi-level HeaderNode tree from multiple facets:

```typescript
/**
 * Generate header hierarchy from multiple stacked facets
 * Creates parent-child relationships based on facet ordering
 *
 * @param cards - Array of card records
 * @param stackedConfig - Axis with ordered facets (parent to child)
 * @returns HeaderHierarchy with computed spans and positions
 */
public generateStackedHierarchy(
  cards: unknown[],
  stackedConfig: StackedAxisConfig
): HeaderHierarchy {
  // 1. Build flat HeaderNode array with parent references
  const flatNodes: HeaderNode[] = [];
  const { axis, facets } = stackedConfig;

  // Root node
  const rootId = `${axis}-root`;
  flatNodes.push({
    id: rootId,
    label: axis.toUpperCase(),
    parentId: undefined,
    level: 0,
    // ... other HeaderNode fields
  });

  // 2. For each facet level, extract unique values and create nodes
  // Track parent-value mapping: for each value at level N, find its parent at level N-1
  // Use data to derive relationships (e.g., 'Jan 2024' belongs to 'Q1 2024')

  facets.forEach((facet, levelIndex) => {
    // Extract unique values for this facet
    const uniqueValues = this.extractUniqueFacetValues(cards, facet);

    uniqueValues.forEach(value => {
      // Determine parent: if level > 0, find the parent value
      const parentValue = levelIndex > 0
        ? this.findParentValue(cards, facets[levelIndex - 1], facet, value)
        : null;

      const parentId = parentValue
        ? `${axis}-${facets[levelIndex - 1]}-${parentValue}`
        : rootId;

      flatNodes.push({
        id: `${axis}-${facet}-${value}`,
        label: this.formatLabel(value, facet),
        parentId,
        level: levelIndex + 1,
        facet, // Store facet for sorting
        // ... other HeaderNode fields initialized
      });
    });
  });

  // 3. Use d3.stratify to build hierarchy
  const stratifyFn = stratify<HeaderNode>()
    .id(d => d.id)
    .parentId(d => d.parentId);

  const root = stratifyFn(flatNodes);

  // 4. Calculate spans bottom-up (parent span = sum of child spans)
  this.calculateStackedSpans(root);

  // 5. Calculate layout positions
  this.calculateLayout(root);

  return {
    axis,
    rootNodes: root.children?.map(c => c.data) || [],
    allNodes: flatNodes,
    maxDepth: root.height,
    totalWidth: this.calculateTotalWidth(root),
    totalHeight: (root.height + 1) * 40,
    expandedNodeIds: new Set(),
    collapsedSubtrees: new Set(),
    config: this.config,
    lastUpdated: Date.now()
  };
}
```

Implement helper methods:
- `extractUniqueFacetValues(cards, facet)` - Get unique values for a facet
- `findParentValue(cards, parentFacet, childFacet, childValue)` - Find parent value for a child
- `calculateStackedSpans(root)` - Bottom-up span calculation using eachAfter
- `formatLabel(value, facet)` - Format value for display (date formatting, etc.)

The key insight: span calculation uses d3-hierarchy's `eachAfter()` for bottom-up traversal. Leaf nodes have span=1, parent span = sum of child spans.
  </action>
  <verify>
```bash
npm run typecheck
grep -n "generateStackedHierarchy" src/services/supergrid/HeaderLayoutService.ts
```
  </verify>
  <done>HeaderLayoutService has generateStackedHierarchy method that produces HeaderHierarchy with correct parent-child relationships and span calculations. Types compile.</done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for stacked hierarchy generation</name>
  <files>src/services/supergrid/__tests__/HeaderLayoutService.test.ts</files>
  <action>
Create or extend test file with tests for stacked hierarchy generation:

```typescript
describe('HeaderLayoutService.generateStackedHierarchy', () => {
  let service: HeaderLayoutService;

  beforeEach(() => {
    service = new HeaderLayoutService();
  });

  it('generates two-level hierarchy from Year -> Quarter facets', () => {
    const cards = [
      { year: '2024', quarter: 'Q1' },
      { year: '2024', quarter: 'Q2' },
      { year: '2023', quarter: 'Q4' },
    ];

    const hierarchy = service.generateStackedHierarchy(cards, {
      axis: 'time',
      facets: ['year', 'quarter']
    });

    // Root + 2 years + 3 quarters = 6 nodes
    expect(hierarchy.allNodes.length).toBe(6);
    expect(hierarchy.maxDepth).toBe(2);

    // 2024 should have span of 2 (Q1 + Q2)
    const year2024 = hierarchy.allNodes.find(n => n.id.includes('year-2024'));
    expect(year2024?.span).toBe(2);
  });

  it('calculates correct spans bottom-up', () => {
    const cards = [
      { category: 'A', subcategory: 'A1' },
      { category: 'A', subcategory: 'A2' },
      { category: 'A', subcategory: 'A3' },
      { category: 'B', subcategory: 'B1' },
    ];

    const hierarchy = service.generateStackedHierarchy(cards, {
      axis: 'category',
      facets: ['category', 'subcategory']
    });

    const catA = hierarchy.allNodes.find(n => n.id.includes('category-A'));
    const catB = hierarchy.allNodes.find(n => n.id.includes('category-B'));

    expect(catA?.span).toBe(3); // A1 + A2 + A3
    expect(catB?.span).toBe(1); // B1
  });

  it('handles single-facet gracefully (backwards compatible)', () => {
    const cards = [{ status: 'todo' }, { status: 'done' }];

    const hierarchy = service.generateStackedHierarchy(cards, {
      axis: 'category',
      facets: ['status'] // Single facet
    });

    expect(hierarchy.maxDepth).toBe(1);
    expect(hierarchy.allNodes.filter(n => n.level === 1).length).toBe(2);
  });
});
```

Ensure tests run and pass.
  </action>
  <verify>
```bash
npm run test -- --testPathPattern="HeaderLayoutService" --run
```
  </verify>
  <done>Unit tests for generateStackedHierarchy exist and pass. Tests verify parent-child relationships and span calculations.</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npm run typecheck` passes
2. Extended types work: grep confirms facets? in AxisProjection, StackedAxisConfig in pafv.ts
3. Service method exists: grep confirms generateStackedHierarchy in HeaderLayoutService
4. Tests pass: vitest runs HeaderLayoutService tests successfully
</verification>

<success_criteria>
1. AxisProjection interface has `facets?: string[]` field for stacked axis support
2. StackedAxisConfig interface defined in pafv.ts
3. HeaderLayoutService.generateStackedHierarchy() produces correct hierarchy with spans
4. Unit tests verify span calculation (parent span = sum of child spans)
5. All TypeScript compilation passes
</success_criteria>

<output>
After completion, create `.planning/phases/60-supergrid-stacked-headers/60-01-SUMMARY.md`
</output>
