---
phase: 60-supergrid-stacked-headers
plan: 02
type: execute
wave: 2
depends_on: ["60-01"]
files_modified:
  - src/d3/SuperGridHeaders.ts
  - src/d3/grid-rendering/GridRenderingEngine.ts
  - src/d3/header-rendering/HeaderProgressiveRenderer.ts
autonomous: true

must_haves:
  truths:
    - "Multi-level headers render when PAFVProjection has stacked facets"
    - "Parent headers visually span across their child headers (Excel pivot style)"
    - "Headers integrate with existing SuperGridHeaders orchestrator"
  artifacts:
    - path: "src/d3/SuperGridHeaders.ts"
      provides: "renderStackedHeaders method for multi-level rendering"
      contains: "renderStackedHeaders"
    - path: "src/d3/grid-rendering/GridRenderingEngine.ts"
      provides: "Integration with stacked hierarchy detection and rendering"
      contains: "generateStackedHierarchy"
    - path: "src/d3/header-rendering/HeaderProgressiveRenderer.ts"
      provides: "Multi-level SVG rendering with proper alignment"
      contains: "renderMultiLevel"
  key_links:
    - from: "src/d3/grid-rendering/GridRenderingEngine.ts"
      to: "src/services/supergrid/HeaderLayoutService.ts"
      via: "generateStackedHierarchy call"
      pattern: "headerLayoutService.*generateStackedHierarchy"
    - from: "src/d3/SuperGridHeaders.ts"
      to: "src/d3/header-rendering/HeaderProgressiveRenderer.ts"
      via: "progressiveRenderer.renderMultiLevel"
      pattern: "progressiveRenderer.*renderMultiLevel"
---

<objective>
Render stacked headers with visual spanning when PAFV projection has multiple facets per axis.

Purpose: Achieve Excel pivot table style headers where parent cells (e.g., "2024") visually span across their children (e.g., Q1, Q2, Q3, Q4). Users see hierarchical structure at a glance.

Output: Multi-level header rendering integrated with GridRenderingEngine, triggered when axis projection has stacked facets.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/60-supergrid-stacked-headers/60-01-SUMMARY.md

Key files:
@src/d3/SuperGridHeaders.ts — Main orchestrator (add renderStackedHeaders)
@src/d3/grid-rendering/GridRenderingEngine.ts — Integration point with projection
@src/d3/header-rendering/HeaderProgressiveRenderer.ts — Visual rendering
@src/services/supergrid/HeaderLayoutService.ts — Hierarchy generation (from Plan 01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add renderStackedHeaders to SuperGridHeaders</name>
  <files>src/d3/SuperGridHeaders.ts</files>
  <action>
Add new method `renderStackedHeaders()` that renders multi-level hierarchical headers:

```typescript
/**
 * Render stacked (multi-level) headers from hierarchy
 * Used when PAFV axis has multiple facets assigned
 *
 * @param hierarchy - Pre-computed HeaderHierarchy from generateStackedHierarchy
 * @param orientation - 'x' for column headers, 'y' for row headers
 * @param totalWidth - Available width for header rendering
 */
public renderStackedHeaders(
  hierarchy: HeaderHierarchy,
  orientation: 'x' | 'y',
  totalWidth: number
): void {
  superGridLogger.render('Stacked header rendering starting', {
    orientation,
    maxDepth: hierarchy.maxDepth,
    totalNodes: hierarchy.allNodes.length,
    totalWidth
  });

  this.currentHierarchy = hierarchy;

  // Calculate span widths for all nodes
  this.layoutCalculator.calculateHierarchyWidths(hierarchy, totalWidth);

  // Delegate to progressive renderer for multi-level rendering
  this.progressiveRenderer.renderMultiLevel(
    hierarchy,
    orientation,
    {
      levelHeight: this.config.defaultHeaderHeight,
      animationDuration: this.config.progressiveDisclosure.transitionDuration
    }
  );

  // Wire up click handlers for each level
  this.setupStackedHeaderInteractions(hierarchy);

  superGridLogger.render('Stacked header rendering complete', {
    levelsRendered: hierarchy.maxDepth + 1
  });
}

/**
 * Setup click interactions for stacked headers
 * Each level can be clicked for sorting/filtering
 */
private setupStackedHeaderInteractions(hierarchy: HeaderHierarchy): void {
  const headerNodes = this.container.selectAll('.header-node');

  headerNodes.on('click', (event: MouseEvent, d: unknown) => {
    const node = d as HeaderNode;
    if (this.callbacks?.onHeaderClick) {
      this.callbacks.onHeaderClick({
        nodeId: node.id,
        facet: node.facet || '',
        value: node.label,
        level: node.level,
        event
      });
    }
  });
}
```

Update the existing `renderHeaders()` method to detect stacked axes and delegate:

```typescript
public renderHeaders(
  flatData: unknown[],
  axis: string,
  facetFieldOrConfig: string | StackedAxisConfig = 'status',
  totalWidth: number = 800
): void {
  // Check if this is a stacked axis configuration
  if (typeof facetFieldOrConfig === 'object' && 'facets' in facetFieldOrConfig) {
    // Stacked axis - generate multi-level hierarchy
    const stackedHierarchy = this.layoutService.generateStackedHierarchy(
      flatData,
      facetFieldOrConfig
    );
    this.renderStackedHeaders(stackedHierarchy, axis as 'x' | 'y', totalWidth);
    return;
  }

  // Single facet - existing behavior
  // ... existing implementation
}
```
  </action>
  <verify>
```bash
npm run typecheck
grep -n "renderStackedHeaders" src/d3/SuperGridHeaders.ts
```
  </verify>
  <done>SuperGridHeaders has renderStackedHeaders method. renderHeaders detects StackedAxisConfig and delegates to stacked rendering.</done>
</task>

<task type="auto">
  <name>Task 2: Add renderMultiLevel to HeaderProgressiveRenderer</name>
  <files>src/d3/header-rendering/HeaderProgressiveRenderer.ts</files>
  <action>
Add multi-level rendering method that creates stacked header rows with proper alignment and spanning:

```typescript
interface MultiLevelConfig {
  levelHeight: number;
  animationDuration: number;
}

/**
 * Render multi-level headers with visual spanning
 * Creates one row per hierarchy level, with parent cells spanning child widths
 *
 * @param hierarchy - HeaderHierarchy with computed spans and positions
 * @param orientation - 'x' for column headers (horizontal), 'y' for row headers (vertical)
 * @param config - Rendering configuration
 */
public renderMultiLevel(
  hierarchy: HeaderHierarchy,
  orientation: 'x' | 'y',
  config: MultiLevelConfig
): void {
  const { levelHeight, animationDuration } = config;
  const levels = d3.range(0, hierarchy.maxDepth + 1);

  // Get or create header container
  let headerContainer = this.container.select('.stacked-headers') as d3.Selection<SVGGElement, unknown, null, undefined>;
  if (headerContainer.empty()) {
    headerContainer = this.container.append('g')
      .attr('class', 'stacked-headers');
  }

  // Create/update level groups
  const levelGroups = headerContainer
    .selectAll<SVGGElement, number>('.header-level')
    .data(levels, d => d)
    .join(
      enter => enter.append('g')
        .attr('class', 'header-level')
        .attr('data-level', d => d),
      update => update,
      exit => exit.remove()
    );

  // Position level groups based on orientation
  if (orientation === 'x') {
    // Column headers: stack vertically
    levelGroups.attr('transform', d => `translate(0, ${d * levelHeight})`);
  } else {
    // Row headers: conceptually same but for rows
    levelGroups.attr('transform', d => `translate(0, ${d * levelHeight})`);
  }

  // Render nodes within each level
  levels.forEach(level => {
    const nodesAtLevel = hierarchy.allNodes.filter(n => n.level === level);
    const levelGroup = levelGroups.filter((d: number) => d === level);

    this.renderLevelNodes(levelGroup, nodesAtLevel, {
      orientation,
      levelHeight,
      animationDuration
    });
  });

  // Add visual dividers between levels
  this.addLevelDividers(headerContainer, levels.length, levelHeight, orientation);
}

/**
 * Render header nodes within a single level
 */
private renderLevelNodes(
  levelGroup: d3.Selection<SVGGElement, number, SVGGElement, unknown>,
  nodes: HeaderNode[],
  config: { orientation: 'x' | 'y'; levelHeight: number; animationDuration: number }
): void {
  const { orientation, levelHeight, animationDuration } = config;

  const nodeSelection = levelGroup
    .selectAll<SVGGElement, HeaderNode>('.header-node')
    .data(nodes, d => d.id)
    .join(
      enter => enter.append('g')
        .attr('class', 'header-node')
        .attr('data-node-id', d => d.id)
        .attr('opacity', 0)
        .call(g => {
          // Background rect with span width
          g.append('rect')
            .attr('class', 'header-bg')
            .attr('width', d => d.width)
            .attr('height', levelHeight)
            .attr('fill', '#f8fafc')
            .attr('stroke', '#e2e8f0')
            .attr('stroke-width', 1)
            .attr('rx', 2);

          // Label text centered
          g.append('text')
            .attr('class', 'header-label')
            .attr('x', d => d.width / 2)
            .attr('y', levelHeight / 2)
            .attr('text-anchor', 'middle')
            .attr('dominant-baseline', 'middle')
            .attr('font-size', '12px')
            .attr('font-weight', d => d.level === 0 ? '600' : '400')
            .attr('fill', '#334155')
            .text(d => d.label);
        })
        .transition()
        .duration(animationDuration)
        .attr('opacity', 1),

      update => update
        .transition()
        .duration(animationDuration)
        .attr('transform', d => `translate(${d.x}, 0)`),

      exit => exit
        .transition()
        .duration(animationDuration / 2)
        .attr('opacity', 0)
        .remove()
    );

  // Position nodes based on computed x position
  nodeSelection
    .attr('transform', d => `translate(${d.x}, 0)`);
}

/**
 * Add visual dividers between hierarchy levels
 */
private addLevelDividers(
  container: d3.Selection<SVGGElement, unknown, null, undefined>,
  levelCount: number,
  levelHeight: number,
  orientation: 'x' | 'y'
): void {
  const dividerData = d3.range(1, levelCount);

  container
    .selectAll<SVGLineElement, number>('.level-divider')
    .data(dividerData)
    .join('line')
    .attr('class', 'level-divider')
    .attr('x1', 0)
    .attr('x2', orientation === 'x' ? '100%' : levelHeight)
    .attr('y1', d => d * levelHeight)
    .attr('y2', d => d * levelHeight)
    .attr('stroke', '#cbd5e1')
    .attr('stroke-width', 1)
    .attr('stroke-dasharray', '2,2');
}
```
  </action>
  <verify>
```bash
npm run typecheck
grep -n "renderMultiLevel" src/d3/header-rendering/HeaderProgressiveRenderer.ts
```
  </verify>
  <done>HeaderProgressiveRenderer has renderMultiLevel method with D3 enter/update/exit pattern for stacked headers.</done>
</task>

<task type="auto">
  <name>Task 3: Integrate stacked headers with GridRenderingEngine</name>
  <files>src/d3/grid-rendering/GridRenderingEngine.ts</files>
  <action>
Update GridRenderingEngine to detect stacked axis projections and render appropriate headers:

1. Update the `renderProjectionHeaders()` method to check for stacked axes:

```typescript
/**
 * Render headers from projection - supports both single and stacked facets
 */
private renderProjectionHeaders(): void {
  if (!this.currentProjection) return;

  // Check if X-axis has stacked facets
  const xAxisStacked = this.currentProjection.xAxis?.facets?.length > 1;
  const yAxisStacked = this.currentProjection.yAxis?.facets?.length > 1;

  if (xAxisStacked || yAxisStacked) {
    this.renderStackedProjectionHeaders(xAxisStacked, yAxisStacked);
    return;
  }

  // Fall back to existing single-level header rendering
  if (!this.currentHeaders) return;
  // ... existing implementation
}

/**
 * Render stacked (hierarchical) headers for multi-facet axes
 */
private renderStackedProjectionHeaders(
  xAxisStacked: boolean,
  yAxisStacked: boolean
): void {
  if (!this.currentData?.cards || !this.currentProjection) return;

  const headerContainer = this.container.select('.headers');
  headerContainer.selectAll('*').remove();

  // Initialize SuperGridHeaders if needed
  if (!this.superGridHeaders) {
    const headerNode = headerContainer.node() as SVGElement;
    if (headerNode) {
      this.superGridHeaders = new SuperGridHeaders(
        headerNode,
        this.headerLayoutService
      );
    }
  }

  // Render stacked column headers if X-axis has multiple facets
  if (xAxisStacked && this.currentProjection.xAxis?.facets) {
    const stackedConfig: StackedAxisConfig = {
      axis: this.currentProjection.xAxis.axis,
      facets: this.currentProjection.xAxis.facets
    };

    const hierarchy = this.headerLayoutService.generateStackedHierarchy(
      this.currentData.cards,
      stackedConfig
    );

    this.superGridHeaders?.renderStackedHeaders(
      hierarchy,
      'x',
      this.getGridWidth()
    );

    // Update currentHeaders based on leaf nodes for positioning
    this.currentHeaders = {
      columns: hierarchy.allNodes
        .filter(n => n.isLeaf)
        .map(n => n.label),
      rows: this.currentHeaders?.rows || []
    };
  }

  // Render stacked row headers if Y-axis has multiple facets
  if (yAxisStacked && this.currentProjection.yAxis?.facets) {
    const stackedConfig: StackedAxisConfig = {
      axis: this.currentProjection.yAxis.axis,
      facets: this.currentProjection.yAxis.facets
    };

    const hierarchy = this.headerLayoutService.generateStackedHierarchy(
      this.currentData.cards,
      stackedConfig
    );

    this.superGridHeaders?.renderStackedHeaders(
      hierarchy,
      'y',
      this.getGridHeight()
    );

    // Update currentHeaders based on leaf nodes
    this.currentHeaders = {
      columns: this.currentHeaders?.columns || [],
      rows: hierarchy.allNodes
        .filter(n => n.isLeaf)
        .map(n => n.label)
    };
  }

  superGridLogger.debug('Rendered stacked projection headers', {
    xAxisStacked,
    yAxisStacked,
    columns: this.currentHeaders?.columns.length || 0,
    rows: this.currentHeaders?.rows.length || 0
  });
}
```

2. Add import for StackedAxisConfig at top of file:
```typescript
import type { StackedAxisConfig } from '../../types/pafv';
```

3. Update `setProjection()` to handle stacked facets in position computation by using leaf nodes only.
  </action>
  <verify>
```bash
npm run typecheck
grep -n "renderStackedProjectionHeaders" src/d3/grid-rendering/GridRenderingEngine.ts
grep -n "generateStackedHierarchy" src/d3/grid-rendering/GridRenderingEngine.ts
```
  </verify>
  <done>GridRenderingEngine detects stacked axes and delegates to SuperGridHeaders.renderStackedHeaders. Card positions computed from leaf nodes of hierarchy.</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npm run typecheck` passes
2. Stacked rendering wired: grep confirms renderStackedHeaders in SuperGridHeaders
3. Multi-level rendering exists: grep confirms renderMultiLevel in HeaderProgressiveRenderer
4. Integration complete: grep confirms GridRenderingEngine calls generateStackedHierarchy and renderStackedHeaders
5. Manual test: `npm run dev`, navigate to /?test=integrated, assign multiple time facets to Y-axis, observe hierarchical headers
</verification>

<success_criteria>
1. SuperGridHeaders.renderStackedHeaders() renders multi-level hierarchical headers
2. Parent headers visually span across their child headers (width = sum of child widths)
3. HeaderProgressiveRenderer.renderMultiLevel() uses D3 join pattern with enter/update/exit
4. GridRenderingEngine detects stacked axes and triggers appropriate rendering
5. Headers animate smoothly on projection changes
</success_criteria>

<output>
After completion, create `.planning/phases/60-supergrid-stacked-headers/60-02-SUMMARY.md`
</output>
