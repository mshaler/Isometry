---
phase: 14.2-latch-filter-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [
  "src/filters/bridge.ts",
  "native/Sources/Isometry/WebView/DatabaseMessageHandler.swift",
  "native/Sources/Isometry/WebView/FilterBridgeHandler.swift",
  "native/Sources/IsometryAPI/QueryTranslator.swift"
]
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User filter changes in React instantly update native query results"
    - "User text search uses FTS5 for fast full-text search"
    - "User filter state persists in URL and syncs with native database queries"
    - "User can apply complex LATCH filters without performance degradation"
  artifacts:
    - path: "src/filters/bridge.ts"
      provides: "React filter bridge integration"
      min_lines: 80
      exports: ["useBridgeFilters", "FilterBridge"]
    - path: "native/Sources/Isometry/WebView/FilterBridgeHandler.swift"
      provides: "Dedicated native filter message handler"
      min_lines: 120
      exports: ["FilterBridgeHandler", "executeFilter"]
    - path: "native/Sources/Isometry/WebView/DatabaseMessageHandler.swift"
      provides: "Extended database handler with filter support"
      contains: "executeFilter"
    - path: "native/Sources/IsometryAPI/QueryTranslator.swift"
      provides: "LATCH pattern optimization"
      contains: "analyzeLATCHQuery"
  key_links:
    - from: "src/filters/bridge.ts"
      to: "window._isometryBridge.filters"
      via: "WebView message posting"
      pattern: "_isometryBridge\\.filters\\."
    - from: "native/Sources/Isometry/WebView/FilterBridgeHandler.swift"
      to: "QueryTranslator.analyzeLATCHQuery"
      via: "pattern optimization"
      pattern: "QueryTranslator\\.analyzeLATCHQuery"
    - from: "native/Sources/IsometryAPI/QueryTranslator.swift"
      to: "database.searchNodesFTS"
      via: "FTS5 query routing"
      pattern: "searchNodesFTS"
---

<objective>
Bridge React LATCH filtering system to native SQLite database queries with real-time synchronization and performance optimization.

Purpose: Enable instant filter updates from React FilterContext to native database queries, leveraging established WebView bridge infrastructure to provide responsive filtering with FTS5 search integration and URL state persistence.

Output: Complete filter bridge integration allowing React prototype filter UI to control native database queries in real-time with <100ms response latency.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 14.2 research and existing infrastructure
@.planning/phases/14.2-latch-filter-integration/14.2-RESEARCH.md
@.planning/phases/14-pafv-integration/14-01-SUMMARY.md

# Existing filter and bridge infrastructure
@src/filters/compiler.ts
@src/state/FilterContext.tsx
@native/Sources/Isometry/WebView/WebViewBridge.swift
@native/Sources/Isometry/WebView/DatabaseMessageHandler.swift
@native/Sources/IsometryAPI/QueryTranslator.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create React Filter Bridge Integration</name>
  <files>src/filters/bridge.ts</files>
  <action>
    Create comprehensive React filter bridge that connects FilterContext state changes to native database queries via WebView messaging:

    Core FilterBridge class:
    - useBridgeFilters() hook with debounced filter execution (300ms)
    - Bridge availability detection with queue fallback when native unavailable
    - Sequence ID tracking for request/response correlation
    - Performance monitoring with filter execution latency tracking
    - TypeScript integration with strict FilterState and result types

    Implementation details:
    - Use existing compileFilters() from compiler.ts for SQL generation
    - Implement debounced executeFilter with setTimeout pattern from research
    - Add comprehensive error handling with graceful fallback
    - Support pagination (limit: 1000, offset: 0) to prevent oversized results
    - Include bridge statistics (cache hit rates, query patterns)
    - Follow established bridge patterns from PAFV integration (sequence ordering, async/await)

    Integration with FilterContext:
    - Listen to activeFilters changes via useEffect with dependency array
    - Trigger native queries only when filters actually change
    - Maintain loading state during query execution
    - Return { filteredNodes, isLoading } interface for UI consumption

    Avoid manual SQL string building - use existing FilterCompiler.compileFilters() for parameterized queries.
    Avoid synchronous bridge calls - implement async/await pattern with proper error boundaries.
  </action>
  <verify>
    npm run type-check passes with no filter bridge TypeScript errors
    Confirm bridge.ts exports useBridgeFilters hook and FilterBridge class
    Verify debounced execution implementation with 300ms timeout
  </verify>
  <done>React filter bridge created with debounced execution, error handling, and TypeScript integration ready for WebView messaging</done>
</task>

<task type="auto">
  <name>Task 2: Create Native Filter Message Handler</name>
  <files>native/Sources/Isometry/WebView/FilterBridgeHandler.swift</files>
  <action>
    Create dedicated native filter message handler that extends WebView bridge with LATCH filter processing:

    FilterBridgeHandler actor implementation:
    - WKScriptMessageHandler conformance with userContentController method
    - executeFilter message type with comprehensive parameter validation
    - Integration with QueryTranslator for LATCH pattern optimization
    - Async database operations with proper error handling
    - Performance monitoring with query execution timing
    - Result formatting with pagination support

    Core methods:
    - executeFilter(_ message: [String: Any]) async throws -> [String: Any]
    - executeOptimizedFilter(pattern: QueryPattern, params: [Any]) async throws
    - formatFilterResults(_ nodes: [Node]) -> [String: Any]
    - validateFilterParameters(_ message: [String: Any]) throws

    Query optimization integration:
    - Use QueryTranslator.analyzeLATCHQuery for pattern recognition
    - Route FTS5 queries to database.searchNodesFTS for text search
    - Route spatial queries to database.searchNodesSpatial for location filtering
    - Route folder queries to database.getNodesByFolder for hierarchy filtering
    - Fallback to raw SQL execution with QueryTranslator.translateSQL

    Error handling:
    - BridgeError.missingParameters for invalid message format
    - BridgeError.invalidParameterType for type validation failures
    - BridgeError.queryExecutionFailed for database operation errors
    - Comprehensive logging with query performance metrics

    Follow actor isolation patterns from existing handlers - use @MainActor where needed for UI updates.
    Avoid raw SQL execution without validation - always use parameterized queries and QueryTranslator.
  </action>
  <verify>
    Swift build passes with FilterBridgeHandler implementing WKScriptMessageHandler
    Confirm executeFilter method returns properly formatted results dictionary
    Verify QueryTranslator integration for LATCH pattern optimization
  </verify>
  <done>Native FilterBridgeHandler created with LATCH optimization, error handling, and async database integration</done>
</task>

<task type="auto">
  <name>Task 3: Extend Database Handler and Query Translator</name>
  <files>
    native/Sources/Isometry/WebView/DatabaseMessageHandler.swift
    native/Sources/IsometryAPI/QueryTranslator.swift
  </files>
  <action>
    Extend existing database handler and query translator with LATCH filter optimization:

    DatabaseMessageHandler extensions:
    - Add executeFilter method to existing handler for backward compatibility
    - Integrate FilterBridgeHandler as filterHandler property
    - Update bridgeInitializationScript to include filters namespace
    - Add filter-specific error handling and result formatting
    - Maintain consistency with existing database method patterns

    QueryTranslator LATCH enhancements:
    - Add analyzeLATCHQuery method for specialized filter pattern recognition
    - Recognize FTS5 search patterns (WHERE content MATCH ?) and route to searchNodesFTS
    - Recognize spatial queries (lat/lng bounds) and route to searchNodesSpatial
    - Recognize folder hierarchy patterns and route to getNodesByFolder
    - Recognize time-based filtering patterns for chronological queries
    - Add LATCH-specific query caching with pattern-based cache keys

    Performance optimization:
    - Cache frequent LATCH filter patterns for <5ms response
    - Implement bounding box approximation for spatial queries (100x faster than exact distance)
    - Use FTS5 virtual tables for alphabet (text search) filtering
    - Optimize compound LATCH conditions with composite indexes where available

    Integration points:
    - Connect to WebViewBridge.filterHandler initialization
    - Add "filters" namespace to bridge JavaScript initialization
    - Ensure proper async/await patterns for Swift 6 compliance
    - Maintain thread safety with actor isolation

    Avoid breaking existing database handler patterns - extend rather than replace.
    Avoid bypassing FTS5 for text search - always route MATCH queries to virtual tables.
  </action>
  <verify>
    Swift build passes with extended DatabaseMessageHandler and QueryTranslator
    Confirm analyzeLATCHQuery method recognizes FTS5, spatial, and folder patterns
    Verify bridge JavaScript includes filters namespace with proper method bindings
  </verify>
  <done>Database handler and query translator extended with LATCH optimization and proper bridge integration</done>
</task>

</tasks>

<verification>
Real-time filter synchronization test:
1. Start React prototype with native bridge available
2. Apply Location filter in React FilterContext
3. Verify native database query executes within 100ms
4. Apply text search (Alphabet filter) and confirm FTS5 query routing
5. Validate URL state persistence works with bridge integration
6. Test complex multi-filter scenarios with Category + Time combinations
</verification>

<success_criteria>
- React filter changes trigger native database queries within 100ms latency
- FTS5 text search integration works for Alphabet filtering with 10-100x performance improvement
- Complex LATCH filter combinations execute without UI blocking
- Filter state synchronization maintains consistency between React URL persistence and native query execution
- Bridge integration handles error cases gracefully with user feedback
- Performance monitoring shows <5ms for cached filter patterns and <100ms for complex queries
</success_criteria>

<output>
After completion, create `.planning/phases/14.2-latch-filter-integration/14.2-01-SUMMARY.md` with:
- Filter bridge integration architecture
- LATCH pattern optimization results
- Performance benchmarks (query latency, cache hit rates)
- Integration points with existing WebView bridge infrastructure
</output>