---
phase: 14.2-latch-filter-integration
plan: 02
type: execute
wave: 2
depends_on: ["14.2-01"]
files_modified: [
  "src/state/FilterContext.tsx",
  "src/hooks/useBridgeDatabase.ts",
  "native/Sources/Isometry/WebView/WebViewBridge.swift",
  "src/utils/filter-serialization.ts"
]
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User filter state changes automatically sync between React and native systems"
    - "User can switch between sql.js and native backend without losing filter state"
    - "User filter URL persistence works seamlessly with native bridge integration"
    - "User experiences no race conditions during rapid filter changes"
  artifacts:
    - path: "src/state/FilterContext.tsx"
      provides: "Bridge-aware filter context"
      contains: "useBridgeFilters"
      min_lines: 200
    - path: "src/hooks/useBridgeDatabase.ts"
      provides: "Unified database abstraction"
      exports: ["useBridgeDatabase", "DatabaseProvider"]
      min_lines: 100
    - path: "native/Sources/Isometry/WebView/WebViewBridge.swift"
      provides: "Filter handler registration"
      contains: "filterHandler"
    - path: "src/utils/filter-serialization.ts"
      provides: "Enhanced filter serialization with bridge support"
      contains: "bridgeCompatibleSerialization"
  key_links:
    - from: "src/state/FilterContext.tsx"
      to: "useBridgeFilters"
      via: "conditional hook usage"
      pattern: "useBridgeFilters\\("
    - from: "src/hooks/useBridgeDatabase.ts"
      to: "window._isometryBridge.database"
      via: "bridge availability detection"
      pattern: "_isometryBridge.*available"
    - from: "native/Sources/Isometry/WebView/WebViewBridge.swift"
      to: "FilterBridgeHandler"
      via: "message handler registration"
      pattern: "addScriptMessageHandler.*filters"
---

<objective>
Integrate filter bridge with existing React FilterContext and database abstraction layer for seamless backend switching and state management.

Purpose: Create unified filter experience that works consistently across sql.js and native backends, with automatic bridge detection, race condition prevention, and URL state synchronization.

Output: Complete filter integration that allows users to switch between prototype and native backends without losing functionality or experiencing state inconsistencies.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 14.2 research and previous plan
@.planning/phases/14.2-latch-filter-integration/14.2-RESEARCH.md
@.planning/phases/14.2-latch-filter-integration/14.2-01-PLAN.md

# Existing filter and database infrastructure
@src/state/FilterContext.tsx
@src/hooks/useSQLiteQuery.ts
@src/utils/filter-serialization.ts
@src/db/DatabaseContext.tsx
@native/Sources/Isometry/WebView/WebViewBridge.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance FilterContext with Bridge Integration</name>
  <files>src/state/FilterContext.tsx</files>
  <action>
    Enhance existing FilterContext to integrate with filter bridge while maintaining backward compatibility:

    Bridge integration additions:
    - Import and conditionally use useBridgeFilters hook from bridge.ts
    - Add bridge availability detection using window._isometryBridge existence check
    - Implement bridgeMode state for tracking active database backend
    - Add sequence ID management for race condition prevention during rapid filter changes
    - Integrate with existing URL state persistence via useURLState hook

    Race condition prevention:
    - Implement debounced filter application with 300ms timeout (consistent with bridge.ts)
    - Add sequence numbering to filter requests to handle out-of-order responses
    - Cancel pending requests when new filter changes occur
    - Maintain filter state consistency between URL, local state, and bridge results

    Backend switching logic:
    - Detect bridge availability on context initialization
    - Fall back gracefully to sql.js when bridge unavailable
    - Maintain filter state continuity during backend switches
    - Preserve URL synchronization regardless of backend

    Enhanced FilterContext provider:
    - Add bridgeResults state for native query results
    - Maintain compatibility with existing sql.js integration
    - Provide unified filtering interface for components
    - Export bridge availability status for UI feedback

    State management integration:
    - Extend existing filterReducer with bridge-specific actions
    - Add BRIDGE_RESULTS_RECEIVED action type
    - Add BRIDGE_MODE_CHANGED action type
    - Maintain existing filter actions for backward compatibility

    Avoid breaking existing FilterContext API - extend rather than replace.
    Avoid synchronous bridge operations - use established debounced async patterns.
  </action>
  <verify>
    npm run type-check passes with enhanced FilterContext
    Confirm bridge availability detection works when window._isometryBridge exists
    Verify existing filter UI components continue working without modification
  </verify>
  <done>FilterContext enhanced with bridge integration while maintaining full backward compatibility with sql.js</done>
</task>

<task type="auto">
  <name>Task 2: Create Unified Database Abstraction Hook</name>
  <files>src/hooks/useBridgeDatabase.ts</files>
  <action>
    Create unified database abstraction that provides consistent interface for both sql.js and native bridge backends:

    useBridgeDatabase hook implementation:
    - Detect bridge availability using window._isometryBridge presence
    - Provide unified query execution interface for both backends
    - Handle backend switching with state preservation
    - Implement proper TypeScript types for cross-backend compatibility
    - Add performance monitoring and statistics collection

    Backend detection and switching:
    - useEffect for bridge availability monitoring
    - Graceful fallback to sql.js when bridge becomes unavailable
    - State migration between backends when switching occurs
    - Maintain query result consistency across backend changes

    Query execution abstraction:
    - executeQuery(sql, params) method works with both backends
    - searchNodes(query) method routes to FTS5 on both backends
    - getFilteredNodes(filters) method uses appropriate filtering approach
    - Return consistent result format regardless of backend

    DatabaseProvider component:
    - Context provider that wraps application with unified database access
    - Manages backend switching and availability monitoring
    - Provides database instance and configuration to child components
    - Handles initialization of both sql.js and bridge connections

    Performance and monitoring:
    - Track query execution times for both backends
    - Monitor backend switching frequency and reasons
    - Provide statistics for debugging and optimization
    - Export performance data for development analysis

    Integration with existing patterns:
    - Compatible with useSQLiteQuery hook patterns
    - Works with existing DatabaseContext infrastructure
    - Maintains consistency with established query result formats
    - Preserves existing error handling patterns

    Avoid duplicating sql.js query logic - delegate to existing useSQLiteQuery when appropriate.
    Avoid bridge-specific assumptions - maintain backend agnostic interface design.
  </action>
  <verify>
    npm run type-check passes with useBridgeDatabase hook
    Confirm consistent query interface works with both sql.js and bridge backends
    Verify DatabaseProvider initializes correctly and detects bridge availability
  </verify>
  <done>Unified database abstraction created with seamless backend switching and consistent query interface</done>
</task>

<task type="auto">
  <name>Task 3: Complete WebView Bridge Registration and Filter Serialization</name>
  <files>
    native/Sources/Isometry/WebView/WebViewBridge.swift
    src/utils/filter-serialization.ts
  </files>
  <action>
    Complete WebView bridge integration and enhance filter serialization for bridge compatibility:

    WebViewBridge filter handler registration:
    - Add FilterBridgeHandler as filterHandler property alongside existing handlers
    - Register "filters" message handler in setupMessageHandlers method
    - Update bridgeInitializationScript to include filters namespace
    - Add filter-specific JavaScript bridge methods (executeFilter, getFilterStatus)
    - Ensure proper handler lifecycle management with database connection

    Bridge JavaScript interface additions:
    - filters.executeFilter(sql, params) async method
    - filters.getFilterStatistics() for performance monitoring
    - filters.cancelPendingRequests() for race condition prevention
    - Consistent error handling with existing database and pafv namespaces

    Filter serialization enhancements:
    - Add bridgeCompatibleSerialization function for optimized bridge message size
    - Implement filter state compression for URL length limits
    - Add validation for bridge message size constraints (5MB limit)
    - Create bridge-specific parameter serialization with type safety

    Enhanced serialization features:
    - Optimize FTS5 query parameters for bridge transmission
    - Compress spatial filter bounds for efficient messaging
    - Handle complex filter combinations with size optimization
    - Add validation for serialization/deserialization round-trip consistency

    Swift bridge registration:
    - Initialize FilterBridgeHandler with database reference
    - Proper error handling for handler registration failures
    - Integration with existing WebView configuration
    - Maintain consistency with PAFV and database handler patterns

    Error boundary integration:
    - Comprehensive error handling for filter message failures
    - Graceful fallback when filter handler initialization fails
    - User-friendly error reporting for bridge communication issues
    - Maintain application stability during bridge initialization problems

    Avoid modifying core bridge initialization patterns - follow established handler registration approach.
    Avoid breaking existing database/PAFV bridge functionality - add filter support as extension.
  </action>
  <verify>
    Swift build passes with FilterBridgeHandler registered in WebViewBridge
    Confirm bridge JavaScript includes filters namespace with proper method bindings
    Verify filter serialization handles bridge message size constraints
  </verify>
  <done>WebView bridge registration complete with filter handler and enhanced serialization for bridge optimization</done>
</task>

</tasks>

<verification>
End-to-end filter integration test:
1. Load React prototype in native WebView with bridge available
2. Verify automatic bridge detection and initialization
3. Apply various LATCH filters and confirm real-time synchronization
4. Test backend switching by toggling bridge availability
5. Validate URL state persistence works across backend switches
6. Verify no race conditions during rapid filter changes
7. Test filter serialization with complex multi-filter combinations
</verification>

<success_criteria>
- Seamless backend switching between sql.js and native bridge without filter state loss
- Real-time filter synchronization with <100ms latency for bridge operations
- URL state persistence works consistently across both backends
- Race condition prevention during rapid filter changes with sequence ordering
- Filter serialization optimization keeps bridge messages under size limits
- Unified database interface provides consistent API regardless of backend
- Existing filter UI components work without modification
</success_criteria>

<output>
After completion, create `.planning/phases/14.2-latch-filter-integration/14.2-02-SUMMARY.md` with:
- Backend switching architecture and implementation details
- Race condition prevention mechanisms and sequence ordering
- Filter serialization optimization results and size constraints
- Unified database abstraction interface and usage patterns
</output>