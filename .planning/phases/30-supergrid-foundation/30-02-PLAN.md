---
phase: 30-supergrid-foundation
subphase: 30-02
title: "Header Architecture Foundation"
status: ready
estimated_duration: "4-5 days"
dependencies: ["30-01"]
verification: true
---

# Phase 30.2: SuperGrid Header Architecture Foundation

**Goal:** Establish recursive header component system and basic spanning calculation algorithms for hierarchical data display.

**Estimated Duration:** 4-5 days
**Status:** Ready to Start (depends on 30-01 completion)
**Dependencies:** Phase 30-01 (Core Architecture Setup)

## Observable Truths (Verification Criteria)

1. **Recursive header component renders multi-level hierarchies correctly**
   - Headers display at least 3 levels deep (Quarter > Month > Week)
   - Parent headers visually span their children
   - Hierarchy depth is configurable and unlimited
   - Component recursion doesn't create performance issues

2. **Spanning calculation algorithm accurately determines visual layout**
   - Parent headers calculate correct width based on children
   - Proportional sizing maintained during data changes
   - Empty categories handled gracefully (no visual artifacts)
   - Calculations perform efficiently with 100+ header combinations

3. **Header-to-data coordination maintains consistency**
   - Header structure reflects actual data hierarchy
   - Data changes trigger appropriate header re-calculation
   - Selection state synchronized between headers and data cells
   - Hover/focus states propagate correctly through hierarchy

4. **Row and column header quadrants function independently**
   - Row headers support different hierarchy than columns
   - Quadrant resize operations don't break spanning
   - Independent scroll behavior when content exceeds bounds
   - Cross-quadrant selection coordination works correctly

5. **Foundation supports future drag-and-drop requirements**
   - Headers have clear drag affordances in visual design
   - Component structure supports adding drag handlers
   - Hierarchy modifications don't break visual layout
   - Performance remains acceptable during layout recalculation

## Required Artifacts

### Core Header Components
- `src/components/supergrid/PAFVHeader.tsx` - Recursive hierarchical header component
- `src/components/supergrid/HeaderGroup.tsx` - Container for grouped headers at each level
- `src/components/supergrid/RowHeadersQuadrant.tsx` - Row hierarchy display quadrant
- `src/components/supergrid/ColumnHeadersQuadrant.tsx` - Column hierarchy display quadrant

### Spanning Algorithm
- `src/utils/header-spanning.ts` - Hierarchical spanning calculations
- `src/utils/hierarchy-builder.ts` - Convert flat data to hierarchical structure
- `src/hooks/useHeaderSpanning.ts` - React hook for span calculation management

### Data Integration
- `src/hooks/useSupergridHierarchy.ts` - Extract hierarchy from PAFV mappings
- `src/types/header-hierarchy.ts` - Type definitions for hierarchical structures

## Detailed Implementation Plan

### Day 1-2: Recursive Header Component

**PAFVHeader.tsx**
```typescript
interface PAFVHeaderProps {
  axis: LATCHAxis;
  facetPath: string;
  depth: number;
  maxDepth: number;
  children?: ReactNode;
  span?: number;
  onResize?: (newSize: number) => void;
  onSelect?: (facetPath: string, depth: number) => void;
}

export function PAFVHeader({
  axis,
  facetPath,
  depth,
  maxDepth,
  children,
  span = 1,
  onResize,
  onSelect
}: PAFVHeaderProps) {
  // Recursive rendering logic
  // Spanning calculation integration
  // Event handling for future drag-and-drop
  // Accessibility support
}
```

**HeaderGroup.tsx**
```typescript
interface HeaderGroupProps {
  headers: HeaderData[];
  orientation: 'row' | 'column';
  depth: number;
  totalDepth: number;
  onHeaderSelect?: (header: HeaderData) => void;
}
```

### Day 2-3: Spanning Algorithm Implementation

**header-spanning.ts**
```typescript
interface SpanCalculation {
  facetPath: string;
  span: number;
  children: SpanCalculation[];
  totalSize: number;
}

export class HeaderSpanningCalculator {
  calculateSpans(hierarchy: HierarchyNode[], availableSize: number): SpanCalculation[];
  updateSpansForDataChange(
    currentSpans: SpanCalculation[],
    newData: Node[]
  ): SpanCalculation[];

  // Performance optimization
  getCachedSpans(hierarchySignature: string): SpanCalculation[] | null;
  invalidateSpanCache(): void;
}
```

**useHeaderSpanning.ts**
```typescript
interface HeaderSpanningHook {
  spans: SpanCalculation[];
  isCalculating: boolean;
  updateHierarchy: (newHierarchy: HierarchyNode[]) => void;
  recalculateSpans: () => void;

  // Performance metrics
  lastCalculationTime: number;
  spanCacheHits: number;
}
```

### Day 3-4: Quadrant Implementation

**RowHeadersQuadrant.tsx**
```typescript
interface RowHeadersQuadrantProps {
  hierarchyData: HierarchyNode[];
  width: number;
  height: number;
  onHeaderSelect?: (facetPath: string, depth: number) => void;
  onResize?: (newWidth: number) => void;
}

export function RowHeadersQuadrant({
  hierarchyData,
  width,
  height,
  onHeaderSelect,
  onResize
}: RowHeadersQuadrantProps) {
  // Vertical header layout
  // Scroll behavior for overflow
  // Selection state management
  // Resize handle for quadrant width
}
```

**ColumnHeadersQuadrant.tsx**
```typescript
interface ColumnHeadersQuadrantProps {
  hierarchyData: HierarchyNode[];
  width: number;
  height: number;
  onHeaderSelect?: (facetPath: string, depth: number) => void;
  onResize?: (newHeight: number) => void;
}
```

### Day 4-5: Data Integration & Testing

**useSupergridHierarchy.ts**
```typescript
interface SupergridHierarchy {
  rowHierarchy: HierarchyNode[];
  columnHierarchy: HierarchyNode[];
  maxRowDepth: number;
  maxColumnDepth: number;

  // Data synchronization
  rebuildFromData: (data: Node[], mappings: PAFVMapping[]) => void;
  updateForMappingChange: (newMapping: PAFVMapping) => void;

  // Performance tracking
  lastRebuildTime: number;
  hierarchyComplexity: number;
}
```

## Testing Strategy

### Unit Tests
- Spanning calculation accuracy with various hierarchy depths
- Recursive component rendering without infinite loops
- Performance benchmarks for span calculation algorithms
- Edge cases: empty hierarchies, single-level data

### Integration Tests
- Header quadrant interaction with data quadrant
- PAFV mapping changes reflect in header structure
- Selection state coordination across quadrants
- Resize behavior maintains layout integrity

### Visual Regression Tests
- Header spanning visual accuracy
- Hierarchy depth visual validation
- Responsive behavior across screen sizes
- Accessibility focus navigation

## Performance Requirements

### Calculation Performance
- Span calculation for 100 headers: < 50ms
- Hierarchy rebuild for 1000 nodes: < 200ms
- Component render time: < 100ms for typical hierarchies

### Memory Efficiency
- Span calculation caching reduces redundant calculations
- Component tree depth optimized for large hierarchies
- Memory usage linear with actual data complexity

## Key Risks & Mitigations

### Risk: Recursive component performance
**Mitigation:** Implement memoization and render optimization, limit default depth

### Risk: Complex spanning calculations
**Mitigation:** Comprehensive unit tests, performance monitoring, fallback to simple layout

### Risk: Cross-quadrant coordination complexity
**Mitigation:** Clear event contracts, centralized state management, incremental testing

## Integration Points

### PAFV Context Integration
- Consume axis mappings to determine hierarchy structure
- React to mapping changes with hierarchy rebuilds
- Maintain consistent facet path format

### Data Layer Integration
- Build hierarchy from filtered node data
- Handle real-time data updates efficiently
- Support sparse data scenarios

### UI Framework Integration
- Follow established Tailwind CSS patterns
- Maintain theme system compatibility
- Support accessibility requirements

## Success Criteria

✅ **Hierarchical Display**
- Multi-level headers render correctly
- Spanning calculations produce accurate visual layout
- Performance acceptable for reasonable data sizes

✅ **Component Architecture**
- Recursive pattern established and tested
- Clean separation between row and column quadrants
- Future drag-and-drop support architecturally ready

✅ **Data Integration**
- Headers reflect actual data hierarchy
- Real-time updates work smoothly
- Edge cases handled gracefully

## Next Phase Preview

Phase 30.3 will focus on data integration, connecting the SQLite data layer with the established grid architecture. This will include node-to-cell mapping logic, basic aggregation support, and establishing performance baselines for the complete data flow.

---

_Plan created: 2026-01-31_
_Dependencies: 30-01 completion_
_Phase template: GSD with verification_