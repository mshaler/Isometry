---
phase: 39-missing-requirement-implementation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/d3/SuperGridHeaders.ts
  - src/hooks/useDatabaseService.ts
  - src/types/grid.ts
autonomous: true

must_haves:
  truths:
    - "User can hover near column borders and see resize cursor"
    - "User can drag column borders to resize columns"
    - "User can resize columns while maintaining 60fps performance"
    - "Column widths persist across sessions and view transitions"
    - "Resize handles integrate seamlessly with existing header interactions"
  artifacts:
    - path: "src/d3/SuperGridHeaders.ts"
      provides: "Column resize drag behavior with edge detection and RAF optimization"
      contains: "handleResizeStart|handleResizeDrag|handleResizeEnd"
    - path: "src/hooks/useDatabaseService.ts"
      provides: "Column width state persistence methods"
      exports: ["saveColumnWidths", "loadColumnWidths"]
    - path: "src/types/grid.ts"
      provides: "TypeScript interfaces for resize events and column state"
      contains: "ColumnResizeEvent|ColumnWidthState"
  key_links:
    - from: "SuperGridHeaders resize handlers"
      to: "useDatabaseService.saveColumnWidths"
      via: "debounced state persistence on resize end"
      pattern: "database\\.saveColumnWidths"
    - from: "SuperGridHeaders mouse events"
      to: "d3-drag behavior"
      via: "edge detection filter and RAF updates"
      pattern: "d3\\.drag.*\\.filter.*isResizeZone"
---

<objective>
Implement FOUND-06 requirement for column resizing with drag handles and state persistence in SuperGrid system.

Purpose: Enable users to resize columns by dragging handles on column borders with smooth 60fps performance and session persistence, completing the missing foundation requirement for v4.1 milestone closure.
Output: Column resize functionality integrated into existing SuperGrid architecture with zero-serialization state persistence.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/39-missing-requirement-implementation/39-RESEARCH.md
@src/d3/SuperGridHeaders.ts
@src/d3/SuperGrid.ts
@src/hooks/useDatabaseService.ts
@src/types/grid.ts
</context>

<tasks>

<task type="auto">
  <name>Add Column Resize Types and Interfaces</name>
  <files>src/types/grid.ts</files>
  <action>
    Add TypeScript interfaces for column resize functionality:

    1. ColumnResizeEvent interface:
       - nodeId: string (header node being resized)
       - originalWidth: number (width before resize)
       - newWidth: number (width after resize)
       - event: MouseEvent (original drag event)

    2. ColumnWidthState interface:
       - datasetId: string
       - appContext: string
       - columnWidths: Record<string, number>
       - lastUpdated: string

    3. ResizeHandleConfig interface:
       - edgeDetectionZone: number (default 4px)
       - minColumnWidth: number (default 50px)
       - animationDuration: number (default 0 for RAF)

    Extend existing HeaderNode interface to include:
    - originalWidth?: number (for drag calculations)
    - isResizing?: boolean (visual state flag)

    Follow existing grid.ts patterns and TypeScript strict mode requirements.
  </action>
  <verify>npm run typecheck passes with new interfaces</verify>
  <done>ColumnResizeEvent, ColumnWidthState, ResizeHandleConfig interfaces exist and HeaderNode extended</done>
</task>

<task type="auto">
  <name>Extend Database Service with Column Width Persistence</name>
  <files>src/hooks/useDatabaseService.ts</files>
  <action>
    Add column width persistence methods following existing saveHeaderState/loadHeaderState pattern:

    1. saveColumnWidths method:
       - Parameters: (datasetId: string, appContext: string, widths: Record<string, number>)
       - Create column_widths table if not exists with columns: dataset_id, app_context, column_id, width, last_updated
       - Clear existing widths for dataset/context, insert new widths
       - Use transaction pattern for atomic updates
       - Return { success: boolean, error?: string }

    2. loadColumnWidths method:
       - Parameters: (datasetId: string, appContext: string)
       - Query column_widths table for dataset/context
       - Return Record<string, number> mapping column IDs to widths
       - Return null if no saved state exists
       - Handle JSON parsing errors gracefully

    Follow existing database service patterns:
    - Use run() for mutations, execute() for queries
    - Proper error handling with try/catch
    - SQLite upsert patterns (INSERT OR REPLACE)
    - Consistent parameter binding with ? placeholders
  </action>
  <verify>Database methods exist and return correct types</verify>
  <done>saveColumnWidths and loadColumnWidths methods implemented in useDatabaseService</done>
</task>

<task type="auto">
  <name>Implement Column Resize Behavior in SuperGridHeaders</name>
  <files>src/d3/SuperGridHeaders.ts</files>
  <action>
    Add column resize functionality to SuperGridHeaders class:

    1. Add resize state properties:
       - private resizeBehavior: d3.DragBehavior | null = null
       - private animationFrameId: number | null = null
       - private pendingResizeUpdate: {nodeId: string, newWidth: number} | null = null
       - private saveStateDebounceTimer: NodeJS.Timeout | null = null

    2. Initialize resize behavior in constructor:
       - Create d3.drag behavior with .filter() for edge detection
       - Bind start/drag/end handlers
       - Apply to header selections after rendering

    3. Add edge detection method isResizeZone():
       - Check if mouse X position is within 4px of right edge
       - Return boolean for drag behavior filter
       - Calculate based on node.width and event.sourceEvent.offsetX

    4. Implement resize handlers:
       - handleResizeStart: Store original width, set cursor, prevent other interactions
       - handleResizeDrag: Use RAF pattern to batch DOM updates, enforce minWidth (50px)
       - handleResizeEnd: Persist state with debouncing, cleanup visual state

    5. Add cursor state management:
       - mousemove handler for hover detection
       - Set cursor: 'col-resize' when in resize zone
       - Reset cursor on mouseleave
       - Integrate with existing click handlers

    6. State persistence integration:
       - Call database.saveColumnWidths in debounced resize end handler
       - Load column widths during initialization if available
       - Apply saved widths during header rendering

    Use existing patterns from SuperGrid.ts drag behavior and SuperGridHeaders.saveHeaderState().
    Maintain 60fps performance using requestAnimationFrame batching.
  </action>
  <verify>Column resize drag behavior works with visual feedback and cursor changes</verify>
  <done>Column resizing implemented with drag handles, RAF optimization, and state persistence</done>
</task>

</tasks>

<verification>
1. User can hover near column borders and see resize cursor change
2. User can drag column borders with smooth visual feedback
3. Columns resize immediately with 60fps performance maintained
4. Column widths persist after browser refresh
5. Resize behavior integrates with existing header interactions (expand/collapse, selection)
6. TypeScript compilation passes with zero errors
7. Database methods successfully save and load column width state
</verification>

<success_criteria>
- FOUND-06 requirement fully implemented and verifiable
- User can resize any column by dragging right edge with col-resize cursor
- Column widths persist across sessions via sql.js database storage
- Performance remains at 60fps during resize operations using RAF optimization
- Integration seamlessly works with existing SuperGrid architecture
- Zero breaking changes to existing header functionality
</success_criteria>

<output>
After completion, create `.planning/phases/39-missing-requirement-implementation/39-01-SUMMARY.md`
</output>