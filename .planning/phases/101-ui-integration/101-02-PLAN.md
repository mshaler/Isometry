---
phase: 101-ui-integration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/LATCHFilter.tsx
  - src/services/property-classifier.ts
autonomous: true

must_haves:
  truths:
    - "LATCHFilter priority range discovered from actual data via MIN/MAX query"
    - "Property classifier handles all numeric columns without hardcoded defaults dict"
    - "Missing columns return false gracefully without crashes"
    - "Default priority range [1, 10] used when no data exists"
  artifacts:
    - path: "src/components/LATCHFilter.tsx"
      provides: "Dynamic priority range discovery with useSQLiteQuery"
      min_lines: 280
    - path: "src/services/property-classifier.ts"
      provides: "Generic numeric column handling without hardcoded defaults"
      min_lines: 350
  key_links:
    - from: "src/components/LATCHFilter.tsx"
      to: "src/hooks/database/useSQLiteQuery.ts"
      via: "useSQLiteQuery hook for priority MIN/MAX"
      pattern: "useSQLiteQuery.*MIN.*MAX.*priority"
    - from: "src/services/property-classifier.ts"
      to: "sql.js Database"
      via: "try-catch for missing columns"
      pattern: "try.*catch.*return false"
---

<objective>
Replace hardcoded priority range [1, 10] in LATCHFilter and remove hardcoded numericColumnsWithDefaults from property-classifier.

Purpose: Eliminate hardcoded LATCH values (UI-04, CLASSIFY-01, CLASSIFY-02, CLASSIFY-03) so filters reflect actual data ranges.

Output: Updated LATCHFilter.tsx with dynamic priority discovery, updated property-classifier.ts with generic numeric handling.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/101-ui-integration/101-RESEARCH.md
@src/components/LATCHFilter.tsx
@src/services/property-classifier.ts
@src/hooks/data/useFacetAggregates.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Discover priority range from actual data in LATCHFilter</name>
  <files>src/components/LATCHFilter.tsx</files>
  <action>
Replace hardcoded priority range with data-driven discovery.

Add import at top of file:
```typescript
import { useSQLiteQuery } from '@/hooks/database/useSQLiteQuery';
```

Add new query hook after existing hooks (around line 47):
```typescript
// Discover actual priority range from data
const { data: priorityStats } = useSQLiteQuery<{ min: number; max: number }>(
  `SELECT
     COALESCE(MIN(priority), 1) as min,
     COALESCE(MAX(priority), 10) as max
   FROM nodes
   WHERE priority IS NOT NULL AND deleted_at IS NULL`,
  [],
  { enabled: axis === 'hierarchy' }
);
```

Update the priorityRange state initialization to use discovered values:
```typescript
// Use discovered range or sensible defaults
const discoveredMin = priorityStats?.min ?? 1;
const discoveredMax = priorityStats?.max ?? 10;

// Priority range state - initialized from discovered values
const [priorityRange, setPriorityRange] = useState<[number, number]>([1, 10]);

// Sync state with discovered values when data arrives
React.useEffect(() => {
  if (priorityStats) {
    setPriorityRange([priorityStats.min, priorityStats.max]);
  }
}, [priorityStats]);
```

Add React import if not already present (check line 1).

Update the default check at lines 239 and 274 to use discovered range:
- Line 239: Change `priorityRange[0] === 1 && priorityRange[1] === 10` to `priorityRange[0] === discoveredMin && priorityRange[1] === discoveredMax`
- Line 274: Same change

This ensures the "no filter" state is based on actual data range, not hardcoded [1, 10].
  </action>
  <verify>
Run `npm run typecheck` - should pass.
Open LATCHFilter for hierarchy axis, verify priority slider shows range from actual data.
If data has priorities 1-3, slider should show 1-3 not 1-10.
  </verify>
  <done>Priority range slider reflects actual MIN/MAX from database</done>
</task>

<task type="auto">
  <name>Task 2: Remove hardcoded numericColumnsWithDefaults from property-classifier</name>
  <files>src/services/property-classifier.ts</files>
  <action>
Replace the hardcoded numericColumnsWithDefaults object with generic numeric handling.

Remove lines 103-108:
```typescript
// DELETE THIS:
const numericColumnsWithDefaults: Record<string, number> = {
  priority: 0,
  importance: 0,
  sort_order: 0,
};
```

Replace the columnHasData function body (lines 96-150) with generic implementation:

```typescript
function columnHasData(db: Database, sourceColumn: string): boolean {
  // Skip columns that are always present and useful
  const alwaysPresentColumns = ['name', 'created_at', 'modified_at', 'folder', 'tags'];
  if (alwaysPresentColumns.includes(sourceColumn)) {
    return true;
  }

  try {
    // Generic approach: check for meaningful variation in ANY column
    // Try numeric check first (most numeric columns default to 0)
    const numericSql = `
      SELECT COUNT(DISTINCT ${sourceColumn}) as cnt FROM nodes
      WHERE ${sourceColumn} IS NOT NULL
        AND ${sourceColumn} != 0
        AND deleted_at IS NULL
    `;
    const numericResult = db.exec(numericSql);
    const numericCount = numericResult.length > 0 && numericResult[0].values.length > 0
      ? Number(numericResult[0].values[0][0])
      : 0;

    if (numericCount >= 2) {
      console.log(`[PropertyClassifier] columnHasData("${sourceColumn}"): true (${numericCount} distinct numeric values)`);
      return true;
    }

    // Fall back to text check (handles both text and numeric as strings)
    const textSql = `
      SELECT COUNT(DISTINCT ${sourceColumn}) as cnt FROM nodes
      WHERE ${sourceColumn} IS NOT NULL
        AND TRIM(CAST(${sourceColumn} AS TEXT)) != ''
        AND deleted_at IS NULL
    `;
    const textResult = db.exec(textSql);
    const textCount = textResult.length > 0 && textResult[0].values.length > 0
      ? Number(textResult[0].values[0][0])
      : 0;

    const hasData = textCount >= 2;
    console.log(`[PropertyClassifier] columnHasData("${sourceColumn}"): ${hasData} (${textCount} distinct values)`);
    return hasData;
  } catch (error) {
    // Column doesn't exist, wrong type, or other SQL error
    // This is NORMAL for schema-on-read - gracefully return false (CLASSIFY-03)
    console.log(`[PropertyClassifier] columnHasData("${sourceColumn}"): false (error: ${error})`);
    return false;
  }
}
```

This satisfies:
- CLASSIFY-01: columnHasData handles all numeric columns without hardcoded defaults
- CLASSIFY-02: numericColumnsWithDefaults object removed
- CLASSIFY-03: Missing columns return false gracefully via try-catch
  </action>
  <verify>
Run `npm run typecheck` - should pass.
Grep for "numericColumnsWithDefaults" - should find 0 matches.
Run `npm run test -- property-classifier` if tests exist (else manual verify).
  </verify>
  <done>Property classifier uses generic numeric handling, no hardcoded defaults dict</done>
</task>

<task type="auto">
  <name>Task 3: Add empty state handling for hierarchy filter</name>
  <files>src/components/LATCHFilter.tsx</files>
  <action>
When no hierarchy data exists, show helpful empty state instead of default slider.

Update the hierarchy case in renderControl() (lines 227-285):

After the existing `return (` for HierarchyTreeView, wrap with a check:
```typescript
case 'hierarchy':
  // Handle empty state when no nodes or edges exist
  if (!allNodes || allNodes.length === 0) {
    return (
      <div className="text-gray-500 italic text-sm py-4">
        No hierarchy data. Create cards with parent-child relationships to use this filter.
      </div>
    );
  }

  return (
    <HierarchyTreeView
      // ... existing props unchanged ...
    />
  );
```

This satisfies UI-05 for the hierarchy filter: Empty states shown when no values discovered.
  </action>
  <verify>
Run `npm run typecheck` - should pass.
Manual test: With empty database (no nodes), verify hierarchy filter shows empty state message.
Manual test: With populated database, verify HierarchyTreeView renders as before.
  </verify>
  <done>Empty state displayed when no hierarchy data exists</done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes with no new errors
2. `npm run lint` passes with no new errors in modified files
3. `grep -r "numericColumnsWithDefaults" src/` returns no matches
4. Manual verification:
   - Open LATCHFilter with hierarchy axis
   - Verify priority slider shows range from actual data
   - Verify filter clearing works correctly with discovered range
   - If no hierarchy data exists, verify empty state message appears
</verification>

<success_criteria>
- LATCHFilter priority range discovered dynamically from MIN/MAX query
- property-classifier numericColumnsWithDefaults removed entirely
- Generic numeric handling works for any numeric column
- Missing columns return false gracefully (no crashes)
- Empty state shown when no hierarchy data exists
- No TypeScript errors
- Requirements UI-04, UI-05 (for LATCHFilter), CLASSIFY-01, CLASSIFY-02, CLASSIFY-03 satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/101-ui-integration/101-02-SUMMARY.md`
</output>
