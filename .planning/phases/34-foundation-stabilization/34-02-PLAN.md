---
phase: 34-foundation-stabilization
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/d3/components/GridCell.tsx
  - src/d3/SuperGrid.ts
  - src/types/grid.ts
  - src/hooks/useVirtualizedGrid.ts
autonomous: true

must_haves:
  truths:
    - "Grid cells render with Janus density model supporting sparse to dense states"
    - "User sees count badges when multiple cards exist in single cell"
    - "Cell transitions animate smoothly when density controls change state"
    - "Virtual scrolling handles 10k+ cells maintaining 60fps performance"
  artifacts:
    - path: "src/d3/components/GridCell.tsx"
      provides: "Janus density cell component with morphing transitions"
      min_lines: 80
      exports: ["GridCell", "useCellDensity"]
    - path: "src/types/grid.ts"
      provides: "Unified cell data structure for all density levels"
      contains: "interface CellData"
    - path: "src/hooks/useVirtualizedGrid.ts"
      provides: "TanStack Virtual integration with D3.js cell rendering"
      exports: ["useVirtualizedGrid"]
  key_links:
    - from: "src/d3/components/GridCell.tsx"
      to: "src/types/grid.ts CellData"
      via: "props interface binding"
      pattern: "interface.*CellData"
    - from: "src/d3/SuperGrid.ts"
      to: "GridCell component rendering"
      via: "D3.js .join() data binding"
      pattern: "\\.join\\(.*GridCell"
---

<objective>
Implement Janus density model grid cells with morphing transitions and virtual scrolling foundation.

Purpose: Establish the core grid cell architecture that enables the four-level Janus density system (sparse→dense transitions) and virtual scrolling for 10k+ row performance. This creates the structural foundation for SuperGrid's polymorphic data projection capabilities.

Output: Working grid cells that morph between density states with count badges, integrated virtual scrolling, and unified CellData structure supporting all Super* features.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/34-foundation-stabilization/34-CONTEXT.md
@.planning/phases/34-foundation-stabilization/34-RESEARCH.md
@CLAUDE.md
@src/d3/SuperGrid.ts
@src/hooks/useVirtualLiveQuery.ts
</context>

<tasks>

<task type="auto">
  <name>Create Unified CellData Structure</name>
  <files>
    src/types/grid.ts
  </files>
  <action>
    Create the unified data structure per user decisions (future-ready with Super* hooks):

    ```typescript
    interface CellData {
      // Core data
      cards: Card[];
      densityLevel: number;           // 0=sparse, 3=collapsed per Janus model
      aggregationType: 'none' | 'group' | 'rollup';

      // Janus model orthogonal controls
      panLevel: number;               // Extent control (0=all, 3=viewport)
      zoomLevel: number;              // Value control (0=leaf, 3=summary)

      // Position in grid
      row: number;
      column: number;
      x: number;
      y: number;

      // Super* feature hooks (minimal implementation, structural preparation)
      selectionCoords?: { row: number; col: number; depth: number };
      expansionState?: 'collapsed' | 'inline' | 'modal';
      eventDelegation?: { onSelect: () => void; onExpand: () => void };
    }
    ```

    Follow user decision: unified structure across all density levels, minimal Super* hooks for future expansion. Include proper TypeScript interfaces for card morphing transitions.
  </action>
  <verify>TypeScript compilation succeeds for CellData interface usage</verify>
  <done>Unified CellData structure supports sparse→dense morphing and Super* feature hooks</done>
</task>

<task type="auto">
  <name>Implement Janus Density Grid Cells</name>
  <files>
    src/d3/components/GridCell.tsx
  </files>
  <action>
    Create grid cell component implementing user decisions (Janus model with morphing transitions):

    1. Core cell rendering with D3.js data binding using .join() patterns:
       - Sparse state: individual card rectangles with full details
       - Dense state: count badge with aggregated information
       - Smooth morphing transitions between states (animate card-to-badge)

    2. Density state handling per Janus model:
       ```typescript
       const renderCellContent = (cellData: CellData) => {
         if (cellData.cards.length === 1) return renderSingleCard(cellData.cards[0]);
         if (cellData.cards.length <= 5) return renderCardStack(cellData.cards);
         return renderCountBadge(cellData.cards.length);
       };
       ```

    3. Morphing animation implementation per user decision:
       - Detect density state changes via useEffect
       - Animate opacity, scale, and position during transitions
       - Duration: 200ms per research recommendations

    4. Integration with D3.js SuperGrid via proper key functions (d => `${d.row}-${d.column}`)

    Use established D3.js patterns from research: .join() method, specific SVG types, proper key functions.
  </action>
  <verify>Grid cells render and animate transitions between sparse/dense states smoothly</verify>
  <done>Working Janus density cells with morphing transitions and count badges</done>
</task>

<task type="auto">
  <name>Integrate TanStack Virtual Scrolling</name>
  <files>
    src/hooks/useVirtualizedGrid.ts
    src/d3/SuperGrid.ts
  </files>
  <action>
    Integrate virtual scrolling per research recommendations (TanStack Virtual + D3.js):

    1. Create useVirtualizedGrid hook following TanStack Virtual patterns:
       ```typescript
       const useVirtualizedGrid = (
         itemCount: number,
         columnCount: number,
         options: { itemHeight: number; estimatedItemWidth: number }
       ) => {
         // TanStack Virtual configuration for grid
         // Return virtualGridItems, totalHeight, totalWidth
       };
       ```

    2. Modify SuperGrid.ts to use virtual scrolling:
       - Replace direct D3.js cell rendering with virtual item rendering
       - Bind only visible virtual items to D3.js selections
       - Maintain 60fps performance target per user requirements

    3. Performance optimization per research:
       - Configure overscan properly for smooth scrolling
       - Use estimateSize callbacks for dynamic cell sizing
       - Limit virtual item count to prevent memory issues

    4. Integration with GridCell component:
       - Virtual items contain CellData with proper positioning
       - D3.js renders only visible cells using virtual coordinates

    Follow research pattern: TanStack Virtual handles virtualization, D3.js handles visible cell rendering.
  </action>
  <verify>Grid scrolls smoothly through 10k+ cells maintaining 60fps in browser dev tools</verify>
  <done>Virtual scrolling integrated with D3.js cell rendering, 60fps performance verified</done>
</task>

</tasks>

<verification>
Test complete grid cell functionality:
- Create test dataset with 10k+ cells containing varying card counts (1, 5, 20+ cards per cell)
- Verify smooth scrolling through entire dataset maintaining 60fps
- Test density transitions by programmatically changing cell densityLevel values
- Confirm count badges appear correctly for multi-card cells
- Verify D3.js key functions prevent element flickering during updates
</verification>

<success_criteria>
1. Grid cells implement full Janus density model with morphing transitions
2. Count badges display correctly when multiple cards present in cells
3. Virtual scrolling handles 10k+ cells with 60fps performance maintained
4. CellData structure supports all density levels with unified interface
5. D3.js data binding uses proper key functions preventing visual glitches
6. Foundation ready for SuperGrid headers and axis assignment in next phase
</success_criteria>

<output>
After completion, create `.planning/phases/34-foundation-stabilization/34-02-SUMMARY.md`
</output>