---
phase: 34-foundation-stabilization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/d3/hooks/useD3ViewLayout.ts
  - src/d3/SuperGrid.ts
  - src/db/SQLiteProvider.tsx
  - src/hooks/useVirtualLiveQuery.ts
  - src/services/GraphAnalyticsAdapter.ts
  - src/services/ConnectionSuggestionService.ts
  - src/db/types.ts
autonomous: true

must_haves:
  truths:
    - "TypeScript compilation succeeds with zero errors across sql.js and D3.js modules"
    - "sql.js FTS5 and recursive CTE capabilities are verified programmatically"
    - "D3.js data binding works with proper key functions and type safety"
  artifacts:
    - path: "src/db/SQLiteProvider.tsx"
      provides: "Clean sql.js integration with proper TypeScript types"
      exports: ["useSQLite", "useSQLiteQuery", "SQLiteProvider"]
    - path: "src/d3/SuperGrid.ts"
      provides: "D3.js grid renderer with type-safe selections"
      min_lines: 200
    - path: "src/db/types.ts"
      provides: "Unified TypeScript interfaces for sql.js and D3.js integration"
      contains: "interface GridCellData"
  key_links:
    - from: "src/db/SQLiteProvider.tsx"
      to: "sql.js Database"
      via: "synchronous execute() calls"
      pattern: "db\\.exec\\(|db\\.prepare\\("
    - from: "src/d3/SuperGrid.ts"
      to: "DatabaseService query"
      via: "direct synchronous calls"
      pattern: "this\\.db\\.query"
---

<objective>
Establish stable sql.js + D3.js foundation with clean TypeScript compilation and verified capabilities.

Purpose: Create the clean foundation required for SuperGrid implementation by eliminating TypeScript errors that prevent reliable D3.js data binding and sql.js integration. This enables the Janus density model and grid rendering work in subsequent plans.

Output: Zero TypeScript compilation errors, verified sql.js FTS5/CTE capabilities, and type-safe D3.js patterns ready for grid cell implementation.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/34-foundation-stabilization/34-CONTEXT.md
@.planning/phases/34-foundation-stabilization/34-RESEARCH.md
@CLAUDE.md
@src/db/SQLiteProvider.tsx
@src/d3/SuperGrid.ts
@src/db/types.ts
</context>

<tasks>

<task type="auto">
  <name>Fix TypeScript D3.js Type Conflicts</name>
  <files>
    src/d3/hooks/useD3ViewLayout.ts
    src/d3/SuperGrid.ts
    src/hooks/useVirtualLiveQuery.ts
    src/db/types.ts
  </files>
  <action>
    Fix D3.js type compatibility issues systematically per user decision (zero tolerance for `any`). Specific fixes:

    1. In useD3ViewLayout.ts line 101: Replace `FlexibleSelection<BaseType>` with specific `Selection<SVGGElement, unknown, null, undefined>` type for merge() compatibility
    2. In SuperGrid.ts: Remove unused variables (`filters`, `event`, `d` parameters) that are causing TS6133 errors
    3. In useVirtualLiveQuery.ts: Fix variable declaration order (virtualItems used before declaration on line 274)
    4. In types.ts: Add proper GridCellData interface extending D3 selection types

    Use research-recommended pattern: specific D3 types (SVGSelection, GroupSelection) instead of generic BaseType. Replace any generic D3 selections with proper typed selections following D3v7 .join() patterns.
  </action>
  <verify>npm run typecheck shows 0 D3.js related TypeScript errors</verify>
  <done>All D3.js modules compile cleanly with strict TypeScript types, no `any` types used</done>
</task>

<task type="auto">
  <name>Fix sql.js TypeScript Integration Issues</name>
  <files>
    src/db/SQLiteProvider.tsx
    src/services/GraphAnalyticsAdapter.ts
    src/services/ConnectionSuggestionService.ts
  </files>
  <action>
    Resolve sql.js type safety issues per user decision (systematic cleanup, zero `any`):

    1. SQLiteProvider.tsx lines 168, 201: Fix `unknown[]` to `SqlValue[]` parameter binding issue - add proper type assertion `as SqlValue[]` with validation
    2. SQLiteProvider.tsx line 224: Fix `Uint8Array<ArrayBufferLike>` to `BlobPart` conversion - use proper ArrayBuffer type assertion
    3. GraphAnalyticsAdapter.ts: Fix BridgeResponse type issues (remove bridge-specific error handling per bridge elimination approach)
    4. ConnectionSuggestionService.ts line 417: Remove unused `suggestionId` parameter

    Maintain fail-fast error handling approach per user decision. Add error telemetry capture structure for future Claude Code integration.
  </action>
  <verify>npm run typecheck shows 0 sql.js related TypeScript errors</verify>
  <done>sql.js integration compiles cleanly with proper type safety, no bridge dependencies</done>
</task>

<task type="auto">
  <name>Verify sql.js Capabilities with Error Telemetry</name>
  <files>
    src/db/SQLiteProvider.tsx
    src/db/types.ts
  </files>
  <action>
    Enhance sql.js capability verification per user decisions (fail fast with telemetry):

    1. Replace CDN sql.js with vendored sql.js-fts5 package as recommended in research (user decision: all local assets)
    2. Add comprehensive capability tests: FTS5 search, JSON1 operations, recursive CTEs for graph traversal
    3. Implement error telemetry structure for Claude Code integration:
       ```typescript
       interface SQLiteCapabilityError {
         capability: 'fts5' | 'json1' | 'recursive_cte';
         error: string;
         timestamp: string;
         context: Record<string, unknown>;
       }
       ```
    4. Verify all capabilities work with sample queries, capture detailed error information on failures
    5. Add startup timing metrics for sql.js initialization performance monitoring

    Follow user decision: fail fast with telemetry, always available database, vendored assets approach.
  </action>
  <verify>Console shows âœ… for FTS5, JSON1, and recursive CTE verification during startup</verify>
  <done>sql.js capabilities fully verified with error telemetry system for future debugging</done>
</task>

</tasks>

<verification>
Run complete TypeScript compilation and verify zero errors:
- `npm run typecheck` returns exit code 0
- Console startup logs show all sql.js capabilities verified
- D3.js data binding patterns use proper key functions and typed selections
- No `any` types anywhere in sql.js or D3.js integration code
</verification>

<success_criteria>
1. TypeScript compilation succeeds with zero errors across entire codebase
2. sql.js initializes with verified FTS5, JSON1, and recursive CTE support
3. D3.js SuperGrid can bind data synchronously from sql.js queries
4. Error telemetry system captures capability failures for debugging
5. Foundation ready for Janus density model implementation in next plan
</success_criteria>

<output>
After completion, create `.planning/phases/34-foundation-stabilization/34-01-SUMMARY.md`
</output>