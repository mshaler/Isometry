---
phase: 65-facet-discovery
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/property-classifier.ts
  - src/services/__tests__/property-classifier.test.ts
autonomous: true

must_haves:
  truths:
    - "classifyProperties() returns dynamic properties from node_properties alongside schema facets"
    - "Dynamic properties have isDynamic: true flag for UI distinction"
    - "Value type correctly infers LATCH bucket (string->A/T, number->H, array->C)"
  artifacts:
    - path: "src/services/property-classifier.ts"
      provides: "discoverDynamicProperties() and inferLATCHBucket() functions"
      exports: ["classifyProperties", "ClassifiedProperty"]
    - path: "src/services/__tests__/property-classifier.test.ts"
      provides: "Tests for dynamic property discovery"
      contains: "discoverDynamicProperties"
  key_links:
    - from: "src/services/property-classifier.ts"
      to: "node_properties table"
      via: "SQL query for distinct keys"
      pattern: "SELECT.*FROM node_properties"
---

<objective>
Extend property classifier to discover dynamic properties from node_properties table.

Purpose: Enable schema-on-read by surfacing arbitrary YAML frontmatter keys as LATCH-classified properties.
Output: Extended ClassifiedProperty interface with isDynamic flag, discoverDynamicProperties() function, LATCH bucket inference.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/65-facet-discovery/65-RESEARCH.md

@src/services/property-classifier.ts
@src/etl/storage/property-storage.ts
@src/db/schema.sql (lines 66-79 for node_properties table)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend ClassifiedProperty interface and add discovery function</name>
  <files>src/services/property-classifier.ts</files>
  <action>
1. Extend ClassifiedProperty interface with two new optional fields:
   - `isDynamic?: boolean` - true for properties discovered from node_properties
   - `nodeCount?: number` - count of nodes with this property (for UI badge)

2. Add DynamicProperty interface for internal use:
   ```typescript
   interface DynamicProperty {
     key: string;
     valueType: 'string' | 'number' | 'boolean' | 'array' | 'object' | 'null';
     nodeCount: number;
     sampleValue: string;
   }
   ```

3. Add `discoverDynamicProperties(db: Database): DynamicProperty[]` function:
   - Query: SELECT key, value_type, COUNT(DISTINCT node_id) as node_count, MIN(value) as sample_value FROM node_properties GROUP BY key, value_type HAVING node_count >= 3 ORDER BY node_count DESC LIMIT 50
   - Parse result rows into DynamicProperty array
   - Return empty array if no results

4. Add `inferLATCHBucket(valueType: string, key: string, sampleValue?: string): LATCHBucket` function:
   - Time (T): If valueType='string' AND key matches /date|time|created|modified|due|start|end/i, OR sampleValue matches ISO date pattern /^\d{4}-\d{2}-\d{2}/
   - Hierarchy (H): If valueType='number'
   - Category (C): If valueType='array' OR valueType='boolean'
   - Location (L): If key matches /location|address|city|country|lat|lon|place/i
   - Alphabet (A): Default for remaining strings

5. Add helper `humanizeKey(key: string): string`:
   - Replace underscores with spaces
   - Capitalize first letter of each word
   - Example: "contact_email" -> "Contact Email"

6. Modify `classifyProperties(db: Database)`:
   - After loading schema facets, call discoverDynamicProperties(db)
   - Track existing facet sourceColumns in a Set to detect collisions
   - For each dynamic property:
     - Check collision: if key exists in schema facets, append " (custom)" to name
     - Create ClassifiedProperty with isDynamic: true, nodeCount set
     - Use ID format: `dynamic-${prop.key}`
     - Use sourceColumn format: `node_properties.${prop.key}` (for projection query detection)
     - Infer bucket via inferLATCHBucket()
     - Set sortOrder to 1000 + bucket.length (after schema facets)
   - Push to appropriate LATCH bucket
  </action>
  <verify>
npm run typecheck (zero errors)
npm run test -- property-classifier (tests pass)
  </verify>
  <done>
classifyProperties() returns both schema facets and dynamic properties, dynamic properties have isDynamic: true and nodeCount set
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tests for dynamic property discovery</name>
  <files>src/services/__tests__/property-classifier.test.ts</files>
  <action>
Add test suite for dynamic property discovery:

1. Test "discoverDynamicProperties returns properties from node_properties":
   - Setup: Insert test node, then insert 3 node_properties rows (same key, different nodes)
   - Verify: discoverDynamicProperties returns the key with nodeCount=3
   - Teardown: Delete test data

2. Test "inferLATCHBucket maps value types correctly":
   - valueType='number' -> 'H'
   - valueType='array' -> 'C'
   - valueType='boolean' -> 'C'
   - valueType='string', key='created_date' -> 'T'
   - valueType='string', key='address' -> 'L'
   - valueType='string', key='custom_field' -> 'A'

3. Test "classifyProperties includes dynamic properties":
   - Setup: Insert test nodes with custom frontmatter keys stored in node_properties
   - Call classifyProperties()
   - Verify: Result contains dynamic properties with isDynamic=true
   - Verify: Dynamic properties appear in correct LATCH bucket

4. Test "dynamic property with collision gets renamed":
   - Setup: Schema has "priority" facet, node_properties has "priority" key
   - Call classifyProperties()
   - Verify: Schema "Priority" unchanged, dynamic "Priority (custom)" appears

5. Test "dynamic properties filtered by node count threshold":
   - Setup: One key with nodeCount=5, one with nodeCount=1
   - Verify: Only key with nodeCount>=3 appears in classification

Use existing test patterns for database setup/teardown from the file.
  </action>
  <verify>
npm run test -- property-classifier --run (all tests pass)
npm run test:coverage -- property-classifier (coverage maintained)
  </verify>
  <done>
Test suite covers discovery, inference, classification integration, collision handling, and threshold filtering
  </done>
</task>

</tasks>

<verification>
1. Run full test suite: `npm run test -- property-classifier --run`
2. Run typecheck: `npm run typecheck`
3. Manual verification (optional): Import markdown files with custom frontmatter, verify console.log shows dynamic properties in classification output
</verification>

<success_criteria>
- classifyProperties() returns dynamic properties from node_properties table
- Dynamic properties have isDynamic: true and nodeCount set
- Value type inference correctly routes to LATCH buckets
- Collision detection adds " (custom)" suffix to dynamic property names
- All tests pass, zero TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/65-facet-discovery/65-01-SUMMARY.md`
</output>
