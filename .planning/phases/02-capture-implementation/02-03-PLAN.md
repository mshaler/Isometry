---
phase: 02-capture-implementation
plan: 03
type: execute
wave: 3
depends_on: ["02-01", "02-02"]
files_modified: [
  "src/components/notebook/CaptureComponent.tsx",
  "src/hooks/useSlashCommands.ts",
  "src/components/notebook/SlashCommandMenu.tsx",
  "src/utils/isometryDSL.ts",
  "src/components/notebook/TemplateManager.tsx"
]
autonomous: true

must_haves:
  truths:
    - "User can trigger slash commands by typing '/' in markdown editor"
    - "User can insert Isometry DSL patterns via slash commands"
    - "User can create and use card templates"
  artifacts:
    - path: "src/hooks/useSlashCommands.ts"
      provides: "Slash command detection and handling"
      exports: ["useSlashCommands"]
    - path: "src/components/notebook/SlashCommandMenu.tsx"
      provides: "Command selection menu"
      exports: ["SlashCommandMenu"]
    - path: "src/utils/isometryDSL.ts"
      provides: "DSL pattern definitions"
      exports: ["DSL_PATTERNS", "insertPattern"]
    - path: "src/components/notebook/TemplateManager.tsx"
      provides: "Template creation and selection"
      exports: ["TemplateManager"]
  key_links:
    - from: "src/hooks/useSlashCommands.ts"
      to: "src/utils/isometryDSL.ts"
      via: "DSL pattern insertion"
      pattern: "insertPattern"
    - from: "src/components/notebook/CaptureComponent.tsx"
      to: "SlashCommandMenu"
      via: "command menu overlay"
      pattern: "SlashCommandMenu"
---

<objective>
Add slash command system for inserting Isometry DSL patterns and implement card template management, completing the capture implementation with advanced content creation features.

Purpose: Enable rapid content creation through slash commands for common Isometry patterns and provide template system for reusable card structures.
Output: Slash command system with DSL patterns and template management for efficient content creation.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/02-capture-implementation/02-01-PLAN.md
@.planning/phases/02-capture-implementation/02-02-PLAN.md
@src/components/notebook/CaptureComponent.tsx
@src/types/notebook.ts
</context>

<tasks>

<task type="auto">
  <name>Create Isometry DSL patterns utility</name>
  <files>src/utils/isometryDSL.ts</files>
  <action>
    Create a utility module with common Isometry DSL patterns and insertion logic:

    ```typescript
    export interface DSLPattern {
      id: string;
      label: string;
      description: string;
      category: 'pafv' | 'latch' | 'graph' | 'query' | 'structure';
      pattern: string;
      cursorPosition?: number; // Position to place cursor after insertion
      requiredFields?: string[]; // Fields that need user input
    }

    export const DSL_PATTERNS: DSLPattern[] = [
      // PAFV Patterns
      {
        id: 'pafv-projection',
        label: 'PAFV Projection',
        description: 'Create a spatial projection view',
        category: 'pafv',
        pattern: `## PAFV Projection: {{title}}

    **Planes**: {{planes}}
    **Axes**: {{axes}}
    **Facets**: {{facets}}
    **Values**: {{values}}

    ### Configuration
    \`\`\`json
    {
      "projection": {
        "planes": ["{{planes}}"],
        "axes": ["{{axes}}"],
        "facets": ["{{facets}}"],
        "values": ["{{values}}"]
      }
    }
    \`\`\``,
        cursorPosition: 22,
        requiredFields: ['title', 'planes', 'axes', 'facets', 'values']
      },

      // LATCH Patterns
      {
        id: 'latch-filter',
        label: 'LATCH Filter',
        description: 'Define a LATCH-based filter',
        category: 'latch',
        pattern: `## Filter: {{name}}

    **Location**: {{location}}
    **Alphabet**: {{alphabet}}
    **Time**: {{time}}
    **Category**: {{category}}
    **Hierarchy**: {{hierarchy}}

    ### SQL Query
    \`\`\`sql
    SELECT * FROM nodes
    WHERE {{conditions}}
    \`\`\``,
        cursorPosition: 15,
        requiredFields: ['name', 'location', 'alphabet', 'time', 'category', 'hierarchy', 'conditions']
      },

      // Graph Patterns
      {
        id: 'graph-relationship',
        label: 'Graph Relationship',
        description: 'Define node relationships',
        category: 'graph',
        pattern: `## Relationship: {{source}} → {{target}}

    **Type**: {{relationship_type}}
    **Direction**: {{direction}}
    **Properties**:
    - {{property1}}: {{value1}}
    - {{property2}}: {{value2}}

    ### Graph Query
    \`\`\`sql
    WITH RECURSIVE graph AS (
      SELECT * FROM edges WHERE source_id = '{{source_id}}'
      UNION ALL
      SELECT e.* FROM edges e
      JOIN graph g ON e.source_id = g.target_id
    )
    SELECT * FROM graph;
    \`\`\``,
        cursorPosition: 24,
        requiredFields: ['source', 'target', 'relationship_type', 'direction', 'property1', 'value1', 'property2', 'value2', 'source_id']
      },

      // Query Patterns
      {
        id: 'supergrid-query',
        label: 'SuperGrid Query',
        description: 'Query for SuperGrid display',
        category: 'query',
        pattern: `## SuperGrid Query: {{name}}

    \`\`\`sql
    SELECT
      n.id,
      n.name,
      n.node_type,
      f.facet_value,
      f.facet_type
    FROM nodes n
    JOIN facets f ON f.node_id = n.id
    WHERE {{conditions}}
    ORDER BY {{order_by}}
    LIMIT {{limit}};
    \`\`\`

    ### Expected Columns
    - **id**: Node identifier
    - **name**: Display name
    - **node_type**: Category
    - **facet_value**: Data value
    - **facet_type**: Value type`,
        cursorPosition: 29,
        requiredFields: ['name', 'conditions', 'order_by', 'limit']
      },

      // Structure Patterns
      {
        id: 'notebook-structure',
        label: 'Notebook Structure',
        description: 'Standard notebook card structure',
        category: 'structure',
        pattern: `# {{title}}

    ## Summary
    {{summary}}

    ## Details
    {{details}}

    ## Links
    - [[{{related_card_1}}]]
    - [[{{related_card_2}}]]

    ## Actions
    - [ ] {{action_1}}
    - [ ] {{action_2}}

    ## Properties
    - **Status**: {{status}}
    - **Priority**: {{priority}}
    - **Created**: {{created_date}}`,
        cursorPosition: 2,
        requiredFields: ['title', 'summary', 'details', 'related_card_1', 'related_card_2', 'action_1', 'action_2', 'status', 'priority', 'created_date']
      },

      {
        id: 'data-model',
        label: 'Data Model',
        description: 'Define a data structure',
        category: 'structure',
        pattern: `## Data Model: {{model_name}}

    ### Schema
    \`\`\`typescript
    interface {{model_name}} {
      id: string;
      {{field_1}}: {{type_1}};
      {{field_2}}: {{type_2}};
      createdAt: string;
      modifiedAt: string;
    }
    \`\`\`

    ### Database Table
    \`\`\`sql
    CREATE TABLE {{table_name}} (
      id TEXT PRIMARY KEY,
      {{field_1}} {{sql_type_1}},
      {{field_2}} {{sql_type_2}},
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      modified_at DATETIME DEFAULT CURRENT_TIMESTAMP
    );
    \`\`\``,
        cursorPosition: 20,
        requiredFields: ['model_name', 'field_1', 'type_1', 'field_2', 'type_2', 'table_name', 'sql_type_1', 'sql_type_2']
      }
    ];

    export function insertPattern(pattern: DSLPattern, userInputs: Record<string, string> = {}): string {
      let result = pattern.pattern;

      // Replace placeholders with user inputs
      Object.entries(userInputs).forEach(([key, value]) => {
        const placeholder = `{{${key}}}`;
        result = result.replace(new RegExp(placeholder.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), value);
      });

      return result;
    }

    export function extractRequiredFields(pattern: string): string[] {
      const matches = pattern.match(/{{\w+}}/g);
      if (!matches) return [];

      return [...new Set(matches.map(match => match.slice(2, -2)))];
    }

    export function getPatternsByCategory(category?: string): DSLPattern[] {
      if (!category) return DSL_PATTERNS;
      return DSL_PATTERNS.filter(pattern => pattern.category === category);
    }

    export function findPattern(id: string): DSLPattern | undefined {
      return DSL_PATTERNS.find(pattern => pattern.id === id);
    }
    ```

    This provides a comprehensive set of Isometry-specific patterns covering PAFV, LATCH, Graph, Query, and Structure use cases.
  </action>
  <verify>Module exports DSL patterns and utility functions correctly</verify>
  <done>isometryDSL module provides comprehensive pattern definitions and insertion utilities</done>
</task>

<task type="auto">
  <name>Create slash command hook</name>
  <files>src/hooks/useSlashCommands.ts</files>
  <action>
    Create a hook that detects slash commands and manages their lifecycle:

    ```typescript
    import { useState, useCallback, useEffect, useRef } from 'react';
    import { DSL_PATTERNS, findPattern, insertPattern, type DSLPattern } from '../utils/isometryDSL';

    interface SlashCommandState {
      isOpen: boolean;
      query: string;
      position: { x: number; y: number } | null;
      selectedIndex: number;
      filteredPatterns: DSLPattern[];
    }

    interface UseSlashCommandsOptions {
      onInsert?: (text: string, cursorPosition?: number) => void;
    }

    export function useSlashCommands(options: UseSlashCommandsOptions = {}) {
      const [state, setState] = useState<SlashCommandState>({
        isOpen: false,
        query: '',
        position: null,
        selectedIndex: 0,
        filteredPatterns: []
      });

      const [showFieldEditor, setShowFieldEditor] = useState(false);
      const [selectedPattern, setSelectedPattern] = useState<DSLPattern | null>(null);
      const [fieldValues, setFieldValues] = useState<Record<string, string>>({});

      // Handle text change to detect slash commands
      const handleTextChange = useCallback((text: string, cursorPosition: number, editorElement?: HTMLElement) => {
        const beforeCursor = text.slice(0, cursorPosition);
        const lastSlashIndex = beforeCursor.lastIndexOf('/');

        if (lastSlashIndex === -1 || lastSlashIndex < beforeCursor.length - 20) {
          // No recent slash or too far away
          setState(prev => ({ ...prev, isOpen: false }));
          return;
        }

        const afterSlash = beforeCursor.slice(lastSlashIndex + 1);

        // Check if there's whitespace after slash (would break command)
        if (afterSlash.includes(' ') || afterSlash.includes('\n')) {
          setState(prev => ({ ...prev, isOpen: false }));
          return;
        }

        // Filter patterns based on query
        const filtered = DSL_PATTERNS.filter(pattern =>
          pattern.label.toLowerCase().includes(afterSlash.toLowerCase()) ||
          pattern.description.toLowerCase().includes(afterSlash.toLowerCase()) ||
          pattern.category.toLowerCase().includes(afterSlash.toLowerCase())
        );

        // Calculate menu position
        let position = null;
        if (editorElement) {
          try {
            const rect = editorElement.getBoundingClientRect();
            // Approximate position - real implementation would need cursor position
            position = {
              x: rect.left + 10,
              y: rect.top + 50
            };
          } catch (e) {
            // Fallback position
            position = { x: 100, y: 100 };
          }
        }

        setState({
          isOpen: filtered.length > 0,
          query: afterSlash,
          position,
          selectedIndex: 0,
          filteredPatterns: filtered
        });
      }, []);

      // Handle keyboard navigation
      const handleKeyDown = useCallback((event: KeyboardEvent): boolean => {
        if (!state.isOpen) return false;

        switch (event.key) {
          case 'ArrowDown':
            event.preventDefault();
            setState(prev => ({
              ...prev,
              selectedIndex: Math.min(prev.selectedIndex + 1, prev.filteredPatterns.length - 1)
            }));
            return true;

          case 'ArrowUp':
            event.preventDefault();
            setState(prev => ({
              ...prev,
              selectedIndex: Math.max(prev.selectedIndex - 1, 0)
            }));
            return true;

          case 'Enter':
            event.preventDefault();
            const pattern = state.filteredPatterns[state.selectedIndex];
            if (pattern) {
              selectPattern(pattern);
            }
            return true;

          case 'Escape':
            event.preventDefault();
            setState(prev => ({ ...prev, isOpen: false }));
            return true;

          default:
            return false;
        }
      }, [state]);

      // Select a pattern for insertion
      const selectPattern = useCallback((pattern: DSLPattern) => {
        setSelectedPattern(pattern);
        setState(prev => ({ ...prev, isOpen: false }));

        if (pattern.requiredFields && pattern.requiredFields.length > 0) {
          // Initialize field values
          const initialValues: Record<string, string> = {};
          pattern.requiredFields.forEach(field => {
            initialValues[field] = '';
          });
          setFieldValues(initialValues);
          setShowFieldEditor(true);
        } else {
          // Insert pattern directly
          insertSelectedPattern(pattern, {});
        }
      }, []);

      // Insert pattern with field values
      const insertSelectedPattern = useCallback((pattern: DSLPattern, values: Record<string, string>) => {
        const insertedText = insertPattern(pattern, values);
        if (options.onInsert) {
          options.onInsert(insertedText, pattern.cursorPosition);
        }

        // Reset state
        setSelectedPattern(null);
        setFieldValues({});
        setShowFieldEditor(false);
      }, [options.onInsert]);

      // Complete field editing
      const completeFieldEditing = useCallback(() => {
        if (selectedPattern) {
          insertSelectedPattern(selectedPattern, fieldValues);
        }
      }, [selectedPattern, fieldValues, insertSelectedPattern]);

      // Cancel field editing
      const cancelFieldEditing = useCallback(() => {
        setSelectedPattern(null);
        setFieldValues({});
        setShowFieldEditor(false);
      }, []);

      return {
        // State
        isMenuOpen: state.isOpen,
        menuPosition: state.position,
        filteredPatterns: state.filteredPatterns,
        selectedIndex: state.selectedIndex,
        showFieldEditor,
        selectedPattern,
        fieldValues,

        // Methods
        handleTextChange,
        handleKeyDown,
        selectPattern,
        setFieldValues,
        completeFieldEditing,
        cancelFieldEditing,

        // Direct access to patterns
        getAllPatterns: () => DSL_PATTERNS,
        getPatternsByCategory: (category: string) => DSL_PATTERNS.filter(p => p.category === category)
      };
    }
    ```

    This hook manages the full slash command lifecycle from detection to insertion.
  </action>
  <verify>Hook exports all necessary slash command functionality</verify>
  <done>useSlashCommands hook provides complete slash command detection and management</done>
</task>

<task type="auto">
  <name>Create slash command menu component</name>
  <files>src/components/notebook/SlashCommandMenu.tsx</files>
  <action>
    Create a floating menu component for slash command selection:

    ```tsx
    import { useEffect, useRef } from 'react';
    import { Hash, Filter, Share2, Search, FileText } from 'lucide-react';
    import { useTheme } from '../../contexts/ThemeContext';
    import type { DSLPattern } from '../../utils/isometryDSL';

    interface SlashCommandMenuProps {
      isOpen: boolean;
      position: { x: number; y: number } | null;
      patterns: DSLPattern[];
      selectedIndex: number;
      onSelect: (pattern: DSLPattern) => void;
      onClose: () => void;
    }

    const CATEGORY_ICONS = {
      pafv: Hash,
      latch: Filter,
      graph: Share2,
      query: Search,
      structure: FileText
    };

    const CATEGORY_COLORS = {
      pafv: 'text-blue-600 bg-blue-50',
      latch: 'text-green-600 bg-green-50',
      graph: 'text-purple-600 bg-purple-50',
      query: 'text-orange-600 bg-orange-50',
      structure: 'text-gray-600 bg-gray-50'
    };

    export function SlashCommandMenu({
      isOpen,
      position,
      patterns,
      selectedIndex,
      onSelect,
      onClose
    }: SlashCommandMenuProps) {
      const { theme } = useTheme();
      const menuRef = useRef<HTMLDivElement>(null);

      // Handle click outside to close
      useEffect(() => {
        const handleClickOutside = (event: MouseEvent) => {
          if (menuRef.current && !menuRef.current.contains(event.target as Node)) {
            onClose();
          }
        };

        if (isOpen) {
          document.addEventListener('mousedown', handleClickOutside);
          return () => document.removeEventListener('mousedown', handleClickOutside);
        }
      }, [isOpen, onClose]);

      // Scroll selected item into view
      useEffect(() => {
        if (isOpen && menuRef.current) {
          const selectedElement = menuRef.current.children[selectedIndex] as HTMLElement;
          if (selectedElement) {
            selectedElement.scrollIntoView({ block: 'nearest' });
          }
        }
      }, [isOpen, selectedIndex]);

      if (!isOpen || !position || patterns.length === 0) {
        return null;
      }

      return (
        <div
          ref={menuRef}
          className={`fixed z-50 ${
            theme === 'NeXTSTEP'
              ? 'bg-[#c0c0c0] border-[#707070] shadow-md'
              : 'bg-white border-gray-200 shadow-lg'
          } border rounded-lg min-w-[300px] max-w-[400px] max-h-[300px] overflow-y-auto`}
          style={{
            left: position.x,
            top: position.y
          }}
        >
          {/* Header */}
          <div className={`px-3 py-2 border-b text-xs font-medium ${
            theme === 'NeXTSTEP'
              ? 'border-[#707070] bg-[#d4d4d4] text-gray-700'
              : 'border-gray-200 bg-gray-50 text-gray-600'
          }`}>
            Insert Pattern ({patterns.length} found)
          </div>

          {/* Pattern List */}
          <div className="py-1">
            {patterns.map((pattern, index) => {
              const IconComponent = CATEGORY_ICONS[pattern.category] || FileText;
              const categoryColors = CATEGORY_COLORS[pattern.category] || 'text-gray-600 bg-gray-50';
              const isSelected = index === selectedIndex;

              return (
                <button
                  key={pattern.id}
                  onClick={() => onSelect(pattern)}
                  className={`w-full flex items-start gap-3 px-3 py-2 text-left hover:${
                    theme === 'NeXTSTEP' ? 'bg-[#b0b0b0]' : 'bg-gray-100'
                  } transition-colors ${
                    isSelected
                      ? theme === 'NeXTSTEP' ? 'bg-[#b0b0b0]' : 'bg-blue-50'
                      : ''
                  }`}
                >
                  {/* Category Icon */}
                  <div className={`mt-1 p-1 rounded ${categoryColors}`}>
                    <IconComponent size={12} />
                  </div>

                  {/* Pattern Info */}
                  <div className="flex-1 min-w-0">
                    <div className="flex items-center gap-2">
                      <span className="font-medium text-sm truncate">
                        {pattern.label}
                      </span>
                      <span className={`text-xs px-1 rounded ${
                        theme === 'NeXTSTEP'
                          ? 'bg-[#d4d4d4] text-gray-600'
                          : 'bg-gray-200 text-gray-500'
                      }`}>
                        {pattern.category.toUpperCase()}
                      </span>
                    </div>
                    <p className="text-xs text-gray-500 mt-1 line-clamp-2">
                      {pattern.description}
                    </p>
                    {pattern.requiredFields && pattern.requiredFields.length > 0 && (
                      <div className="flex items-center gap-1 mt-1">
                        <span className="text-xs text-gray-400">Fields:</span>
                        <div className="flex flex-wrap gap-1">
                          {pattern.requiredFields.slice(0, 3).map(field => (
                            <span
                              key={field}
                              className={`text-xs px-1 rounded font-mono ${
                                theme === 'NeXTSTEP'
                                  ? 'bg-white text-gray-600 border'
                                  : 'bg-gray-100 text-gray-600'
                              }`}
                            >
                              {field}
                            </span>
                          ))}
                          {pattern.requiredFields.length > 3 && (
                            <span className="text-xs text-gray-400">
                              +{pattern.requiredFields.length - 3} more
                            </span>
                          )}
                        </div>
                      </div>
                    )}
                  </div>

                  {/* Selection Indicator */}
                  {isSelected && (
                    <div className="mt-1">
                      <div className="w-2 h-2 bg-blue-500 rounded-full" />
                    </div>
                  )}
                </button>
              );
            })}
          </div>

          {/* Footer */}
          <div className={`px-3 py-2 border-t text-xs ${
            theme === 'NeXTSTEP'
              ? 'border-[#707070] bg-[#d4d4d4] text-gray-600'
              : 'border-gray-200 bg-gray-50 text-gray-500'
          }`}>
            ↑↓ Navigate • Enter Select • Esc Cancel
          </div>
        </div>
      );
    }
    ```

    This component provides a rich, categorized view of available patterns with keyboard navigation support.
  </action>
  <verify>Component renders floating menu with pattern selection</verify>
  <done>SlashCommandMenu provides intuitive pattern selection interface</done>
</task>

<task type="auto">
  <name>Create template manager component</name>
  <files>src/components/notebook/TemplateManager.tsx</files>
  <action>
    Create a component for managing card templates:

    ```tsx
    import { useState, useCallback } from 'react';
    import { Plus, Edit2, Trash2, Copy, FileText, X, Check } from 'lucide-react';
    import { useTheme } from '../../contexts/ThemeContext';
    import { useNotebook } from '../../contexts/NotebookContext';
    import type { NotebookTemplate, NotebookCardType } from '../../types/notebook';

    interface TemplateManagerProps {
      isOpen: boolean;
      onClose: () => void;
      onSelectTemplate: (template: NotebookTemplate) => void;
    }

    export function TemplateManager({ isOpen, onClose, onSelectTemplate }: TemplateManagerProps) {
      const { theme } = useTheme();
      const { activeCard } = useNotebook();
      const [templates] = useState<NotebookTemplate[]>([]); // TODO: Connect to actual template storage
      const [showCreateForm, setShowCreateForm] = useState(false);
      const [editingTemplate, setEditingTemplate] = useState<NotebookTemplate | null>(null);
      const [newTemplate, setNewTemplate] = useState({
        name: '',
        description: '',
        cardType: 'capture' as NotebookCardType,
        defaultMarkdown: '',
        defaultProperties: '{}'
      });

      const handleCreateTemplate = useCallback(() => {
        if (activeCard) {
          // Pre-fill with current card content
          setNewTemplate({
            name: `Template from ${new Date().toLocaleDateString()}`,
            description: 'Created from current card',
            cardType: activeCard.cardType,
            defaultMarkdown: activeCard.markdownContent || '',
            defaultProperties: JSON.stringify(activeCard.properties || {}, null, 2)
          });
        }
        setShowCreateForm(true);
      }, [activeCard]);

      const handleSaveTemplate = useCallback(() => {
        try {
          const template: NotebookTemplate = {
            id: crypto.randomUUID(),
            name: newTemplate.name,
            description: newTemplate.description,
            cardType: newTemplate.cardType,
            defaultMarkdown: newTemplate.defaultMarkdown,
            defaultProperties: JSON.parse(newTemplate.defaultProperties || '{}'),
            created_at: new Date().toISOString(),
            modified_at: new Date().toISOString()
          };

          // TODO: Save to database via NotebookContext
          console.log('Template to save:', template);

          setShowCreateForm(false);
          setNewTemplate({
            name: '',
            description: '',
            cardType: 'capture',
            defaultMarkdown: '',
            defaultProperties: '{}'
          });
        } catch (error) {
          console.error('Invalid JSON in properties:', error);
        }
      }, [newTemplate]);

      if (!isOpen) return null;

      return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50">
          <div className={`${
            theme === 'NeXTSTEP'
              ? 'bg-[#c0c0c0] border-[#707070]'
              : 'bg-white border-gray-200'
          } border rounded-lg shadow-xl w-full max-w-4xl h-[80vh] flex flex-col`}>

            {/* Header */}
            <div className={`flex items-center justify-between p-4 border-b ${
              theme === 'NeXTSTEP'
                ? 'border-[#707070] bg-[#d4d4d4]'
                : 'border-gray-200 bg-gray-50'
            }`}>
              <h2 className="font-semibold text-lg">Card Templates</h2>
              <div className="flex items-center gap-2">
                <button
                  onClick={handleCreateTemplate}
                  className={`flex items-center gap-2 px-3 py-1 rounded text-sm hover:${
                    theme === 'NeXTSTEP' ? 'bg-[#b0b0b0]' : 'bg-gray-200'
                  } transition-colors`}
                >
                  <Plus size={14} />
                  Create from Current
                </button>
                <button
                  onClick={onClose}
                  className={`p-1 rounded hover:${
                    theme === 'NeXTSTEP' ? 'bg-[#b0b0b0]' : 'bg-gray-200'
                  } transition-colors`}
                >
                  <X size={16} />
                </button>
              </div>
            </div>

            {/* Content */}
            <div className="flex-1 flex">
              {/* Template List */}
              <div className={`w-1/3 border-r ${
                theme === 'NeXTSTEP' ? 'border-[#707070]' : 'border-gray-200'
              }`}>
                <div className="p-4">
                  <h3 className="font-medium mb-3">Available Templates ({templates.length})</h3>

                  {templates.length === 0 ? (
                    <div className="text-center py-8 text-gray-500">
                      <FileText size={24} className="mx-auto mb-2 text-gray-400" />
                      <p className="text-sm">No templates yet</p>
                      <p className="text-xs text-gray-400 mt-1">
                        Create one from your current card
                      </p>
                    </div>
                  ) : (
                    <div className="space-y-2">
                      {templates.map((template) => (
                        <div
                          key={template.id}
                          className={`p-3 border rounded hover:${
                            theme === 'NeXTSTEP' ? 'bg-[#b0b0b0]' : 'bg-gray-50'
                          } transition-colors cursor-pointer ${
                            theme === 'NeXTSTEP' ? 'border-[#707070]' : 'border-gray-200'
                          }`}
                          onClick={() => onSelectTemplate(template)}
                        >
                          <div className="flex items-start justify-between">
                            <div className="flex-1">
                              <h4 className="font-medium text-sm">{template.name}</h4>
                              <p className="text-xs text-gray-500 mt-1">
                                {template.description}
                              </p>
                              <div className="flex items-center gap-2 mt-2">
                                <span className={`text-xs px-2 py-1 rounded ${
                                  theme === 'NeXTSTEP'
                                    ? 'bg-white text-gray-600'
                                    : 'bg-gray-100 text-gray-600'
                                }`}>
                                  {template.cardType}
                                </span>
                                <span className="text-xs text-gray-400">
                                  {new Date(template.created_at).toLocaleDateString()}
                                </span>
                              </div>
                            </div>
                            <div className="flex items-center gap-1 ml-2">
                              <button
                                onClick={(e) => {
                                  e.stopPropagation();
                                  setEditingTemplate(template);
                                }}
                                className="p-1 rounded hover:bg-gray-200"
                                title="Edit template"
                              >
                                <Edit2 size={12} />
                              </button>
                              <button
                                onClick={(e) => {
                                  e.stopPropagation();
                                  // TODO: Delete template
                                }}
                                className="p-1 rounded hover:bg-red-100 text-red-500"
                                title="Delete template"
                              >
                                <Trash2 size={12} />
                              </button>
                            </div>
                          </div>
                        </div>
                      ))}
                    </div>
                  )}
                </div>
              </div>

              {/* Template Editor */}
              <div className="flex-1 flex flex-col">
                {showCreateForm || editingTemplate ? (
                  <div className="p-4 h-full flex flex-col">
                    <h3 className="font-medium mb-4">
                      {editingTemplate ? 'Edit Template' : 'Create New Template'}
                    </h3>

                    <div className="flex-1 space-y-4 overflow-y-auto">
                      <div>
                        <label className="block text-sm font-medium mb-1">Name</label>
                        <input
                          type="text"
                          value={newTemplate.name}
                          onChange={(e) => setNewTemplate(prev => ({ ...prev, name: e.target.value }))}
                          className="w-full p-2 border rounded"
                          placeholder="Template name"
                        />
                      </div>

                      <div>
                        <label className="block text-sm font-medium mb-1">Description</label>
                        <input
                          type="text"
                          value={newTemplate.description}
                          onChange={(e) => setNewTemplate(prev => ({ ...prev, description: e.target.value }))}
                          className="w-full p-2 border rounded"
                          placeholder="Brief description"
                        />
                      </div>

                      <div>
                        <label className="block text-sm font-medium mb-1">Card Type</label>
                        <select
                          value={newTemplate.cardType}
                          onChange={(e) => setNewTemplate(prev => ({ ...prev, cardType: e.target.value as NotebookCardType }))}
                          className="w-full p-2 border rounded"
                        >
                          <option value="capture">Capture</option>
                          <option value="shell">Shell</option>
                          <option value="preview">Preview</option>
                        </select>
                      </div>

                      <div>
                        <label className="block text-sm font-medium mb-1">Default Markdown</label>
                        <textarea
                          value={newTemplate.defaultMarkdown}
                          onChange={(e) => setNewTemplate(prev => ({ ...prev, defaultMarkdown: e.target.value }))}
                          className="w-full p-2 border rounded font-mono text-sm h-32 resize-y"
                          placeholder="# Template Title&#10;&#10;Your default content here..."
                        />
                      </div>

                      <div>
                        <label className="block text-sm font-medium mb-1">Default Properties (JSON)</label>
                        <textarea
                          value={newTemplate.defaultProperties}
                          onChange={(e) => setNewTemplate(prev => ({ ...prev, defaultProperties: e.target.value }))}
                          className="w-full p-2 border rounded font-mono text-sm h-24 resize-y"
                          placeholder='{"status": "draft", "priority": "medium"}'
                        />
                      </div>
                    </div>

                    <div className="flex items-center gap-2 mt-4 pt-4 border-t">
                      <button
                        onClick={handleSaveTemplate}
                        className="flex items-center gap-2 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors"
                      >
                        <Check size={14} />
                        Save Template
                      </button>
                      <button
                        onClick={() => {
                          setShowCreateForm(false);
                          setEditingTemplate(null);
                        }}
                        className="px-4 py-2 border rounded hover:bg-gray-50 transition-colors"
                      >
                        Cancel
                      </button>
                    </div>
                  </div>
                ) : (
                  <div className="flex-1 flex items-center justify-center text-gray-500">
                    <div className="text-center">
                      <FileText size={24} className="mx-auto mb-2 text-gray-400" />
                      <p>Select a template to preview</p>
                      <p className="text-sm text-gray-400 mt-1">
                        Or create a new one from your current card
                      </p>
                    </div>
                  </div>
                )}
              </div>
            </div>
          </div>
        </div>
      );
    }
    ```

    This component provides template management with creation, editing, and selection capabilities.
  </action>
  <verify>Component renders template management interface</verify>
  <done>TemplateManager provides comprehensive template creation and management UI</done>
</task>

<task type="auto">
  <name>Integrate slash commands and templates into capture component</name>
  <files>src/components/notebook/CaptureComponent.tsx</files>
  <action>
    Integrate slash commands and template management into the CaptureComponent:

    1. Import the new components and hooks:
    ```tsx
    import { useSlashCommands } from '../../hooks/useSlashCommands';
    import { SlashCommandMenu } from './SlashCommandMenu';
    import { TemplateManager } from './TemplateManager';
    import { Template } from 'lucide-react';
    ```

    2. Add state for slash commands and templates:
    ```tsx
    const [showTemplateManager, setShowTemplateManager] = useState(false);
    const [editorRef, setEditorRef] = useState<HTMLDivElement | null>(null);
    ```

    3. Set up slash command hook:
    ```tsx
    const slashCommands = useSlashCommands({
      onInsert: (text, cursorPosition) => {
        // Insert text at current cursor position in markdown editor
        const currentContent = content || '';
        const newContent = currentContent + '\n\n' + text;
        setContent(newContent);
      }
    });
    ```

    4. Add template button to header:
    ```tsx
    <div className="flex items-center gap-1">
      {/* Template button */}
      <button
        onClick={() => setShowTemplateManager(true)}
        className={`p-1 rounded hover:${theme === 'NeXTSTEP' ? 'bg-[#b0b0b0]' : 'bg-gray-200'} transition-colors`}
        title="Templates"
      >
        <Template size={14} className="text-gray-600" />
      </button>

      {/* Save button */}
      <button
        onClick={handleManualSave}
        disabled={!isDirty || isSaving}
        className={`p-1 rounded hover:${theme === 'NeXTSTEP' ? 'bg-[#b0b0b0]' : 'bg-gray-200'} transition-colors disabled:opacity-50`}
        title="Save now (Ctrl+S)"
      >
        <Save size={14} className="text-gray-600" />
      </button>

      // ... rest of header buttons
    ```

    5. Add keyboard event listener for slash command handling:
    ```tsx
    useEffect(() => {
      const handleKeyDown = (event: KeyboardEvent) => {
        // Handle slash commands first
        if (slashCommands.handleKeyDown(event)) {
          return; // Handled by slash commands
        }

        // Then handle other shortcuts
        if ((event.metaKey || event.ctrlKey)) {
          switch (event.key) {
            case 's':
              event.preventDefault();
              handleManualSave();
              break;
            case '1':
              event.preventDefault();
              // Focus capture component
              break;
            case '2':
              event.preventDefault();
              // Focus shell component
              break;
            case '3':
              event.preventDefault();
              // Focus preview component
              break;
          }
        }
      };

      if (activeCard) {
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }
    }, [slashCommands, activeCard, handleManualSave]);
    ```

    6. Add onChange handler to MDEditor to detect slash commands:
    ```tsx
    <MDEditor
      value={content}
      onChange={(val) => {
        setContent(val);
        // Detect slash commands
        if (val && editorRef) {
          // This is simplified - real implementation would need cursor position
          slashCommands.handleTextChange(val, val.length, editorRef);
        }
      }}
      preview={previewMode === 'edit' ? 'edit' : previewMode === 'preview' ? 'preview' : 'live'}
      hideToolbar={false}
      height={400}
      data-color-mode={theme === 'NeXTSTEP' ? 'light' : 'light'}
      ref={(ref) => setEditorRef(ref?.editor || null)}
    />
    ```

    7. Add template selection handler:
    ```tsx
    const handleTemplateSelect = useCallback(async (template: NotebookTemplate) => {
      try {
        // Create new card from template
        const newCard = await createCard(template.cardType, template.id);

        // Update with template content
        await updateCard(newCard.id, {
          markdownContent: template.defaultMarkdown,
          properties: template.defaultProperties
        });

        setShowTemplateManager(false);
      } catch (error) {
        console.error('Failed to create card from template:', error);
      }
    }, [createCard, updateCard]);
    ```

    8. Add slash command menu and template manager at the end of the component:
    ```tsx
    {/* Slash Command Menu */}
    <SlashCommandMenu
      isOpen={slashCommands.isMenuOpen}
      position={slashCommands.menuPosition}
      patterns={slashCommands.filteredPatterns}
      selectedIndex={slashCommands.selectedIndex}
      onSelect={slashCommands.selectPattern}
      onClose={() => slashCommands.handleTextChange('', 0)} // Close menu
    />

    {/* Template Manager */}
    <TemplateManager
      isOpen={showTemplateManager}
      onClose={() => setShowTemplateManager(false)}
      onSelectTemplate={handleTemplateSelect}
    />
    ```

    This integration provides seamless slash command functionality and template management within the capture component.
  </action>
  <verify>Slash commands trigger when typing '/' and templates can be created/selected</verify>
  <done>CaptureComponent integrates slash commands and template management for enhanced content creation</done>
</task>

</tasks>

<verification>
1. Run `npm run typecheck` to verify TypeScript compilation
2. Start development server and navigate to notebook mode
3. Create a new card and verify:
   - Typing '/' triggers slash command menu with DSL patterns
   - Arrow keys navigate menu, Enter selects pattern
   - Selected patterns insert into editor with proper formatting
   - Template button opens template manager
   - Can create templates from current card content
   - Can select templates to create new cards
   - Field editor appears for patterns requiring user input
   - All patterns from different categories (PAFV, LATCH, Graph, etc.) are available
4. Test keyboard shortcuts:
   - Ctrl/Cmd+S saves manually
   - Escape closes slash command menu
   - Enter in field editor completes pattern insertion
</verification>

<success_criteria>
1. User can trigger slash commands by typing '/' in markdown editor
2. User can navigate and select from categorized DSL patterns via keyboard or mouse
3. User can insert Isometry DSL patterns (PAFV, LATCH, Graph, Query, Structure) with field completion
4. User can create card templates from current content
5. User can select templates to create new cards with pre-filled content
6. User can save custom templates for reuse across sessions
7. Slash command system integrates seamlessly with existing editor workflow
</success_criteria>

<output>
After completion, create `.planning/phases/02-capture-implementation/02-03-SUMMARY.md`
</output>