---
phase: 02-capture-implementation
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified: [
  "src/components/notebook/CaptureComponent.tsx",
  "src/components/notebook/PropertyEditor.tsx",
  "src/hooks/usePropertyEditor.ts"
]
autonomous: true

must_haves:
  truths:
    - "User can add custom properties through an intuitive JSON editor"
    - "User can edit property values with proper type validation"
    - "User can remove properties and see changes persist immediately"
  artifacts:
    - path: "src/components/notebook/PropertyEditor.tsx"
      provides: "JSON property editor component"
      min_lines: 80
      exports: ["PropertyEditor"]
    - path: "src/hooks/usePropertyEditor.ts"
      provides: "Property management state hook"
      exports: ["usePropertyEditor"]
    - path: "src/components/notebook/CaptureComponent.tsx"
      provides: "Enhanced properties panel"
      contains: "PropertyEditor"
  key_links:
    - from: "src/components/notebook/PropertyEditor.tsx"
      to: "src/hooks/usePropertyEditor.ts"
      via: "hook usage"
      pattern: "usePropertyEditor"
    - from: "src/hooks/usePropertyEditor.ts"
      to: "NotebookContext"
      via: "updateCard with properties"
      pattern: "updateCard.*properties"
---

<objective>
Replace the basic properties panel with a sophisticated property editor that allows users to add, edit, and remove custom properties on notebook cards with JSON validation and immediate persistence.

Purpose: Enable rich metadata management for notebook cards, allowing users to add custom properties like tags, status, priority, or any structured data needed for their workflow.
Output: Interactive property editor with add/remove/edit capabilities and real-time persistence to database.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/02-capture-implementation/02-01-PLAN.md
@src/components/notebook/CaptureComponent.tsx
@src/contexts/NotebookContext.tsx
@src/types/notebook.ts
</context>

<tasks>

<task type="auto">
  <name>Create property editor state hook</name>
  <files>src/hooks/usePropertyEditor.ts</files>
  <action>
    Create a hook that manages property editing state and validation:

    ```typescript
    import { useState, useCallback, useEffect } from 'react';
    import { useNotebook } from '../contexts/NotebookContext';
    import type { NotebookCardProperties } from '../types/notebook';

    interface UsePropertyEditorOptions {
      autoSaveDelay?: number;
    }

    export function usePropertyEditor(options: UsePropertyEditorOptions = {}) {
      const { autoSaveDelay = 1500 } = options;
      const { activeCard, updateCard } = useNotebook();
      const [properties, setProperties] = useState<NotebookCardProperties>({});
      const [editingProperty, setEditingProperty] = useState<string | null>(null);
      const [newPropertyKey, setNewPropertyKey] = useState('');
      const [newPropertyValue, setNewPropertyValue] = useState('');
      const [validationErrors, setValidationErrors] = useState<Record<string, string>>({});
      const [isDirty, setIsDirty] = useState(false);

      // Sync with active card
      useEffect(() => {
        if (activeCard?.properties) {
          setProperties(activeCard.properties);
          setIsDirty(false);
          setValidationErrors({});
        } else {
          setProperties({});
          setIsDirty(false);
          setValidationErrors({});
        }
        setEditingProperty(null);
        setNewPropertyKey('');
        setNewPropertyValue('');
      }, [activeCard?.id]);

      // Validate property key
      const validatePropertyKey = useCallback((key: string): string | null => {
        if (!key.trim()) {
          return 'Property key cannot be empty';
        }
        if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(key)) {
          return 'Property key must start with letter/underscore and contain only letters, numbers, and underscores';
        }
        if (properties.hasOwnProperty(key)) {
          return 'Property key already exists';
        }
        return null;
      }, [properties]);

      // Validate property value (try to parse as JSON if string)
      const validatePropertyValue = useCallback((value: string): { isValid: boolean; parsedValue: any; error?: string } => {
        // If empty, return string
        if (!value.trim()) {
          return { isValid: true, parsedValue: '' };
        }

        // Try to parse as JSON for complex types
        if (value.startsWith('{') || value.startsWith('[') || value === 'null' || value === 'true' || value === 'false' || !isNaN(Number(value))) {
          try {
            const parsed = JSON.parse(value);
            return { isValid: true, parsedValue: parsed };
          } catch (e) {
            return { isValid: false, parsedValue: value, error: 'Invalid JSON format' };
          }
        }

        // Return as string
        return { isValid: true, parsedValue: value };
      }, []);

      // Save properties to database
      const saveProperties = useCallback(async (newProperties: NotebookCardProperties) => {
        if (!activeCard?.id) return;

        try {
          await updateCard(activeCard.id, {
            properties: Object.keys(newProperties).length > 0 ? newProperties : null
          });
          setIsDirty(false);
        } catch (error) {
          console.error('Failed to save properties:', error);
          throw error;
        }
      }, [activeCard?.id, updateCard]);

      // Add new property
      const addProperty = useCallback(async () => {
        const keyError = validatePropertyKey(newPropertyKey);
        if (keyError) {
          setValidationErrors(prev => ({ ...prev, newKey: keyError }));
          return;
        }

        const { isValid, parsedValue, error } = validatePropertyValue(newPropertyValue);
        if (!isValid) {
          setValidationErrors(prev => ({ ...prev, newValue: error || 'Invalid value' }));
          return;
        }

        const newProperties = {
          ...properties,
          [newPropertyKey]: parsedValue
        };

        setProperties(newProperties);
        setNewPropertyKey('');
        setNewPropertyValue('');
        setValidationErrors({});
        setIsDirty(true);

        // Auto-save
        setTimeout(() => saveProperties(newProperties), autoSaveDelay);
      }, [newPropertyKey, newPropertyValue, properties, validatePropertyKey, validatePropertyValue, saveProperties, autoSaveDelay]);

      // Update existing property
      const updateProperty = useCallback(async (key: string, value: string) => {
        const { isValid, parsedValue, error } = validatePropertyValue(value);
        if (!isValid) {
          setValidationErrors(prev => ({ ...prev, [key]: error || 'Invalid value' }));
          return;
        }

        const newProperties = {
          ...properties,
          [key]: parsedValue
        };

        setProperties(newProperties);
        setValidationErrors(prev => {
          const updated = { ...prev };
          delete updated[key];
          return updated;
        });
        setIsDirty(true);

        // Auto-save
        setTimeout(() => saveProperties(newProperties), autoSaveDelay);
      }, [properties, validatePropertyValue, saveProperties, autoSaveDelay]);

      // Delete property
      const deleteProperty = useCallback(async (key: string) => {
        const newProperties = { ...properties };
        delete newProperties[key];

        setProperties(newProperties);
        setIsDirty(true);

        // Auto-save
        setTimeout(() => saveProperties(newProperties), autoSaveDelay);
      }, [properties, saveProperties, autoSaveDelay]);

      // Start editing property
      const startEditing = useCallback((key: string) => {
        setEditingProperty(key);
        setValidationErrors(prev => {
          const updated = { ...prev };
          delete updated[key];
          return updated;
        });
      }, []);

      // Cancel editing
      const cancelEditing = useCallback(() => {
        setEditingProperty(null);
        setValidationErrors(prev => {
          const updated = { ...prev };
          if (editingProperty) {
            delete updated[editingProperty];
          }
          return updated;
        });
      }, [editingProperty]);

      return {
        properties,
        editingProperty,
        newPropertyKey,
        setNewPropertyKey,
        newPropertyValue,
        setNewPropertyValue,
        validationErrors,
        isDirty,
        addProperty,
        updateProperty,
        deleteProperty,
        startEditing,
        cancelEditing,
        saveNow: () => saveProperties(properties)
      };
    }
    ```

    This hook provides comprehensive property management with validation, auto-save, and proper error handling.
  </action>
  <verify>TypeScript compilation passes and hook exports usePropertyEditor function</verify>
  <done>usePropertyEditor hook provides property CRUD operations with validation and auto-save</done>
</task>

<task type="auto">
  <name>Create property editor component</name>
  <files>src/components/notebook/PropertyEditor.tsx</files>
  <action>
    Create a sophisticated property editor component:

    ```tsx
    import { useState, useRef, useEffect } from 'react';
    import { Plus, Edit2, Check, X, Trash2, AlertCircle } from 'lucide-react';
    import { usePropertyEditor } from '../../hooks/usePropertyEditor';
    import { useTheme } from '../../contexts/ThemeContext';

    interface PropertyEditorProps {
      className?: string;
    }

    export function PropertyEditor({ className }: PropertyEditorProps) {
      const { theme } = useTheme();
      const {
        properties,
        editingProperty,
        newPropertyKey,
        setNewPropertyKey,
        newPropertyValue,
        setNewPropertyValue,
        validationErrors,
        isDirty,
        addProperty,
        updateProperty,
        deleteProperty,
        startEditing,
        cancelEditing
      } = usePropertyEditor();

      const [showAddForm, setShowAddForm] = useState(false);
      const [editingValue, setEditingValue] = useState('');
      const addKeyInputRef = useRef<HTMLInputElement>(null);
      const editInputRef = useRef<HTMLInputElement>(null);

      // Focus on add form when shown
      useEffect(() => {
        if (showAddForm && addKeyInputRef.current) {
          addKeyInputRef.current.focus();
        }
      }, [showAddForm]);

      // Focus on edit input when editing starts
      useEffect(() => {
        if (editingProperty && editInputRef.current) {
          const currentValue = properties[editingProperty];
          setEditingValue(typeof currentValue === 'string' ? currentValue : JSON.stringify(currentValue, null, 2));
          editInputRef.current.focus();
        }
      }, [editingProperty, properties]);

      const handleAddSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        try {
          await addProperty();
          setShowAddForm(false);
        } catch (error) {
          console.error('Failed to add property:', error);
        }
      };

      const handleEditSubmit = async () => {
        if (!editingProperty) return;
        try {
          await updateProperty(editingProperty, editingValue);
          cancelEditing();
        } catch (error) {
          console.error('Failed to update property:', error);
        }
      };

      const handleKeyDown = (e: React.KeyboardEvent, action: 'add' | 'edit') => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          if (action === 'add') {
            handleAddSubmit(e);
          } else {
            handleEditSubmit();
          }
        } else if (e.key === 'Escape') {
          if (action === 'add') {
            setShowAddForm(false);
            setNewPropertyKey('');
            setNewPropertyValue('');
          } else {
            cancelEditing();
          }
        }
      };

      const renderPropertyValue = (value: any): string => {
        if (typeof value === 'string') {
          return value;
        }
        return JSON.stringify(value, null, 2);
      };

      const getValueTypeIndicator = (value: any): string => {
        if (value === null) return 'null';
        if (Array.isArray(value)) return 'array';
        return typeof value;
      };

      return (
        <div className={`${className || ''}`}>
          {/* Properties List */}
          <div className="space-y-2 max-h-40 overflow-y-auto">
            {Object.entries(properties).map(([key, value]) => (
              <div
                key={key}
                className={`p-2 rounded border ${theme === 'NeXTSTEP' ? 'border-[#707070] bg-white' : 'border-gray-200 bg-gray-50'}`}
              >
                {/* Property Key */}
                <div className="flex items-center justify-between mb-1">
                  <div className="flex items-center gap-2">
                    <span className="font-mono text-xs font-medium">{key}</span>
                    <span className={`text-xs px-1 rounded ${theme === 'NeXTSTEP' ? 'bg-[#d4d4d4] text-gray-700' : 'bg-gray-200 text-gray-600'}`}>
                      {getValueTypeIndicator(value)}
                    </span>
                  </div>
                  <div className="flex items-center gap-1">
                    <button
                      onClick={() => startEditing(key)}
                      className={`p-1 rounded hover:${theme === 'NeXTSTEP' ? 'bg-[#b0b0b0]' : 'bg-gray-200'} transition-colors`}
                      title="Edit property"
                    >
                      <Edit2 size={12} className="text-gray-600" />
                    </button>
                    <button
                      onClick={() => deleteProperty(key)}
                      className={`p-1 rounded hover:bg-red-100 transition-colors`}
                      title="Delete property"
                    >
                      <Trash2 size={12} className="text-red-500" />
                    </button>
                  </div>
                </div>

                {/* Property Value */}
                {editingProperty === key ? (
                  <div className="space-y-1">
                    <textarea
                      ref={editInputRef}
                      value={editingValue}
                      onChange={(e) => setEditingValue(e.target.value)}
                      onKeyDown={(e) => handleKeyDown(e, 'edit')}
                      className={`w-full text-xs font-mono p-1 border rounded resize-y min-h-[60px] ${theme === 'NeXTSTEP' ? 'border-[#707070]' : 'border-gray-300'}`}
                      placeholder="Enter value (string or JSON)"
                    />
                    {validationErrors[key] && (
                      <div className="flex items-center gap-1 text-red-500 text-xs">
                        <AlertCircle size={12} />
                        {validationErrors[key]}
                      </div>
                    )}
                    <div className="flex items-center gap-1">
                      <button
                        onClick={handleEditSubmit}
                        className={`p-1 rounded hover:bg-green-100 transition-colors`}
                        title="Save changes"
                      >
                        <Check size={12} className="text-green-600" />
                      </button>
                      <button
                        onClick={cancelEditing}
                        className={`p-1 rounded hover:bg-red-100 transition-colors`}
                        title="Cancel"
                      >
                        <X size={12} className="text-red-500" />
                      </button>
                      <span className="text-xs text-gray-500 ml-2">Enter to save, Esc to cancel</span>
                    </div>
                  </div>
                ) : (
                  <div className={`text-xs font-mono p-1 rounded ${theme === 'NeXTSTEP' ? 'bg-gray-100' : 'bg-white'} border`}>
                    <pre className="whitespace-pre-wrap break-words">{renderPropertyValue(value)}</pre>
                  </div>
                )}
              </div>
            ))}

            {Object.keys(properties).length === 0 && !showAddForm && (
              <div className="text-center py-4 text-gray-500 text-xs">
                No properties yet. Click + to add one.
              </div>
            )}
          </div>

          {/* Add Property Form */}
          {showAddForm ? (
            <form onSubmit={handleAddSubmit} className="mt-3 space-y-2">
              <div>
                <input
                  ref={addKeyInputRef}
                  type="text"
                  value={newPropertyKey}
                  onChange={(e) => setNewPropertyKey(e.target.value)}
                  onKeyDown={(e) => handleKeyDown(e, 'add')}
                  placeholder="Property key (e.g., status, priority)"
                  className={`w-full text-xs p-1 border rounded font-mono ${theme === 'NeXTSTEP' ? 'border-[#707070]' : 'border-gray-300'}`}
                />
                {validationErrors.newKey && (
                  <div className="flex items-center gap-1 text-red-500 text-xs mt-1">
                    <AlertCircle size={12} />
                    {validationErrors.newKey}
                  </div>
                )}
              </div>
              <div>
                <textarea
                  value={newPropertyValue}
                  onChange={(e) => setNewPropertyValue(e.target.value)}
                  onKeyDown={(e) => handleKeyDown(e, 'add')}
                  placeholder='Value (string or JSON, e.g., "active", 42, {"completed": true})'
                  className={`w-full text-xs font-mono p-1 border rounded resize-y min-h-[40px] ${theme === 'NeXTSTEP' ? 'border-[#707070]' : 'border-gray-300'}`}
                />
                {validationErrors.newValue && (
                  <div className="flex items-center gap-1 text-red-500 text-xs mt-1">
                    <AlertCircle size={12} />
                    {validationErrors.newValue}
                  </div>
                )}
              </div>
              <div className="flex items-center gap-2">
                <button
                  type="submit"
                  className={`flex items-center gap-1 px-2 py-1 rounded text-xs hover:bg-green-100 transition-colors`}
                >
                  <Check size={12} className="text-green-600" />
                  Add
                </button>
                <button
                  type="button"
                  onClick={() => {
                    setShowAddForm(false);
                    setNewPropertyKey('');
                    setNewPropertyValue('');
                  }}
                  className={`flex items-center gap-1 px-2 py-1 rounded text-xs hover:bg-red-100 transition-colors`}
                >
                  <X size={12} className="text-red-500" />
                  Cancel
                </button>
                <span className="text-xs text-gray-500">Enter to add, Esc to cancel</span>
              </div>
            </form>
          ) : (
            /* Add Property Button */
            <button
              onClick={() => setShowAddForm(true)}
              className={`w-full mt-3 flex items-center justify-center gap-1 p-2 border-2 border-dashed rounded hover:${theme === 'NeXTSTEP' ? 'bg-[#b0b0b0]' : 'bg-gray-100'} transition-colors ${theme === 'NeXTSTEP' ? 'border-[#707070] text-gray-600' : 'border-gray-300 text-gray-500'}`}
            >
              <Plus size={14} />
              <span className="text-xs">Add Property</span>
              {isDirty && <div className="ml-1 w-2 h-2 bg-orange-500 rounded-full" title="Unsaved changes" />}
            </button>
          )}
        </div>
      );
    }
    ```

    This component provides:
    - Visual property list with type indicators
    - Inline editing with validation feedback
    - Add new properties with form validation
    - Delete properties with confirmation
    - JSON value support with syntax highlighting
    - Keyboard shortcuts (Enter/Escape)
    - Theme support
  </action>
  <verify>Component renders and allows property management operations</verify>
  <done>PropertyEditor component provides full CRUD interface for card properties</done>
</task>

<task type="auto">
  <name>Integrate property editor into capture component</name>
  <files>src/components/notebook/CaptureComponent.tsx</files>
  <action>
    Replace the basic properties panel in CaptureComponent with the new PropertyEditor component:

    1. Import PropertyEditor:
    ```tsx
    import { PropertyEditor } from './PropertyEditor';
    ```

    2. Remove the basic properties form and replace with PropertyEditor in the properties panel section:

    ```tsx
    {/* Properties Panel */}
    <div className={`border-t ${theme === 'NeXTSTEP' ? 'border-[#707070] bg-[#d4d4d4]' : 'border-gray-200 bg-gray-50'}`}>
      <button
        onClick={() => setPropertiesExpanded(!propertiesExpanded)}
        className={`w-full flex items-center justify-between p-2 hover:${theme === 'NeXTSTEP' ? 'bg-[#b0b0b0]' : 'bg-gray-100'} transition-colors`}
      >
        <span className="text-sm font-medium">Properties</span>
        {propertiesExpanded ? (
          <ChevronDown size={14} className="text-gray-600" />
        ) : (
          <ChevronRight size={14} className="text-gray-600" />
        )}
      </button>

      {propertiesExpanded && (
        <div className="p-3">
          {activeCard ? (
            <PropertyEditor />
          ) : (
            <div className="text-center py-4 text-gray-500 text-xs">
              No card selected
            </div>
          )}
        </div>
      )}
    </div>
    ```

    3. Remove the old hardcoded property fields (card type, node ID, created, modified) - these are now handled by the PropertyEditor or can be shown as read-only metadata if needed.

    4. Add keyboard shortcut for saving (Ctrl+S / Cmd+S) in the keyboard event handler:

    ```tsx
    // In the keyboard shortcuts useEffect, add:
    case 's':
      if (event.metaKey || event.ctrlKey) {
        event.preventDefault();
        handleManualSave();
      }
      break;
    ```

    5. Update the header to show property count when properties exist:

    ```tsx
    <span className="font-medium text-sm">
      {activeCard ? (
        <>
          Card: {activeCard.nodeId.slice(0, 8)}...
          {activeCard.properties && Object.keys(activeCard.properties).length > 0 && (
            <span className="ml-2 text-xs bg-blue-100 text-blue-700 px-1 rounded">
              {Object.keys(activeCard.properties).length} props
            </span>
          )}
        </>
      ) : 'No Active Card'}
    </span>
    ```

    This integration provides a much more powerful property management system while maintaining the clean UI design.
  </action>
  <verify>PropertyEditor renders in the properties panel and allows property management</verify>
  <done>CaptureComponent uses PropertyEditor for enhanced property management capabilities</done>
</task>

</tasks>

<verification>
1. Run `npm run typecheck` to verify TypeScript compilation
2. Start development server and navigate to notebook mode
3. Create a new card and verify:
   - Properties panel can be expanded/collapsed
   - "Add Property" button shows form with key/value inputs
   - Can add properties with different types (strings, numbers, JSON objects)
   - Property validation works (invalid keys/JSON show errors)
   - Can edit existing properties inline
   - Can delete properties
   - Properties persist after editing
   - Keyboard shortcuts work (Enter to save, Esc to cancel)
   - Property count shows in header when properties exist
</verification>

<success_criteria>
1. User can add custom properties through an intuitive interface
2. User can edit property values with proper JSON validation and type indicators
3. User can remove properties and changes persist immediately
4. Property editor handles different data types (strings, numbers, objects, arrays)
5. Validation prevents invalid property keys and malformed JSON values
6. Keyboard shortcuts enhance workflow efficiency
7. UI shows property count and visual indicators for unsaved changes
</success_criteria>

<output>
After completion, create `.planning/phases/02-capture-implementation/02-02-SUMMARY.md`
</output>