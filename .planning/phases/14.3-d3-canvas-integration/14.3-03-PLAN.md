---
phase: 14.3-d3-canvas-integration
plan: 03
type: execute
wave: 2
depends_on: ["14.3-01", "14.3-02"]
files_modified: [
  "src/components/views/D3ListView.tsx",
  "src/components/views/D3GridView.tsx",
  "native/Sources/Isometry/Rendering/HybridRenderingEngine.swift"
]
autonomous: false

must_haves:
  truths:
    - "All major D3 view components support native rendering with feature parity"
    - "Hybrid rendering intelligently chooses optimal renderer per element type"
    - "Performance gains are validated across real-world usage scenarios"
    - "User experience is seamless regardless of rendering backend"
  artifacts:
    - path: "native/Sources/Isometry/Rendering/HybridRenderingEngine.swift"
      provides: "Intelligent hybrid rendering system choosing optimal renderer per element"
      exports: ["HybridRenderingEngine", "RenderingStrategy", "ElementClassifier"]
    - path: "src/components/views/D3ListView.tsx"
      provides: "Enhanced D3ListView with native rendering integration"
      exports: ["D3ListView with native support"]
    - path: "src/components/views/D3GridView.tsx"
      provides: "Enhanced D3GridView with hybrid rendering optimization"
      exports: ["D3GridView with hybrid support"]
  key_links:
    - from: "HybridRenderingEngine.swift"
      to: "D3CanvasMessageHandler.renderCommands"
      via: "intelligent command routing"
      pattern: "handler.*renderCommands"
    - from: "D3ListView.tsx"
      to: "D3NativeBridge.sendRenderCommands"
      via: "view-specific optimization"
      pattern: "bridge.*sendRenderCommands"
---

<objective>
Complete D3-Canvas integration by implementing hybrid rendering system across all major D3 view components, with intelligent per-element renderer selection and comprehensive performance validation in real-world scenarios.

Purpose: Finalize the D3-native rendering enhancement by ensuring all visualization components can leverage native performance while maintaining development simplicity and visual consistency.
Output: Production-ready hybrid D3 rendering system with validated performance improvements and seamless user experience across all view types.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/14.3-d3-canvas-integration/14.3-01-PLAN.md
@.planning/phases/14.3-d3-canvas-integration/14.3-02-PLAN.md
@src/components/views/D3ListView.tsx
@src/components/views/D3GridView.tsx
@src/d3/D3View.tsx
@src/d3/components/D3ViewWrapper.tsx
</context>

<tasks>

<task type="auto">
  <name>Create Hybrid Rendering Engine</name>
  <files>native/Sources/Isometry/Rendering/HybridRenderingEngine.swift</files>
  <action>
    Create HybridRenderingEngine.swift for intelligent element-level rendering decisions:
    - Actor-based hybrid engine analyzing render commands for optimal routing
    - ElementClassifier: analyze command complexity, size, and type for renderer selection
    - RenderingStrategy enum: Native, DOM, Hybrid with decision criteria
    - Performance-based learning: track which renderer performs better for element types
    - Memory pressure adaptation: fallback to simpler rendering under constraints
    - Batch optimization: group similar elements for same renderer to reduce overhead

    Decision criteria for renderer selection:
    - Complex paths/gradients → Native renderer (GPU acceleration)
    - Simple shapes at scale → Native renderer (batching efficiency)
    - Text-heavy content → DOM renderer (font rendering quality)
    - Interactive elements → DOM renderer (event handling complexity)
    - Large datasets → Native with LOD, small datasets → DOM for simplicity

    Integration with existing performance monitoring and coordinate transformation systems.
  </action>
  <verify>Swift compilation succeeds and hybrid engine makes reasonable routing decisions</verify>
  <done>Hybrid rendering engine intelligently routes render commands to optimal renderer based on element characteristics</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete D3-Canvas integration system with native rendering, performance optimization, and hybrid routing across D3ListView and D3GridView components</what-built>
  <how-to-verify>
    1. Open Isometry app in development mode
    2. Navigate to D3 visualizations section
    3. Load dataset with 1000+ nodes in D3GridView
    4. Toggle native rendering on/off and observe:
       - Performance difference (check performance overlay)
       - Visual consistency (compare DOM vs native output)
       - Gesture responsiveness (pan/zoom smoothness)
       - Memory usage (check Activity Monitor)
    5. Switch between D3ListView and D3GridView
    6. Test rapid view switching and dataset changes
    7. Verify performance monitoring shows:
       - Measurable improvement with native rendering
       - Stable memory usage across renderer switches
       - Appropriate renderer selection in hybrid mode
    8. Test edge cases:
       - Very large datasets (5000+ nodes)
       - Rapid pan/zoom operations
       - Background/foreground app switching
       - Low memory conditions
  </how-to-verify>
  <resume-signal>Type "approved" with performance validation results, or describe any issues that need addressing</resume-signal>
</task>

</tasks>

<verification>
Comprehensive D3-Canvas integration validation:
1. Performance benchmarks show target 2x improvement for large datasets
2. Visual consistency maintained across all renderer modes
3. Gesture coordination works seamlessly
4. Memory usage remains stable during extended usage
5. All D3 view components support native rendering
6. Hybrid engine makes intelligent routing decisions
7. Error handling provides graceful fallbacks
8. Performance monitoring captures actionable metrics
</verification>

<success_criteria>
1. All major D3 view components (ListView, GridView) support native rendering
2. Hybrid rendering engine provides intelligent per-element optimization
3. Performance improvements validated in real-world scenarios (target: 2x faster)
4. User experience remains seamless regardless of rendering backend
5. Memory usage optimized with stable performance across view switching
6. Comprehensive error handling and fallback mechanisms
7. Performance monitoring provides actionable insights for further optimization
8. Zero breaking changes to existing D3 component APIs
9. Production-ready code quality with comprehensive testing coverage
</success_criteria>

<output>
After completion, create `.planning/phases/14.3-d3-canvas-integration/14.3-03-SUMMARY.md`
</output>