---
phase: 14.3-d3-canvas-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [
  "native/Sources/Isometry/WebView/D3CanvasMessageHandler.swift",
  "native/Sources/Isometry/Rendering/NativeCanvasRenderer.swift",
  "src/utils/d3-native-bridge.ts",
  "src/components/D3Canvas.tsx",
  "src/hooks/useD3Canvas.ts",
  "native/Sources/Isometry/WebView/WebViewBridge.swift"
]
autonomous: true

must_haves:
  truths:
    - "D3 visualizations can opt-in to native Canvas rendering for performance boost"
    - "React D3 components seamlessly switch between DOM/Canvas and native rendering"
    - "Native rendering maintains visual fidelity with React D3 output"
    - "Performance improvements are measurable (target: 2x faster for 1000+ nodes)"
  artifacts:
    - path: "native/Sources/Isometry/WebView/D3CanvasMessageHandler.swift"
      provides: "WebView bridge handler for D3 canvas rendering commands"
      exports: ["handleRenderCommands", "handleCanvasUpdate"]
    - path: "native/Sources/Isometry/Rendering/NativeCanvasRenderer.swift"
      provides: "Native Canvas/Core Graphics renderer for D3 visualizations"
      exports: ["CanvasRenderEngine", "D3RenderCommand"]
    - path: "src/utils/d3-native-bridge.ts"
      provides: "React bridge client for D3-native communication"
      exports: ["D3NativeBridge", "RenderCommand", "CanvasCapabilities"]
  key_links:
    - from: "src/components/D3Canvas.tsx"
      to: "D3NativeBridge.sendRenderCommands"
      via: "useD3Canvas hook integration"
      pattern: "bridge\\.sendRenderCommands"
    - from: "D3CanvasMessageHandler.swift"
      to: "NativeCanvasRenderer.render"
      via: "Swift actor-based rendering"
      pattern: "await.*renderer\\.render"
---

<objective>
Create native Canvas rendering capabilities for D3 visualizations, enabling React D3 components to leverage native Core Graphics/Metal performance while maintaining seamless fallback to DOM/Canvas rendering.

Purpose: Enhance D3 visualization performance for large datasets by offloading rendering to native graphics APIs, while preserving the existing React D3 development workflow and visual consistency.
Output: Bidirectional bridge enabling D3 components to send render commands to native Canvas renderer with automatic capability detection and fallback.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-pafv-integration/14-01-SUMMARY.md
@src/components/D3Canvas.tsx
@src/hooks/useD3Canvas.ts
@native/Sources/Isometry/WebView/WebViewBridge.swift
@native/Sources/Isometry/WebView/PAFVMessageHandler.swift
</context>

<tasks>

<task type="auto">
  <name>Create D3 Canvas Message Handler</name>
  <files>native/Sources/Isometry/WebView/D3CanvasMessageHandler.swift</files>
  <action>
    Create D3CanvasMessageHandler.swift following PAFVMessageHandler patterns:
    - Actor-based message handler for WebView bridge communication
    - Handle "renderCommands" message type with D3 render command arrays
    - Handle "canvasUpdate" message type for viewport/state synchronization
    - Sequence ID tracking for message ordering (like PAFV handler)
    - Performance monitoring with render latency tracking
    - Type-safe parameter parsing with comprehensive error handling
    - Integration with NativeCanvasRenderer via async calls
    - Debounced updates to prevent flooding (60fps max frequency)

    Message types:
    - renderCommands: Array of render commands (shapes, paths, text)
    - canvasUpdate: Viewport changes (zoom, pan, dimensions)
    - getCapabilities: Query native rendering capabilities

    Follow Swift 6 concurrency patterns and actor isolation like existing handlers.
  </action>
  <verify>Swift compilation succeeds with no warnings for new handler</verify>
  <done>D3CanvasMessageHandler.swift handles D3 render command messages with sequence tracking and error handling</done>
</task>

<task type="auto">
  <name>Create Native Canvas Renderer Engine</name>
  <files>native/Sources/Isometry/Rendering/NativeCanvasRenderer.swift</files>
  <action>
    Create NativeCanvasRenderer.swift with Core Graphics/SwiftUI Canvas integration:
    - Actor-based renderer for thread-safe rendering operations
    - D3RenderCommand protocol supporting: circles, rectangles, paths, text, gradients
    - CanvasRenderEngine class with render(commands: [D3RenderCommand]) async method
    - Viewport transformation matrix for zoom/pan consistency with React
    - Performance optimization: batched rendering, GPU acceleration hints
    - Memory management: render command caching and cleanup
    - SwiftUI Canvas integration for UIKit/AppKit compatibility
    - Color space management for consistent colors across platforms
    - Text rendering with font fallbacks and proper metrics

    Render command types:
    - Circle: center, radius, fill, stroke
    - Rectangle: bounds, fill, stroke, corner radius
    - Path: SVG-like path data, fill, stroke
    - Text: content, position, font, color, alignment
    - Group: transform matrix, child commands

    Follow established patterns from SuperGrid rendering architecture.
  </action>
  <verify>Swift compilation succeeds and basic render test passes</verify>
  <done>NativeCanvasRenderer renders D3 commands to native Canvas with performance optimization</done>
</task>

<task type="auto">
  <name>Create React D3 Native Bridge Client</name>
  <files>src/utils/d3-native-bridge.ts, src/components/D3Canvas.tsx, src/hooks/useD3Canvas.ts</files>
  <action>
    Create d3-native-bridge.ts following PAFVBridge patterns:
    - D3NativeBridge class with capability detection and message queuing
    - sendRenderCommands(commands: RenderCommand[]) with debouncing
    - sendCanvasUpdate(viewport: Viewport) for synchronization
    - getCapabilities() to query native rendering features
    - Performance monitoring with render latency tracking
    - Error boundaries and graceful fallback to DOM rendering
    - TypeScript strict mode compliance with proper command types

    Enhance D3Canvas.tsx:
    - Add native rendering opt-in prop (useNativeRendering?: boolean)
    - Integrate D3NativeBridge in render pipeline
    - Maintain existing Canvas/DOM rendering as fallback
    - Convert D3 render commands to native command format
    - Handle bridge availability with graceful degradation

    Update useD3Canvas.ts:
    - Add native bridge integration option
    - Expose native rendering capability state
    - Track performance metrics for native vs DOM rendering
    - Handle renderer switching without state loss

    Ensure zero breaking changes to existing D3Canvas usage.
  </action>
  <verify>npm run build succeeds and existing D3Canvas tests pass</verify>
  <done>React D3Canvas supports optional native rendering with automatic fallback and performance monitoring</done>
</task>

</tasks>

<verification>
Test native D3 rendering integration:
1. npm run build - React build succeeds
2. Swift build - Native project compiles
3. D3Canvas component renders with useNativeRendering=false (DOM fallback)
4. Bridge capability detection works when native not available
5. Performance monitoring shows baseline metrics
</verification>

<success_criteria>
1. D3Canvas component has opt-in native rendering capability
2. Bridge communication established between React D3 and native renderer
3. Render commands successfully convert from D3 to native format
4. Performance monitoring infrastructure tracks native vs DOM metrics
5. Graceful fallback maintains existing functionality when native unavailable
6. Zero breaking changes to existing D3 visualization components
7. Swift compilation clean with actor-based concurrency patterns
8. TypeScript strict mode compliance throughout React integration
</success_criteria>

<output>
After completion, create `.planning/phases/14.3-d3-canvas-integration/14.3-01-SUMMARY.md`
</output>