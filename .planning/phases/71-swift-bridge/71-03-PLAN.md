---
phase: 71-swift-bridge
plan: 03
type: execute
wave: 2
depends_on: [71-01]
files_modified:
  - native/Sources/Isometry/Adapters/ContactsAdapter.swift
  - native/Sources/Isometry/Adapters/NotesAdapter.swift
  - native/Tests/IsometryTests/Adapters/ContactsAdapterTests.swift
  - native/Tests/IsometryTests/Adapters/NotesAdapterTests.swift
autonomous: true
user_setup:
  - service: Contacts
    why: "Contacts access for person nodes"
    dashboard_config:
      - task: "Grant Contacts access when prompted"
        location: "iOS Settings > Privacy > Contacts > Isometry"

must_haves:
  truths:
    - "ContactsAdapter can fetch contacts and convert to CanonicalNode"
    - "NotesAdapter delegates alto-index file parsing to ETLBridge"
    - "Contact names handle empty first/last names gracefully"
    - "Notes adapter uses existing alto-importer via JS bridge"
  artifacts:
    - path: "native/Sources/Isometry/Adapters/ContactsAdapter.swift"
      provides: "CNContactStore to CanonicalNode converter"
      exports: ["ContactsAdapter", "fetchContacts"]
    - path: "native/Sources/Isometry/Adapters/NotesAdapter.swift"
      provides: "Alto-index file delegation to JS ETL"
      exports: ["NotesAdapter", "importNotesExport"]
  key_links:
    - from: "native/Sources/Isometry/Adapters/ContactsAdapter.swift"
      to: "CNContactStore"
      via: "requestAccess(for:) async API"
      pattern: "requestAccess.*contacts"
    - from: "native/Sources/Isometry/Adapters/NotesAdapter.swift"
      to: "ETLBridge"
      via: "File delegation for markdown parsing"
      pattern: "etlBridge\\.importFile"
---

<objective>
Create ContactsAdapter and NotesAdapter for remaining native framework integrations.

Purpose: Complete native framework coverage. ContactsAdapter provides direct CNContactStore access; NotesAdapter delegates alto-index markdown files to ETLBridge for JavaScript parsing (avoids duplicating gray-matter in Swift).

Output: Both adapters producing CanonicalNode arrays, completing BRIDGE-02 requirement.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/71-swift-bridge/71-RESEARCH.md

# ETLBridge from 71-01
@.planning/phases/71-swift-bridge/71-01-PLAN.md

# Existing patterns
@native/Sources/Isometry/Import/SQLiteFileImporter.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ContactsAdapter actor</name>
  <files>native/Sources/Isometry/Adapters/ContactsAdapter.swift</files>
  <action>
Create ContactsAdapter as Swift actor:

```swift
import Contacts
import Foundation

public actor ContactsAdapter {
    private let contactStore = CNContactStore()
    private let dateFormatter: ISO8601DateFormatter

    public init() {
        dateFormatter = ISO8601DateFormatter()
    }

    /// Request contacts access (iOS 17+)
    public func requestAccess() async throws -> Bool

    /// Fetch all contacts
    public func fetchContacts() async throws -> [CanonicalNode]
}
```

Implementation details:

**requestAccess():**
- Use `try await contactStore.requestAccess(for: .contacts)` (iOS 17+ async API)
- Return the granted boolean

**fetchContacts():**
- Define keysToFetch array:
  - CNContactGivenNameKey
  - CNContactFamilyNameKey
  - CNContactOrganizationNameKey
  - CNContactEmailAddressesKey
  - CNContactPhoneNumbersKey
  - CNContactNoteKey
  - CNContactIdentifierKey
  - CNContactBirthdayKey
- Create CNContactFetchRequest with keysToFetch
- Use contactStore.enumerateContacts(with:) wrapped in withCheckedThrowingContinuation
- Map each CNContact to CanonicalNode:
  - nodeType: "person"
  - name: Build display name from givenName + familyName, fallback to organizationName
  - content: contact.note
  - summary: organizationName if different from name
  - createdAt: ISO8601 from Date() (CNContact doesn't track creation)
  - modifiedAt: ISO8601 from Date()
  - folder: "Contacts"
  - tags: ["contacts"]
  - source: "contacts"
  - sourceId: contact.identifier
  - properties: Store email addresses and phone numbers as arrays

Handle name edge cases:
- If both givenName and familyName empty, use organizationName
- If all empty, use "Unknown Contact"
- Trim whitespace from concatenated names

Add ContactsError enum:
- accessDenied: User denied contacts permission
- fetchFailed(String): Contacts fetch failed
  </action>
  <verify>swift build compiles ContactsAdapter.swift without errors</verify>
  <done>ContactsAdapter fetches CNContact and converts to CanonicalNode with correct field mapping</done>
</task>

<task type="auto">
  <name>Task 2: Create NotesAdapter with ETLBridge delegation</name>
  <files>native/Sources/Isometry/Adapters/NotesAdapter.swift</files>
  <action>
Create NotesAdapter that delegates markdown parsing to JavaScript:

```swift
import Foundation

public actor NotesAdapter {
    private let etlBridge: ETLBridge
    private let fileManager = FileManager.default

    public init(etlBridge: ETLBridge) {
        self.etlBridge = etlBridge
    }

    /// Import alto-index export directory
    public func importNotesExport(from directoryURL: URL) async throws -> ImportSummary

    /// Import single markdown file via ETLBridge
    public func importFile(_ url: URL) async throws -> ImportResult
}
```

**Key design decisions from 71-RESEARCH.md:**
- Do NOT try to access Apple Notes directly (AppleScript TCC issues)
- Use alto-index exported markdown files instead
- Delegate ALL markdown parsing to JS (gray-matter + marked)
- Swift just reads files and passes to ETLBridge

**importNotesExport(from:):**
1. Enumerate directory for .md files recursively
2. For each file:
   - Read file content as Data
   - Call etlBridge.importFile(url) or importContent(filename:content:)
   - Aggregate results
3. Return ImportSummary with total imported, failed, errors

**importFile(_:):**
- Simple delegation to etlBridge.importFile(url)
- File reading happens in ETLBridge

Create ImportSummary struct:
- totalFiles: Int
- imported: Int
- failed: Int
- errors: [String]

Add NotesError enum:
- directoryNotFound: Export directory doesn't exist
- noFilesFound: No .md files in directory
- partialImportFailure(ImportSummary): Some files failed
  </action>
  <verify>swift build compiles NotesAdapter.swift without errors</verify>
  <done>NotesAdapter delegates markdown parsing to ETLBridge, handles directory enumeration</done>
</task>

<task type="auto">
  <name>Task 3: Add adapter unit tests</name>
  <files>
    native/Tests/IsometryTests/Adapters/ContactsAdapterTests.swift
    native/Tests/IsometryTests/Adapters/NotesAdapterTests.swift
  </files>
  <action>
Create test files for both adapters.

**ContactsAdapterTests.swift:**

Create MockContactData helper:
```swift
struct MockContactData {
    let givenName: String
    let familyName: String
    let organizationName: String
    let identifier: String
}
```

Test cases:
1. testContactToCanonicalNodeMapping - Full name from given + family
2. testContactWithOnlyOrganization - Fallback to org name
3. testContactWithEmptyNames - "Unknown Contact" fallback
4. testContactIdentifierAsSourceId - Verify sourceId mapping
5. testContactsErrorDescriptions - Error messages

**NotesAdapterTests.swift:**

Test cases:
1. testImportSummaryAggregation - Verify counts aggregate correctly
2. testDirectoryEnumeration - Mock file system for .md discovery
3. testPartialFailureHandling - Some files fail, others succeed
4. testNotesErrorDescriptions - Error messages

For directory enumeration testing:
- Create temp directory with test .md files
- Verify adapter finds all .md files recursively
- Clean up temp directory after test

Note: Full integration requires ETLBridge + WKWebView.
Unit tests focus on:
- Data structure conversions
- Error handling
- File enumeration logic
  </action>
  <verify>swift test runs ContactsAdapterTests and NotesAdapterTests</verify>
  <done>Unit tests validate adapter logic without requiring framework permissions</done>
</task>

</tasks>

<verification>
1. swift build compiles both adapter files
2. swift test runs both test files
3. ContactsAdapter uses iOS 17+ async requestAccess API
4. NotesAdapter correctly delegates to ETLBridge
5. Both handle empty/nil fields gracefully
6. Error enums provide meaningful descriptions
</verification>

<success_criteria>
- ContactsAdapter.swift at native/Sources/Isometry/Adapters/
- NotesAdapter.swift at native/Sources/Isometry/Adapters/
- ContactsAdapter converts CNContact to CanonicalNode
- NotesAdapter delegates markdown to ETLBridge (no Swift parsing)
- Both use iOS 17+ async APIs
- Unit tests validate conversion and error handling
- BRIDGE-02 requirement satisfied (round-trip Swift->JS->sql.js)
</success_criteria>

<output>
After completion, create `.planning/phases/71-swift-bridge/71-03-SUMMARY.md`
</output>
