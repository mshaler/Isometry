---
phase: 71-swift-bridge
plan: 04
type: execute
wave: 2
depends_on: [71-01, 71-02, 71-03]
files_modified:
  - native/Tests/IsometryTests/Integration/ETLBridgeIntegrationTests.swift
  - native/Sources/Isometry/Bridge/BridgeCoordinator.swift
autonomous: false

must_haves:
  truths:
    - "Round-trip Swift -> JS -> sql.js -> Swift works end-to-end"
    - "BridgeCoordinator orchestrates ETLBridge and native adapters"
    - "Integration test validates full pipeline with real WKWebView"
    - "All adapters produce valid CanonicalNode arrays"
  artifacts:
    - path: "native/Sources/Isometry/Bridge/BridgeCoordinator.swift"
      provides: "Unified interface for all import sources"
      exports: ["BridgeCoordinator", "importFromEventKit", "importFromContacts", "importFile"]
    - path: "native/Tests/IsometryTests/Integration/ETLBridgeIntegrationTests.swift"
      provides: "End-to-end integration tests"
  key_links:
    - from: "native/Sources/Isometry/Bridge/BridgeCoordinator.swift"
      to: "ETLBridge"
      via: "File import delegation"
      pattern: "etlBridge\\.importFile"
    - from: "native/Sources/Isometry/Bridge/BridgeCoordinator.swift"
      to: "EventKitAdapter"
      via: "Calendar event import"
      pattern: "eventKitAdapter\\.fetchEvents"
---

<objective>
Create BridgeCoordinator and integration tests to validate complete Swift-JS round-trip.

Purpose: Provide unified interface for all import sources and verify BRIDGE-02 requirement (round-trip Swift -> JS -> sql.js -> Swift works correctly) with real WKWebView integration test.

Output: BridgeCoordinator class and passing integration tests.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/71-swift-bridge/71-RESEARCH.md
@.planning/phases/71-swift-bridge/71-01-PLAN.md
@.planning/phases/71-swift-bridge/71-02-PLAN.md
@.planning/phases/71-swift-bridge/71-03-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BridgeCoordinator</name>
  <files>native/Sources/Isometry/Bridge/BridgeCoordinator.swift</files>
  <action>
Create BridgeCoordinator as main entry point for imports:

```swift
import WebKit
import Foundation

@MainActor
public class BridgeCoordinator {
    private let etlBridge: ETLBridge
    private let eventKitAdapter: EventKitAdapter
    private let contactsAdapter: ContactsAdapter
    private let notesAdapter: NotesAdapter

    public init(webView: WKWebView) {
        self.etlBridge = ETLBridge(webView: webView)
        self.eventKitAdapter = EventKitAdapter()
        self.contactsAdapter = ContactsAdapter()
        self.notesAdapter = NotesAdapter(etlBridge: etlBridge)
    }

    // MARK: - File Imports (via JS ETL)

    /// Import file via JavaScript ETL pipeline
    public func importFile(_ url: URL) async throws -> ImportResult

    /// Import multiple files
    public func importFiles(_ urls: [URL]) async throws -> BatchImportResult

    // MARK: - Native Framework Imports

    /// Import calendar events
    public func importFromEventKit(from: Date, to: Date) async throws -> [CanonicalNode]

    /// Import reminders
    public func importReminders() async throws -> [CanonicalNode]

    /// Import contacts
    public func importFromContacts() async throws -> [CanonicalNode]

    /// Import alto-index notes export
    public func importNotesExport(from directory: URL) async throws -> ImportSummary

    // MARK: - Access Requests

    /// Request all permissions upfront
    public func requestAllPermissions() async -> PermissionStatus
}
```

Implementation notes:
- BridgeCoordinator is @MainActor because it holds WKWebView reference
- Adapters are actors, so calls are automatically isolated
- File imports delegate to etlBridge
- Native imports use corresponding adapters

Create BatchImportResult:
- results: [String: ImportResult] (keyed by filename)
- totalSuccess: Int
- totalFailed: Int

Create PermissionStatus:
- calendar: Bool
- reminders: Bool
- contacts: Bool

Error handling:
- If any adapter throws, propagate the error
- For batch imports, continue on individual failures and aggregate
  </action>
  <verify>swift build compiles BridgeCoordinator.swift</verify>
  <done>BridgeCoordinator provides unified interface for all import sources</done>
</task>

<task type="auto">
  <name>Task 2: Create integration test infrastructure</name>
  <files>native/Tests/IsometryTests/Integration/ETLBridgeIntegrationTests.swift</files>
  <action>
Create integration test that validates full round-trip with real WKWebView.

Test setup:
1. Create WKWebView with proper configuration
2. Load Isometry web app (or minimal HTML with window.isometryETL mock)
3. Wait for JS to initialize
4. Run import and verify result

```swift
@MainActor
class ETLBridgeIntegrationTests: XCTestCase {
    var webView: WKWebView!
    var coordinator: BridgeCoordinator!

    override func setUp() async throws {
        // Create WKWebView with script message handler
        let config = WKWebViewConfiguration()
        webView = WKWebView(frame: .zero, configuration: config)
        coordinator = BridgeCoordinator(webView: webView)

        // Load test HTML with mock isometryETL
        let testHTML = """
        <!DOCTYPE html>
        <html>
        <body>
        <script>
        window.isometryETL = {
            async importFile(filename, content) {
                // Mock implementation for testing
                return {
                    success: true,
                    nodeCount: 1,
                    errors: null
                };
            },
            getDatabase() { return null; }
        };
        </script>
        </body>
        </html>
        """
        webView.loadHTMLString(testHTML, baseURL: nil)

        // Wait for page load
        try await Task.sleep(nanoseconds: 500_000_000)
    }

    func testRoundTripFileImport() async throws {
        // Create test markdown file
        let testContent = """
        ---
        title: Test Note
        created: 2026-02-12
        ---
        # Hello World
        """

        let tempURL = FileManager.default.temporaryDirectory
            .appendingPathComponent("test.md")
        try testContent.write(to: tempURL, atomically: true, encoding: .utf8)

        // Import via coordinator
        let result = try await coordinator.importFile(tempURL)

        // Verify round-trip succeeded
        XCTAssertTrue(result.success)
        XCTAssertEqual(result.nodeCount, 1)
        XCTAssertNil(result.errors)

        // Cleanup
        try FileManager.default.removeItem(at: tempURL)
    }

    func testETLBridgeErrorOnUninitializedJS() async throws {
        // Create fresh WebView without isometryETL
        let emptyConfig = WKWebViewConfiguration()
        let emptyWebView = WKWebView(frame: .zero, configuration: emptyConfig)
        let bridge = ETLBridge(webView: emptyWebView)

        // Load empty page
        emptyWebView.loadHTMLString("<html></html>", baseURL: nil)
        try await Task.sleep(nanoseconds: 500_000_000)

        // Attempt import should fail
        let tempURL = FileManager.default.temporaryDirectory
            .appendingPathComponent("test.md")
        try "test".write(to: tempURL, atomically: true, encoding: .utf8)

        do {
            _ = try await bridge.importFile(tempURL)
            XCTFail("Should have thrown notInitialized error")
        } catch let error as ETLBridgeError {
            // Expected: notInitialized or similar
            XCTAssertNotNil(error.localizedDescription)
        }
    }
}
```

Note: These tests require XCUITest or similar for WKWebView.
Mark with appropriate @available attributes.
  </action>
  <verify>swift test runs integration tests (may require simulator)</verify>
  <done>Integration tests validate Swift->JS->Swift round-trip with mock isometryETL</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete Swift Bridge implementation:
    - ETLBridge.swift: Swift->JS delegation via callAsyncJavaScript
    - CanonicalNode.swift: Swift model matching TypeScript schema
    - EventKitAdapter.swift: Calendar/Reminders to CanonicalNode
    - ContactsAdapter.swift: Contacts to CanonicalNode
    - NotesAdapter.swift: Alto-index delegation to JS
    - BridgeCoordinator.swift: Unified import interface
    - Integration tests with mock WKWebView
  </what-built>
  <how-to-verify>
    1. Open Xcode project: `open native/Isometry.xcodeproj`
    2. Build (Cmd+B) - verify no compilation errors
    3. Run tests (Cmd+U) - verify all tests pass
    4. Check BridgeCoordinator in code:
       - Verify it initializes all adapters
       - Verify importFile delegates to etlBridge
       - Verify native adapters are accessible

    5. If running on device/simulator with permissions:
       - Test EventKitAdapter.requestAccess() grants permission
       - Test ContactsAdapter.requestAccess() grants permission

    6. Verify CanonicalNode fields match TypeScript:
       - Compare native/Sources/Isometry/Bridge/CanonicalNode.swift
       - Against src/etl/types/canonical.ts
  </how-to-verify>
  <resume-signal>Type "approved" if Swift builds and tests pass, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
1. swift build compiles all Bridge module files
2. swift test runs all unit and integration tests
3. BridgeCoordinator provides unified API
4. Integration test validates round-trip with mock JS
5. Error handling covers all edge cases
</verification>

<success_criteria>
- BridgeCoordinator.swift exists with unified import interface
- Integration tests validate Swift->JS->Swift round-trip
- All adapters accessible via BridgeCoordinator
- Build and test commands succeed
- Human verification confirms implementation works
- BRIDGE-01 and BRIDGE-02 requirements satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/71-swift-bridge/71-04-SUMMARY.md`
</output>
