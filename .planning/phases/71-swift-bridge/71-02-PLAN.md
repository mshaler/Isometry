---
phase: 71-swift-bridge
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - native/Sources/Isometry/Adapters/EventKitAdapter.swift
  - native/Tests/IsometryTests/Adapters/EventKitAdapterTests.swift
autonomous: true
user_setup:
  - service: EventKit
    why: "Calendar and Reminders access"
    dashboard_config:
      - task: "Grant Calendar access when prompted"
        location: "iOS Settings > Privacy > Calendars > Isometry"

must_haves:
  truths:
    - "EventKitAdapter can request calendar access using iOS 17+ async API"
    - "Fetched events are converted to CanonicalNode array"
    - "Event dates are formatted as ISO8601 strings"
    - "Calendar title becomes folder field for organization"
  artifacts:
    - path: "native/Sources/Isometry/Adapters/EventKitAdapter.swift"
      provides: "Actor-based EventKit to CanonicalNode converter"
      exports: ["EventKitAdapter", "fetchEvents", "requestAccess"]
  key_links:
    - from: "native/Sources/Isometry/Adapters/EventKitAdapter.swift"
      to: "EKEventStore"
      via: "requestFullAccessToEvents() iOS 17+ API"
      pattern: "requestFullAccessToEvents"
    - from: "native/Sources/Isometry/Adapters/EventKitAdapter.swift"
      to: "CanonicalNode"
      via: "Event-to-node conversion"
      pattern: "CanonicalNode\\("
---

<objective>
Create EventKitAdapter that fetches calendar events and converts them to CanonicalNode format.

Purpose: Enable native iOS calendar integration without file-based import. EventKit provides direct access to user's calendar data which can be converted to nodes for SuperGrid visualization.

Output: EventKitAdapter actor with fetchEvents() method returning CanonicalNode array.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/71-swift-bridge/71-RESEARCH.md

# CanonicalNode model created in 71-01
# If executing in parallel, reference research for schema
@native/Sources/Isometry/Import/SQLiteFileImporter.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EventKitAdapter actor</name>
  <files>native/Sources/Isometry/Adapters/EventKitAdapter.swift</files>
  <action>
Create EventKitAdapter as Swift actor:

```swift
import EventKit
import Foundation

public actor EventKitAdapter {
    private let eventStore = EKEventStore()
    private let dateFormatter: ISO8601DateFormatter

    public init() {
        dateFormatter = ISO8601DateFormatter()
        dateFormatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]
    }

    /// Request calendar access (iOS 17+)
    public func requestAccess() async throws -> Bool

    /// Fetch events within date range
    public func fetchEvents(from: Date, to: Date) async throws -> [CanonicalNode]

    /// Fetch reminders (incomplete only)
    public func fetchReminders() async throws -> [CanonicalNode]
}
```

Implementation details:

**requestAccess():**
- Use `try await eventStore.requestFullAccessToEvents()` (iOS 17+ API)
- Return the granted boolean
- If denied, subsequent fetch calls will throw AdapterError.accessDenied

**fetchEvents(from:to:):**
- Create predicate with eventStore.predicateForEvents(withStart:end:calendars:)
- Pass nil for calendars to get all calendars
- Call eventStore.events(matching:) synchronously (it's thread-safe)
- Map each EKEvent to CanonicalNode:
  - id: UUID().uuidString (new ID, not event identifier)
  - nodeType: "event"
  - name: event.title ?? "Untitled Event"
  - content: event.notes
  - summary: event.location
  - createdAt: ISO8601 from event.creationDate
  - modifiedAt: ISO8601 from event.lastModifiedDate
  - eventStart: ISO8601 from event.startDate
  - eventEnd: ISO8601 from event.endDate
  - folder: event.calendar?.title ?? "Calendar"
  - tags: ["eventkit", event.calendar?.title].compactMap { $0 }
  - source: "eventkit"
  - sourceId: event.eventIdentifier
  - priority: 0
  - importance: 0
  - sortOrder: 0

**fetchReminders():**
- Use eventStore.predicateForIncompleteReminders(withDueDateStarting:ending:calendars:)
- Use eventStore.fetchReminders(matching:) with continuation wrapper
- Map EKReminder to CanonicalNode:
  - nodeType: "task"
  - name: reminder.title ?? "Untitled Reminder"
  - content: reminder.notes
  - dueAt: ISO8601 from reminder.dueDateComponents
  - completedAt: ISO8601 from reminder.completionDate (nil if incomplete)
  - status: reminder.isCompleted ? "complete" : "pending"

Create AdapterError enum:
- accessDenied: User denied calendar permission
- fetchFailed(String): EventKit fetch operation failed
  </action>
  <verify>swift build compiles EventKitAdapter.swift without errors</verify>
  <done>EventKitAdapter exists with requestAccess(), fetchEvents(), fetchReminders() methods using iOS 17+ async APIs</done>
</task>

<task type="auto">
  <name>Task 2: Add EventKitAdapter tests</name>
  <files>native/Tests/IsometryTests/Adapters/EventKitAdapterTests.swift</files>
  <action>
Create test file for EventKitAdapter.

Note: EventKit requires entitlements and user permission, so unit tests focus on:
1. Date formatting for ISO8601 output
2. CanonicalNode field mapping logic
3. AdapterError descriptions

Create MockEKEvent helper struct for testing conversion logic without actual EventKit:
```swift
struct MockEventData {
    let title: String?
    let notes: String?
    let location: String?
    let startDate: Date
    let endDate: Date
    let calendarTitle: String?
    let eventIdentifier: String
}
```

Test cases:
1. testEventToCanonicalNodeMapping - Verify all fields map correctly
2. testEventWithNilFields - Verify optional fields handled
3. testReminderToCanonicalNodeMapping - Verify task conversion
4. testDateFormatting - Verify ISO8601 format with fractional seconds
5. testAdapterErrorDescriptions - Verify error messages

For actual EventKit integration testing, create a separate UI test target that:
- Requests permission from user
- Fetches real events
- Validates result structure

Mark integration tests with @available(iOS 17, *) for compile-time checking.
  </action>
  <verify>swift test runs EventKitAdapterTests with mocked data</verify>
  <done>Unit tests validate conversion logic and error handling</done>
</task>

</tasks>

<verification>
1. swift build compiles EventKitAdapter.swift
2. swift test runs EventKitAdapterTests
3. Uses iOS 17+ requestFullAccessToEvents() API
4. ISO8601DateFormatter configured correctly
5. All EKEvent fields map to appropriate CanonicalNode fields
6. AdapterError provides meaningful messages
</verification>

<success_criteria>
- EventKitAdapter.swift exists at native/Sources/Isometry/Adapters/
- Uses iOS 17+ async/await API (requestFullAccessToEvents)
- Converts EKEvent to CanonicalNode with correct field mapping
- Calendar title used as folder for organization
- Event identifiers preserved as sourceId
- Unit tests validate conversion without requiring calendar access
</success_criteria>

<output>
After completion, create `.planning/phases/71-swift-bridge/71-02-SUMMARY.md`
</output>
