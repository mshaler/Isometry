---
phase: 71-swift-bridge
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - native/Sources/Isometry/Bridge/ETLBridge.swift
  - native/Sources/Isometry/Bridge/CanonicalNode.swift
  - native/Sources/Isometry/Bridge/ETLBridgeError.swift
autonomous: true

must_haves:
  truths:
    - "Swift can invoke window.isometryETL.importFile() via WKWebView"
    - "File content is correctly base64-encoded before JS call"
    - "JSON response is decoded into Swift ImportResult struct"
    - "Error cases return meaningful Swift errors"
  artifacts:
    - path: "native/Sources/Isometry/Bridge/ETLBridge.swift"
      provides: "Actor-based bridge to JS ETL pipeline"
      exports: ["ETLBridge", "importFile"]
    - path: "native/Sources/Isometry/Bridge/CanonicalNode.swift"
      provides: "Swift Codable model matching TypeScript CanonicalNode"
      exports: ["CanonicalNode"]
    - path: "native/Sources/Isometry/Bridge/ETLBridgeError.swift"
      provides: "Error types for bridge operations"
      exports: ["ETLBridgeError"]
  key_links:
    - from: "native/Sources/Isometry/Bridge/ETLBridge.swift"
      to: "window.isometryETL.importFile"
      via: "callAsyncJavaScript"
      pattern: "callAsyncJavaScript.*isometryETL"
    - from: "native/Sources/Isometry/Bridge/ETLBridge.swift"
      to: "WKWebView"
      via: "MainActor.run for thread safety"
      pattern: "MainActor\\.run"
---

<objective>
Create ETLBridge.swift that delegates file processing to JavaScript ETL pipeline via WKWebView.

Purpose: Enable Swift to leverage the TypeScript ETL infrastructure (6 importers + coordinator) without duplicating parsing logic. This eliminates the need for Swift-side markdown/xlsx/docx parsers.

Output: ETLBridge actor with importFile() method that calls window.isometryETL.importFile() and returns ImportResult.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/71-swift-bridge/71-RESEARCH.md

# Phase 70 created the JS API we're calling
@.planning/phases/70-integration/70-01-SUMMARY.md

# Existing Swift patterns to follow
@native/Sources/Isometry/WebView/FileSystemMessageHandler.swift
@native/Sources/Isometry/Import/SQLiteFileImporter.swift

# JS API we're calling
@src/etl/bridge/window-export.ts
@src/types/global.d.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CanonicalNode Swift model</name>
  <files>native/Sources/Isometry/Bridge/CanonicalNode.swift</files>
  <action>
Create Swift Codable struct matching TypeScript CanonicalNode from src/etl/types/canonical.ts.

Required fields with correct types:
- id: String
- nodeType: String
- name: String
- content: String?
- summary: String?
- createdAt: String (ISO8601)
- modifiedAt: String (ISO8601)
- dueAt: String?
- completedAt: String?
- eventStart: String?
- eventEnd: String?
- folder: String?
- tags: [String]
- status: String?
- priority: Int (default 0)
- importance: Int (default 0)
- sortOrder: Int (default 0)
- source: String?
- sourceId: String?
- sourceUrl: String?
- deletedAt: String?
- version: Int (default 1)
- properties: [String: AnyCodable]? (for JSON extension point)

Also create AnyCodable helper for handling arbitrary JSON values in properties.
Use CodingKeys for snake_case to camelCase mapping when decoding JSON from JS.

Add extension for convenience initializers matching common node types (event, person, note).
  </action>
  <verify>swift build compiles without errors for CanonicalNode.swift</verify>
  <done>CanonicalNode.swift exists with Codable conformance, all fields match TypeScript schema, CodingKeys handle JSON naming</done>
</task>

<task type="auto">
  <name>Task 2: Create ETLBridge actor with importFile</name>
  <files>
    native/Sources/Isometry/Bridge/ETLBridge.swift
    native/Sources/Isometry/Bridge/ETLBridgeError.swift
  </files>
  <action>
Create ETLBridgeError enum in separate file:
- webViewNotAvailable: WKWebView reference is nil
- notInitialized: ETL bridge not initialized in JS
- invalidResponse: JS returned unexpected format
- importFailed(String): JS-side error with message
- fileAccessDenied: Cannot read file

Create ETLBridge as Swift actor (not class) for thread safety:
```swift
public actor ETLBridge {
    private weak var webView: WKWebView?
    private let decoder = JSONDecoder()

    public init(webView: WKWebView) {
        self.webView = webView
    }

    /// Import file via JS ETL pipeline
    public func importFile(_ url: URL) async throws -> ImportResult

    /// Import raw content with filename
    public func importContent(filename: String, content: Data) async throws -> ImportResult
}
```

ImportResult struct:
- success: Bool
- nodeCount: Int
- errors: [String]?

Implementation notes from 71-RESEARCH.md:
1. Use callAsyncJavaScript (not evaluateJavaScript) for async JS functions
2. Base64-encode file content before passing to JS (binary safety)
3. Use MainActor.run when calling webView methods (WKWebView is MainActor)
4. Use .page content world to access window.isometryETL
5. Always return value from JS (callAsyncJavaScript crashes on nil return)
6. Parse JSON response with JSONDecoder

Key JS call pattern:
```swift
let result = try await MainActor.run {
    try await webView.callAsyncJavaScript(
        """
        const result = await window.isometryETL.importFile(filename, atob(content));
        return JSON.stringify(result);
        """,
        arguments: ["filename": filename, "content": base64Content],
        in: nil,
        contentWorld: .page
    )
}
```

Handle errors:
- If webView is nil, throw webViewNotAvailable
- If window.isometryETL is undefined, throw notInitialized
- If JSON decode fails, throw invalidResponse
- If result.success is false, throw importFailed with first error
  </action>
  <verify>swift build compiles ETLBridge.swift and ETLBridgeError.swift without errors</verify>
  <done>ETLBridge actor can call window.isometryETL.importFile, returns ImportResult, handles all error cases</done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for ETLBridge</name>
  <files>native/Tests/IsometryTests/Bridge/ETLBridgeTests.swift</files>
  <action>
Create test file with XCTest framework.

Test cases needed:
1. testImportResultDecoding - Verify JSON from JS decodes to ImportResult
2. testCanonicalNodeDecoding - Verify JSON with all fields decodes correctly
3. testCanonicalNodeDefaults - Verify optional fields default correctly
4. testAnyCodableHandlesNestedObjects - Verify properties dict handles complex values
5. testBase64EncodingForBinaryContent - Verify file content encoding
6. testETLBridgeErrorDescriptions - Verify all error cases have useful messages

Note: Full integration test requires WKWebView which needs a separate test target.
These unit tests validate the Codable models and error types without WKWebView.

Use sample JSON matching window.isometryETL.importFile() response format:
```json
{
  "success": true,
  "nodeCount": 5,
  "errors": null
}
```

Add test for failed import response:
```json
{
  "success": false,
  "nodeCount": 0,
  "errors": ["Unsupported file format: .xyz"]
}
```
  </action>
  <verify>swift test runs ETLBridgeTests and all tests pass</verify>
  <done>Unit tests exist for ImportResult, CanonicalNode, and ETLBridgeError types</done>
</task>

</tasks>

<verification>
1. swift build compiles all Bridge module files
2. swift test runs ETLBridgeTests with 0 failures
3. CanonicalNode fields match TypeScript schema exactly
4. ETLBridge uses actor isolation for thread safety
5. callAsyncJavaScript pattern matches 71-RESEARCH.md recommendations
</verification>

<success_criteria>
- ETLBridge.swift exists at native/Sources/Isometry/Bridge/ETLBridge.swift
- CanonicalNode.swift matches TypeScript CanonicalNode schema
- importFile() uses callAsyncJavaScript with .page content world
- Base64 encoding applied to file content
- MainActor.run used for WKWebView calls
- All error cases throw appropriate ETLBridgeError
- Unit tests validate Codable models and error types
</success_criteria>

<output>
After completion, create `.planning/phases/71-swift-bridge/71-01-SUMMARY.md`
</output>
