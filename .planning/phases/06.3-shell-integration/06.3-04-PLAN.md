---
phase: 06.3-shell-integration
plan: 04
type: execute
wave: 4
depends_on: [06.3-03]
files_modified: [
  native/Sources/Isometry/Models/CommandHistory.swift,
  native/Sources/Isometry/Views/Notebook/CommandHistoryView.swift,
  native/Sources/Isometry/Views/Notebook/NotebookShellView.swift,
  native/Sources/Isometry/Database/IsometryDatabase.swift
]
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can search command history across sessions with instant results"
    - "Command history persists across app restarts with CloudKit sync"
    - "Context shows current notebook card relationship to commands"
    - "History navigation works with keyboard shortcuts and gestures"
  artifacts:
    - path: "native/Sources/Isometry/Models/CommandHistory.swift"
      provides: "Persistent command history with CloudKit sync"
      exports: ["CommandHistoryManager", "HistoryEntry", "HistoryFilter"]
    - path: "native/Sources/Isometry/Views/Notebook/CommandHistoryView.swift"
      provides: "Searchable command history interface"
      exports: ["CommandHistoryView", "HistorySearchView"]
    - path: "native/Sources/Isometry/Database/IsometryDatabase.swift"
      provides: "Database schema for command history storage"
      contains: "command_history table definitions"
  key_links:
    - from: "CommandHistoryView.swift"
      to: "IsometryDatabase"
      via: "FTS5 search queries"
      pattern: "database\\.searchCommandHistory"
    - from: "CommandHistoryManager.swift"
      to: "CloudKit"
      via: "sync coordination"
      pattern: "CKRecord.*command_history"
---

<objective>
Implement persistent command history with CloudKit synchronization and advanced search capabilities

Purpose: Provide comprehensive command history management that persists across devices and sessions with powerful search and context awareness
Output: Full-featured command history system with search, persistence, and cloud synchronization
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Previous plans in phase
@.planning/phases/06.3-shell-integration/06.3-01-PLAN.md
@.planning/phases/06.3-shell-integration/06.3-02-PLAN.md
@.planning/phases/06.3-shell-integration/06.3-03-PLAN.md

# Database foundation
@native/Sources/Isometry/Database/IsometryDatabase.swift
@native/Sources/Isometry/Sync/CloudKitSyncManager.swift

# React prototype history patterns
@src/types/shell.ts

# Current shell implementation
@native/Sources/Isometry/Views/Notebook/NotebookShellView.swift
@native/Sources/Isometry/Models/ShellModels.swift
@native/Sources/Isometry/Security/SandboxExecutor.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend database schema for command history with full-text search</name>
  <files>native/Sources/Isometry/Database/IsometryDatabase.swift</files>
  <action>
    Add comprehensive command history storage to IsometryDatabase:

    Database schema extension:
    - command_history table: id, command_text, command_type (system/claude), timestamp, duration, success, output_preview, error_message, working_directory, session_id
    - notebook_context table: command_id, card_id, card_title for linking commands to notebook cards
    - command_history_fts5 virtual table for full-text search on command_text and output_preview
    - Indexes on timestamp, command_type, session_id for efficient queries
    - CloudKit integration fields: ck_record_id, ck_modified_date for sync

    Query methods:
    - searchCommandHistory(query: String) -> [HistoryEntry] using FTS5
    - getRecentCommands(limit: Int, type: CommandType?) for history navigation
    - getCommandsBySession(sessionId: String) for session-based grouping
    - getCommandsForCard(cardId: String) for context awareness
    - cleanupOldHistory(olderThan: Date) for maintenance (keep last 1000 or 30 days)

    Follow existing IsometryDatabase patterns for GRDB integration and CloudKit sync.
    Use proper transaction handling for batch inserts and complex queries.
  </action>
  <verify>Database migration runs successfully and FTS5 search returns expected results for test data</verify>
  <done>Command history database schema supports efficient storage, search, and CloudKit synchronization</done>
</task>

<task type="auto">
  <name>Task 2: Create CommandHistoryManager for persistence and search operations</name>
  <files>native/Sources/Isometry/Models/CommandHistory.swift</files>
  <action>
    Create comprehensive command history management system:

    CommandHistoryManager actor:
    - saveCommand() method for persisting executed commands with metadata
    - searchHistory() with query string, filters (type, date range, success status)
    - getRecent() for shell history navigation (up/down arrows)
    - getSessionHistory() for current session context
    - CloudKit sync integration with CloudKitSyncManager
    - Automatic cleanup of old entries based on configurable retention policy

    HistoryEntry model:
    - All command metadata: text, type, timestamp, duration, success, output, error
    - Context information: working directory, session ID, related card
    - CloudKit compatibility with CKRecord conversion methods
    - Search ranking based on recency, frequency, success rate

    HistoryFilter model:
    - Type filter: system/claude commands, successful/failed only
    - Date range filtering with relative dates (today, this week, this month)
    - Text search with highlighting for matched terms
    - Context filtering by notebook card or session

    Performance optimization:
    - Background queue for database operations to avoid UI blocking
    - Pagination for large history sets (50 entries per page)
    - Caching of recent searches and frequent queries
    - Memory management for search results and metadata
  </action>
  <verify>CommandHistoryManager saves commands, performs searches, and integrates with CloudKit sync</verify>
  <done>History management system provides efficient persistence and search with cloud synchronization</done>
</task>

<task type="auto">
  <name>Task 3: Create command history search interface with advanced filtering</name>
  <files>native/Sources/Isometry/Views/Notebook/CommandHistoryView.swift</files>
  <action>
    Create comprehensive command history UI component:

    CommandHistoryView:
    - Searchable list with instant search results using SwiftUI .searchable
    - Command entry cells showing: command text, type icon, timestamp, duration, success indicator
    - Expandable cells for full output preview on tap
    - Filter controls: command type toggle, date range picker, success/error filter
    - Context grouping: show commands by notebook card or session
    - Infinite scroll with lazy loading for large history sets

    Search features:
    - Real-time search with 300ms debounce for performance
    - Search highlighting for matched terms in command text and output
    - Search suggestions based on command frequency and recency
    - Quick filters: Recent, Successful, Failed, Claude commands, System commands
    - Search history for repeated queries

    Accessibility and navigation:
    - VoiceOver support with descriptive labels for commands and metadata
    - Keyboard navigation: arrow keys, return to select/execute
    - Haptic feedback for selection and actions on iOS
    - Context menus for copy command, re-execute, add to favorites

    Platform-specific features:
    - macOS: Right-click context menus, keyboard shortcuts
    - iOS: Swipe actions, haptic feedback, pull-to-refresh
    - Both: Share command functionality through native share sheet
  </action>
  <verify>History view displays commands with search functionality and proper filtering options</verify>
  <done>Command history interface provides comprehensive search and filtering with excellent user experience</done>
</task>

<task type="auto">
  <name>Task 4: Integrate history system into shell with navigation and context awareness</name>
  <files>native/Sources/Isometry/Views/Notebook/NotebookShellView.swift</files>
  <action>
    Integrate comprehensive history system into shell interface:

    History integration:
    - CommandHistoryManager integration for automatic command saving
    - History navigation: up/down arrow keys for previous commands
    - Command completion suggestions based on history frequency
    - Session context: automatically link commands to active notebook card
    - History panel toggle with slide-out/popover interface

    Enhanced shell features:
    - Auto-completion dropdown with recent commands and suggestions
    - Command preview when navigating history (show before executing)
    - Favorite commands system with star/bookmark functionality
    - Quick access toolbar with most frequent commands
    - Session management: new session on card change, session naming

    Context awareness:
    - Automatically include current notebook card ID and title in command context
    - Show related commands when viewing different notebook cards
    - Context switching: adjust working directory based on card content
    - Command suggestions relevant to current card type or content

    Performance optimizations:
    - Background history saving to avoid blocking command execution
    - Efficient history queries with proper caching
    - Lazy loading for history navigation and suggestions
    - Memory management for large command outputs and history sets

    UI enhancements:
    - History indicator in shell header showing last command status
    - Quick stats: total commands, session duration, success rate
    - Export functionality: share command history or session logs
    - Settings integration: history retention, search preferences, sync settings
  </action>
  <verify>Shell saves command history, provides navigation with arrow keys, and shows context-aware suggestions</verify>
  <done>Shell provides complete history integration with context awareness and advanced navigation features</done>
</task>

</tasks>

<verification>
History persistence test: Execute commands, restart app, verify commands persist and sync across devices
Search test: Execute "grep" and "claude" commands, search for "grep", verify correct filtering and results
Navigation test: Use up/down arrows to navigate recent commands, verify proper cycling and execution
Context test: Switch between different notebook cards, verify command history shows relevant context
CloudKit test: Execute commands on one device, verify they appear on another device with same account
</verification>

<success_criteria>
- Command history persists across app sessions and syncs via CloudKit to other devices
- Search functionality provides instant results with proper filtering by type, date, success status
- Keyboard navigation allows efficient browsing of command history with arrow keys
- Context awareness links commands to notebook cards and provides relevant suggestions
- History management includes cleanup, favorites, and export functionality
- Performance remains responsive with large command history (1000+ entries)
</success_criteria>

<output>
After completion, create `.planning/phases/06.3-shell-integration/06.3-04-SUMMARY.md`
</output>