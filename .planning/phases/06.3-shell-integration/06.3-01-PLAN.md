---
phase: 06.3-shell-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [
  native/Sources/Isometry/Models/ShellModels.swift,
  native/Sources/Isometry/Security/SandboxExecutor.swift,
  native/Sources/Isometry/Views/Notebook/NotebookShellView.swift
]
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can type commands in native terminal input field"
    - "Commands execute within App Sandbox constraints"
    - "Terminal shows command output with proper formatting"
    - "System respects sandboxed file access limitations"
  artifacts:
    - path: "native/Sources/Isometry/Models/ShellModels.swift"
      provides: "Command, response, and session data models"
      exports: ["ShellCommand", "CommandResponse", "ShellSession"]
    - path: "native/Sources/Isometry/Security/SandboxExecutor.swift"
      provides: "App Sandbox-compliant process execution"
      exports: ["SandboxExecutor", "ExecutionResult"]
    - path: "native/Sources/Isometry/Views/Notebook/NotebookShellView.swift"
      provides: "Native terminal interface"
      min_lines: 200
  key_links:
    - from: "NotebookShellView.swift"
      to: "SandboxExecutor"
      via: "command execution"
      pattern: "sandboxExecutor\\.execute"
    - from: "SandboxExecutor.swift"
      to: "Process"
      via: "sandboxed process creation"
      pattern: "Process\\(\\)"
---

<objective>
Create App Sandbox-compliant terminal interface with secure process execution framework

Purpose: Establish native terminal foundation that respects iOS/macOS App Store security constraints while enabling basic command execution
Output: Working native terminal with secure process execution infrastructure
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 6.1 foundation
@.planning/phases/06.1-foundation-layout/06.1-01-SUMMARY.md

# React prototype patterns
@src/types/shell.ts
@src/components/notebook/ShellComponent.tsx

# Current placeholder shell
@native/Sources/Isometry/Views/Notebook/NotebookShellView.swift

# Existing security patterns
@native/Sources/Isometry/App/IsometryApp.swift
@native/Sources/Isometry/Utils/PerformanceMonitor.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Swift shell data models based on React prototype types</name>
  <files>native/Sources/Isometry/Models/ShellModels.swift</files>
  <action>
    Create comprehensive Swift data models translating React TypeScript shell types:

    - ShellCommand: id, type (system/claude), command string, timestamp, cwd, context (cardId/title)
    - CommandResponse: id, success, output, error, duration, type, metadata
    - ShellSession: commands array, currentDirectory, environment vars, sessionId
    - CommandHistory: entries, maxSize (1000), persistence methods
    - ExecutionContext: working directory, environment restrictions, timeout limits

    Use @Sendable, Codable protocols for thread safety and persistence. Add CloudKit support with CKRecord compatibility.
    Include security-aware properties (allowedCommands, restrictedPaths) for App Sandbox compliance.
    Reference React prototype patterns but adapt for native CloudKit/GRDB persistence.
  </action>
  <verify>Build succeeds with no Swift compilation errors</verify>
  <done>Shell data models exist with proper Swift protocols and App Sandbox awareness</done>
</task>

<task type="auto">
  <name>Task 2: Create SandboxExecutor for secure process execution</name>
  <files>native/Sources/Isometry/Security/SandboxExecutor.swift</files>
  <action>
    Create App Sandbox-compliant command execution infrastructure:

    - SandboxExecutor actor with async execute() method using Process API
    - Allowlist of safe commands: ls, pwd, echo, cat (readonly), find, grep, wc, head, tail
    - File access restrictions: only allow operations within app container/Documents
    - Timeout enforcement: 30 second maximum execution time
    - Output streaming with proper memory management (no unlimited buffers)
    - Error handling for sandbox violations, command not found, timeout
    - Integration with PerformanceMonitor for shell operation tracking

    Study existing Process usage in IsometryApp.swift for codesign pattern.
    Use Pipe for output capture, NSString(data:encoding:) for text conversion.
    NO unrestricted shell access - this must be App Store compliant.
    Return structured ExecutionResult with success/failure, output, timing.
  </action>
  <verify>Unit test with echo/pwd commands executes successfully within sandbox</verify>
  <done>SandboxExecutor safely runs allowlisted commands with proper error handling</done>
</task>

<task type="auto">
  <name>Task 3: Replace NotebookShellView placeholder with native terminal interface</name>
  <files>native/Sources/Isometry/Views/Notebook/NotebookShellView.swift</files>
  <action>
    Transform placeholder shell into working native terminal interface:

    - TextField for command input with onSubmit handling
    - ScrollView with LazyVStack for command history display
    - Command/response pairs with timestamps and type indicators (system vs claude)
    - Terminal-style formatting: monospace font, dark theme, green prompt
    - Working directory display with proper truncation for mobile
    - Command execution integration with SandboxExecutor
    - Loading states during command execution with cancellation
    - Error display for sandbox violations or command failures

    Maintain existing shell view styling but replace static placeholder content.
    Use @StateObject for SandboxExecutor, @State for input text and command history.
    Add keyboard shortcuts: Enter (execute), Up/Down (history), Ctrl+C (cancel).
    Follow SwiftUI best practices with proper view composition and performance.
  </action>
  <verify>Shell UI accepts input, executes simple commands, displays output with proper formatting</verify>
  <done>Native terminal interface works with command execution and history display</done>
</task>

</tasks>

<verification>
Integration test: Type "pwd" and "echo hello world" in shell interface, verify execution and output display
Build verification: iOS and macOS targets compile without errors
Security verification: Attempt restricted command (e.g. "rm -rf /") fails with proper error message
</verification>

<success_criteria>
- User can type commands in native Swift terminal interface
- Basic sandbox-safe commands execute and display output correctly
- App Sandbox security prevents unsafe operations with clear error messages
- Terminal interface integrates with existing notebook layout and performance monitoring
- Foundation ready for Claude API integration in next plan
</success_criteria>

<output>
After completion, create `.planning/phases/06.3-shell-integration/06.3-01-SUMMARY.md`
</output>