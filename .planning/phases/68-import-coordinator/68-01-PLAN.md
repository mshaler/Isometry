---
phase: 68-import-coordinator
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/etl/importers/BaseImporter.ts
  - src/etl/coordinator/ImportCoordinator.ts
  - src/etl/__tests__/ImportCoordinator.test.ts
autonomous: true

must_haves:
  truths:
    - "ImportCoordinator routes files to appropriate importers by extension"
    - "BaseImporter defines import/parse/validate/transform contract"
    - "Format detection works for all supported extensions (md, xlsx, docx, json, html, csv)"
    - "Batch import collects errors without failing entire operation"
  artifacts:
    - path: "src/etl/importers/BaseImporter.ts"
      provides: "Abstract base class for all importers"
      exports: ["BaseImporter", "FileSource", "ImportResult"]
    - path: "src/etl/coordinator/ImportCoordinator.ts"
      provides: "Central router for file imports"
      exports: ["ImportCoordinator"]
    - path: "src/etl/__tests__/ImportCoordinator.test.ts"
      provides: "Unit tests for coordinator"
      min_lines: 80
  key_links:
    - from: "src/etl/coordinator/ImportCoordinator.ts"
      to: "src/etl/importers/BaseImporter.ts"
      via: "import BaseImporter"
      pattern: "import.*BaseImporter.*from"
    - from: "src/etl/coordinator/ImportCoordinator.ts"
      to: "src/etl/types/canonical.ts"
      via: "import CanonicalNodeSchema"
      pattern: "import.*CanonicalNodeSchema.*from"
---

<objective>
Create central ImportCoordinator router and BaseImporter abstract class for the ETL system.

Purpose: Establish the factory + strategy pattern infrastructure that all file importers (Phase 69) will plug into. The coordinator handles routing and validation, while importers handle format-specific parsing.

Output: Two TypeScript modules (BaseImporter, ImportCoordinator) with unit tests.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/68-import-coordinator/68-RESEARCH.md
@.planning/phases/67-canonical-schema/67-01-SUMMARY.md
@src/etl/types/canonical.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BaseImporter and ImportCoordinator</name>
  <files>
    src/etl/importers/BaseImporter.ts
    src/etl/coordinator/ImportCoordinator.ts
  </files>
  <action>
Create the import infrastructure following patterns from 68-RESEARCH.md:

**BaseImporter.ts** (src/etl/importers/BaseImporter.ts):
1. Define `FileSource` interface:
   - `filename: string` (required for extension detection)
   - `content: string` (UTF-8 text or base64 binary)
   - `encoding?: 'utf8' | 'base64'` (defaults to utf8)
   - `metadata?: { size?: number; mimeType?: string; source?: string }`

2. Define `ImportResult` interface:
   - `imported: number`
   - `skipped: number`
   - `errors: Array<{ file: string; error: string }>`
   - `duration: number`
   - `nodes: CanonicalNode[]`

3. Create abstract `BaseImporter` class with Template Method pattern:
   - `async import(source: FileSource): Promise<CanonicalNode[]>` - public template method
   - `protected abstract parse(source: FileSource): Promise<unknown>` - format-specific parsing
   - `protected async validate(data: unknown): Promise<unknown>` - default passthrough, override for format-specific
   - `protected abstract transform(data: unknown): Promise<CanonicalNode[]>` - convert to canonical format
   - Template method orchestrates: parse -> validate -> transform

**ImportCoordinator.ts** (src/etl/coordinator/ImportCoordinator.ts):
1. Import `BaseImporter`, `FileSource`, `ImportResult` from BaseImporter
2. Import `CanonicalNode`, `CanonicalNodeSchema` from types/canonical
3. Use `path` module for extension extraction (import path from 'path' - browser-safe via Vite)

4. Define supported extensions constant:
   ```typescript
   const SUPPORTED_EXTENSIONS = [
     '.md', '.markdown', '.mdx',
     '.xlsx', '.xls',
     '.docx',
     '.json',
     '.html', '.htm',
     '.csv', '.tsv'
   ] as const;
   ```

5. Create `ImportCoordinator` class:
   - `private importers: Map<string, BaseImporter>` - extension -> importer mapping
   - `constructor()` - initialize empty Map
   - `registerImporter(extensions: string[], importer: BaseImporter): void` - register importer for extensions (normalize to lowercase)
   - `getSupportedExtensions(): string[]` - return list of registered extensions
   - `detectFormat(filename: string): string` - extract and validate extension (lowercase), throw if unsupported
   - `getImporter(extension: string): BaseImporter` - get importer for extension, throw if none registered
   - `async importFile(source: FileSource): Promise<CanonicalNode[]>` - route to importer, validate output with CanonicalNodeSchema.parse()
   - `async importFiles(sources: FileSource[]): Promise<ImportResult>` - batch import with error collection using for-of loop (not Promise.allSettled - simpler for this use case)

Key implementation details:
- Always normalize extensions to lowercase in detectFormat() and registerImporter()
- Validate EVERY node returned by importer using CanonicalNodeSchema.parse() in importFile()
- Wrap validation errors with file context: "Node {idx} from {filename} failed validation: {error}"
- Track duration with performance.now() in importFiles()
- Do NOT import any concrete importers - they register themselves in Phase 69
  </action>
  <verify>
TypeScript compiles without errors:
```bash
npm run check:types
```

Files exist with correct exports:
```bash
grep -l "export.*BaseImporter\|export.*FileSource\|export.*ImportResult" src/etl/importers/BaseImporter.ts
grep -l "export.*ImportCoordinator" src/etl/coordinator/ImportCoordinator.ts
```
  </verify>
  <done>
- BaseImporter.ts exports FileSource, ImportResult, and abstract BaseImporter class
- ImportCoordinator.ts exports ImportCoordinator class with register/detect/import methods
- TypeScript compiles cleanly
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for ImportCoordinator</name>
  <files>
    src/etl/__tests__/ImportCoordinator.test.ts
  </files>
  <action>
Create comprehensive unit tests using Vitest:

**Test file structure:**

```typescript
import { describe, it, expect, beforeEach } from 'vitest';
import { ImportCoordinator } from '../coordinator/ImportCoordinator';
import { BaseImporter, FileSource } from '../importers/BaseImporter';
import { CanonicalNode } from '../types/canonical';
import { v4 as uuidv4 } from 'uuid';
```

**Mock importer for testing:**
Create a simple MockImporter class extending BaseImporter that:
- Accepts `returnNodes: CanonicalNode[]` in constructor
- Returns those nodes from transform()
- Optionally throws error in parse() to test error handling

**Test cases to implement:**

1. **Format detection tests:**
   - `detectFormat('.md') returns '.md'`
   - `detectFormat('.MD') returns '.md'` (case normalization)
   - `detectFormat('README.markdown') returns '.markdown'`
   - `detectFormat('.xyz') throws 'Unsupported file format'`
   - `detectFormat('noextension') throws error`

2. **Importer registration tests:**
   - `registerImporter() allows importing for registered extension`
   - `registerImporter() handles multiple extensions for one importer`
   - `getImporter() throws for unregistered extension`
   - `getSupportedExtensions() returns registered extensions`

3. **Single file import tests:**
   - `importFile() returns validated CanonicalNode[]`
   - `importFile() validates nodes with CanonicalNodeSchema`
   - `importFile() throws if node fails validation`
   - `importFile() routes to correct importer by extension`

4. **Batch import tests:**
   - `importFiles() processes multiple files`
   - `importFiles() collects errors without failing entire batch`
   - `importFiles() returns correct imported/skipped counts`
   - `importFiles() includes duration in result`
   - `importFiles() returns all nodes in nodes array`

**Helper function for creating valid test nodes:**
```typescript
function createValidNode(name: string): CanonicalNode {
  const now = new Date().toISOString();
  return {
    id: uuidv4(),
    nodeType: 'note',
    name,
    content: null,
    summary: null,
    latitude: null,
    longitude: null,
    locationName: null,
    locationAddress: null,
    createdAt: now,
    modifiedAt: now,
    dueAt: null,
    completedAt: null,
    eventStart: null,
    eventEnd: null,
    folder: null,
    tags: [],
    status: null,
    priority: 0,
    importance: 0,
    sortOrder: 0,
    gridX: 0,
    gridY: 0,
    source: 'test',
    sourceId: null,
    sourceUrl: null,
    deletedAt: null,
    version: 1,
    properties: {},
  };
}
```

**Minimum test coverage:** 10+ test cases covering all requirements.
  </action>
  <verify>
Tests pass:
```bash
npm run test -- --run src/etl/__tests__/ImportCoordinator.test.ts
```

All test cases execute (should be 10+):
```bash
npm run test -- --run src/etl/__tests__/ImportCoordinator.test.ts 2>&1 | grep -E "^\s*(✓|✗|Tests:)"
```
  </verify>
  <done>
- ImportCoordinator.test.ts has 10+ test cases
- All tests pass
- Coverage includes format detection, registration, single import, and batch import
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. TypeScript compilation:
```bash
npm run check:types
```

2. All tests pass:
```bash
npm run test -- --run src/etl/__tests__/ImportCoordinator.test.ts
```

3. Files exist with correct structure:
```bash
ls -la src/etl/importers/BaseImporter.ts src/etl/coordinator/ImportCoordinator.ts src/etl/__tests__/ImportCoordinator.test.ts
```
</verification>

<success_criteria>
- ImportCoordinator.detectFormat() correctly extracts and normalizes file extensions
- ImportCoordinator.registerImporter() allows dynamic importer registration
- ImportCoordinator.importFile() routes to registered importer and validates output
- ImportCoordinator.importFiles() processes batches with error collection
- BaseImporter defines abstract parse/transform contract with Template Method
- All 10+ unit tests pass
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/68-import-coordinator/68-01-SUMMARY.md`
</output>
