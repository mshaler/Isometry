---
phase: 98-isometry-embeds
plan: 03
type: execute
wave: 2
depends_on: ["98-01"]
files_modified:
  - src/components/notebook/editor/nodes/EmbedNode.tsx
  - src/components/notebook/editor/nodes/EmbedToolbar.tsx
  - src/components/notebook/editor/nodes/EmbedNode.css
autonomous: true

must_haves:
  truths:
    - "Embeds have toolbar for view switching (grid/network/timeline)"
    - "User can switch embed type without reinserting"
  artifacts:
    - path: "src/components/notebook/editor/nodes/EmbedToolbar.tsx"
      provides: "Toolbar component for embed controls"
      exports: ["EmbedToolbar"]
  key_links:
    - from: "EmbedNode.tsx"
      to: "EmbedToolbar"
      via: "render composition"
      pattern: "<EmbedToolbar"
    - from: "EmbedToolbar"
      to: "updateAttributes"
      via: "TipTap NodeView API"
      pattern: "updateAttributes.*type"
---

<objective>
Add view-switching toolbar to embeds enabling users to toggle between SuperGrid, Network, and Timeline views.

Purpose: EMBED-06 requires embeds have toolbar for view switching. This allows users to explore their data through different projections without reinserting the embed.

Output: Embeds with interactive toolbar showing view toggle buttons
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/98-isometry-embeds/98-01-SUMMARY.md
@src/components/notebook/editor/nodes/EmbedNode.tsx
@src/components/notebook/editor/extensions/embed-types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EmbedToolbar Component</name>
  <files>
    src/components/notebook/editor/nodes/EmbedToolbar.tsx
  </files>
  <action>
Create toolbar component for embed view controls:

```typescript
import { memo } from 'react';
import type { EmbedType } from '../extensions/embed-types';

interface EmbedToolbarProps {
  currentType: EmbedType;
  onTypeChange: (type: EmbedType) => void;
  filter?: string;
  onFilterEdit?: () => void;
}

const VIEW_OPTIONS: { type: EmbedType; icon: string; label: string }[] = [
  { type: 'supergrid', icon: '\u2637', label: 'Grid' },      // &#9783; grid icon
  { type: 'network', icon: '\u2B55', label: 'Network' },     // &#11093; circle
  { type: 'timeline', icon: '\u2500', label: 'Timeline' },   // &#9472; horizontal line
];

export const EmbedToolbar = memo(function EmbedToolbar({
  currentType,
  onTypeChange,
  filter,
  onFilterEdit,
}: EmbedToolbarProps) {
  return (
    <div className="embed-toolbar" contentEditable={false}>
      <div className="embed-toolbar__views">
        {VIEW_OPTIONS.map(({ type, icon, label }) => (
          <button
            key={type}
            type="button"
            className={`embed-toolbar__btn ${currentType === type ? 'embed-toolbar__btn--active' : ''}`}
            onClick={() => onTypeChange(type)}
            title={label}
            aria-pressed={currentType === type}
          >
            <span className="embed-toolbar__icon">{icon}</span>
            <span className="embed-toolbar__label">{label}</span>
          </button>
        ))}
      </div>
      {filter && (
        <div className="embed-toolbar__filter">
          <span className="embed-toolbar__filter-label">Filter:</span>
          <code className="embed-toolbar__filter-value">{filter}</code>
          {onFilterEdit && (
            <button
              type="button"
              className="embed-toolbar__filter-edit"
              onClick={onFilterEdit}
              title="Edit filter"
            >
              Edit
            </button>
          )}
        </div>
      )}
    </div>
  );
});
```

Key patterns:
- Use memo to prevent unnecessary re-renders
- contentEditable={false} prevents TipTap capturing toolbar clicks (CALL-03)
- Unicode escapes for icons to avoid encoding issues (CALL-02)
- aria-pressed for accessibility
  </action>
  <verify>
TypeScript compiles: `npm run typecheck`
Component exports: grep for "export.*EmbedToolbar" in EmbedToolbar.tsx
  </verify>
  <done>
EmbedToolbar component exists with view toggle buttons and filter display
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate Toolbar into EmbedNode</name>
  <files>
    src/components/notebook/editor/nodes/EmbedNode.tsx
  </files>
  <action>
Wire EmbedToolbar into EmbedNode component:

1. Import EmbedToolbar

2. Update EmbedNode to render toolbar:
```typescript
export function EmbedNode({ node, updateAttributes }: NodeViewProps) {
  const handleTypeChange = useCallback((newType: EmbedType) => {
    updateAttributes({ type: newType });
  }, [updateAttributes]);

  const handleFilterEdit = useCallback(() => {
    // For now, log intent - full filter editor is future enhancement
    console.log('Filter edit requested for:', node.attrs.filter);
    // Could dispatch custom event for modal:
    // window.dispatchEvent(new CustomEvent('isometry:edit-embed-filter', { ... }));
  }, [node.attrs.filter]);

  return (
    <NodeViewWrapper className={`embed embed--${node.attrs.type}`}>
      <EmbedToolbar
        currentType={node.attrs.type}
        onTypeChange={handleTypeChange}
        filter={node.attrs.filter}
        onFilterEdit={node.attrs.filter ? handleFilterEdit : undefined}
      />
      <div className="embed__content">
        {/* Conditional rendering by type */}
        {node.attrs.type === 'supergrid' && <SuperGridEmbed node={node} />}
        {node.attrs.type === 'network' && <NetworkEmbed node={node} />}
        {node.attrs.type === 'timeline' && <TimelineEmbed node={node} />}
      </div>
    </NodeViewWrapper>
  );
}
```

3. When type changes via toolbar:
   - updateAttributes triggers re-render
   - New type is persisted in node attrs
   - useEmbedData in child component will use new type

4. Ensure sub-components handle type prop correctly:
   - Pass node.attrs.type to useEmbedData
   - D3 instance cleanup when type changes
  </action>
  <verify>
TypeScript compiles: `npm run typecheck`
Toolbar rendered: grep for "EmbedToolbar" in EmbedNode.tsx
  </verify>
  <done>
EmbedNode renders toolbar above visualization, type changes update embed view
  </done>
</task>

<task type="auto">
  <name>Task 3: Style Embed Toolbar</name>
  <files>
    src/components/notebook/editor/nodes/EmbedNode.css
  </files>
  <action>
Add toolbar styles to EmbedNode.css:

```css
/* Embed Toolbar */
.embed-toolbar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 12px;
  background: var(--bg-secondary, #f5f5f5);
  border-bottom: 1px solid var(--border-color, #e0e0e0);
  border-radius: 8px 8px 0 0;
  font-size: 13px;
  user-select: none;
}

.embed-toolbar__views {
  display: flex;
  gap: 4px;
}

.embed-toolbar__btn {
  display: flex;
  align-items: center;
  gap: 4px;
  padding: 4px 8px;
  border: 1px solid var(--border-color, #e0e0e0);
  border-radius: 4px;
  background: var(--bg-primary, white);
  color: var(--text-secondary, #666);
  cursor: pointer;
  transition: all 0.15s ease;
}

.embed-toolbar__btn:hover {
  background: var(--bg-hover, #f0f0f0);
  border-color: var(--border-hover, #ccc);
}

.embed-toolbar__btn--active {
  background: var(--accent-bg, #e3f2fd);
  border-color: var(--accent-color, #2196f3);
  color: var(--accent-color, #2196f3);
}

.embed-toolbar__icon {
  font-size: 14px;
}

.embed-toolbar__label {
  font-weight: 500;
}

.embed-toolbar__filter {
  display: flex;
  align-items: center;
  gap: 6px;
  color: var(--text-secondary, #666);
}

.embed-toolbar__filter-label {
  font-weight: 500;
}

.embed-toolbar__filter-value {
  padding: 2px 6px;
  background: var(--bg-code, #f0f0f0);
  border-radius: 3px;
  font-family: var(--font-mono, monospace);
  font-size: 12px;
  max-width: 200px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.embed-toolbar__filter-edit {
  padding: 2px 8px;
  border: 1px solid var(--border-color, #e0e0e0);
  border-radius: 3px;
  background: transparent;
  color: var(--text-secondary, #666);
  cursor: pointer;
  font-size: 12px;
}

.embed-toolbar__filter-edit:hover {
  background: var(--bg-hover, #f0f0f0);
}

/* Theme support */
[data-theme="nextstep"] .embed-toolbar {
  background: #c0c0c0;
  border-color: #808080;
}

[data-theme="nextstep"] .embed-toolbar__btn--active {
  background: #a0a0a0;
  border-color: #404040;
}
```

Ensure overall embed container styles are updated:
```css
.embed {
  position: relative;
  margin: 16px 0;
  border: 1px solid var(--border-color, #e0e0e0);
  border-radius: 8px;
  overflow: hidden;
  background: var(--bg-primary, white);
}

.embed__content {
  min-height: 300px;
  position: relative;
}
```
  </action>
  <verify>
CSS file has toolbar styles: grep for "embed-toolbar" in EmbedNode.css
Theme support: grep for "nextstep" in EmbedNode.css
  </verify>
  <done>
Toolbar styled with view buttons, filter display, and theme support
  </done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes
2. Start dev server: `npm run dev`
3. Insert /supergrid embed
4. See toolbar with Grid/Network/Timeline buttons
5. Click Network button - view switches to force graph
6. Click Timeline button - view switches to timeline
7. Click Grid button - view returns to SuperGrid
8. Verify toolbar styling matches theme (try both themes)
</verification>

<success_criteria>
- EmbedToolbar component renders view toggle buttons
- Clicking buttons changes embed type via updateAttributes
- View smoothly transitions between types
- Filter is displayed in toolbar when present
- Styling follows theme variables
</success_criteria>

<output>
After completion, create `.planning/phases/98-isometry-embeds/98-03-SUMMARY.md`
</output>
