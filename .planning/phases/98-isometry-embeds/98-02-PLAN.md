---
phase: 98-isometry-embeds
plan: 02
type: execute
wave: 2
depends_on: ["98-01"]
files_modified:
  - src/components/notebook/editor/nodes/EmbedNode.tsx
  - src/components/notebook/editor/extensions/EmbedExtension.ts
  - src/hooks/embed/useEmbedData.ts
autonomous: true

must_haves:
  truths:
    - "Embeds update automatically when underlying data changes"
    - "Embeds respect LATCH filter parameters"
  artifacts:
    - path: "src/hooks/embed/useEmbedData.ts"
      provides: "Hook for live data subscription with dataVersion"
      exports: ["useEmbedData"]
  key_links:
    - from: "EmbedNode.tsx"
      to: "useEmbedData"
      via: "hook call"
      pattern: "useEmbedData"
    - from: "useEmbedData.ts"
      to: "useSQLiteQuery"
      via: "data fetching"
      pattern: "useSQLiteQuery|dataVersion"
---

<objective>
Add live data updates to embeds using dataVersion reactivity and LATCH filter support.

Purpose: Embeds must reflect the current database state. When cards are added/modified/deleted, embeds should re-render automatically. This leverages the existing dataVersion pattern from useSQLiteQuery.

Output: Embeds that automatically update when data changes and respect filter parameters
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/98-isometry-embeds/98-01-SUMMARY.md
@src/hooks/database/useSQLiteQuery.ts
@src/db/SQLiteProvider.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useEmbedData Hook</name>
  <files>
    src/hooks/embed/useEmbedData.ts
    src/hooks/embed/index.ts
    src/hooks/index.ts
  </files>
  <action>
Create hook for live embed data with LATCH filter support:

1. Create `src/hooks/embed/useEmbedData.ts`:

```typescript
import { useMemo } from 'react';
import { useSQLiteQuery, useNodes } from '../database/useSQLiteQuery';
import { useSQLite } from '../../db/SQLiteProvider';
import type { Node } from '../../types/node';
import type { EmbedType } from '../../components/notebook/editor/extensions/embed-types';

export interface EmbedDataOptions {
  type: EmbedType;
  filter?: string;  // LATCH filter clause (e.g., "folder = 'work'")
  limit?: number;
}

export interface EmbedDataResult {
  nodes: Node[];
  edges: { source: string; target: string; type: string; weight: number }[];
  loading: boolean;
  error: Error | null;
}

export function useEmbedData(options: EmbedDataOptions): EmbedDataResult {
  const { type, filter, limit = 100 } = options;
  const { dataVersion } = useSQLite();

  // Build WHERE clause from filter
  const whereClause = useMemo(() => {
    if (filter) {
      return `(${filter}) AND deleted_at IS NULL`;
    }
    return 'deleted_at IS NULL';
  }, [filter]);

  // Query nodes
  const nodesQuery = useNodes(whereClause, [], { enabled: true });

  // Query edges for network view (only when type is 'network')
  const edgesSQL = useMemo(() => `
    SELECT source_id as source, target_id as target, edge_type as type, weight
    FROM edges
    WHERE source_id IN (SELECT id FROM nodes WHERE ${whereClause})
    LIMIT ?
  `, [whereClause]);

  const edgesQuery = useSQLiteQuery<{source: string; target: string; type: string; weight: number}>(
    edgesSQL,
    [limit],
    { enabled: type === 'network' }
  );

  return {
    nodes: nodesQuery.data ?? [],
    edges: edgesQuery.data ?? [],
    loading: nodesQuery.loading || edgesQuery.loading,
    error: nodesQuery.error || edgesQuery.error,
  };
}
```

2. Create `src/hooks/embed/index.ts`:
```typescript
export { useEmbedData } from './useEmbedData';
export type { EmbedDataOptions, EmbedDataResult } from './useEmbedData';
```

3. Update `src/hooks/index.ts` to export from embed folder.

Key insight: useSQLiteQuery already depends on dataVersion from SQLiteProvider, so data will automatically refetch when dataVersion changes.
  </action>
  <verify>
TypeScript compiles: `npm run typecheck`
Hook exports: grep for "useEmbedData" in src/hooks/embed/index.ts
  </verify>
  <done>
useEmbedData hook exists, uses dataVersion for reactivity, supports filter parameter
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire Live Data to EmbedNode Components</name>
  <files>
    src/components/notebook/editor/nodes/EmbedNode.tsx
  </files>
  <action>
Update EmbedNode to use useEmbedData for live updates:

1. Import useEmbedData hook

2. Update each embed sub-component:

For SuperGridEmbed:
```typescript
function SuperGridEmbed({ node }: { node: NodeViewProps['node'] }) {
  const containerRef = useRef<HTMLDivElement>(null);
  const engineRef = useRef<SuperGridEngine | null>(null);

  const { nodes, loading, error } = useEmbedData({
    type: 'supergrid',
    filter: node.attrs.filter,
  });

  useEffect(() => {
    if (!containerRef.current || loading) return;

    // Create or update engine
    if (!engineRef.current) {
      engineRef.current = new SuperGridEngine(db, {
        width: node.attrs.width || 600,
        height: node.attrs.height || 400,
      });
      engineRef.current.mount(containerRef.current);
    }

    // Update data - engine handles enter/update/exit
    engineRef.current.setData(nodes);

    return () => {
      engineRef.current?.unmount();
      engineRef.current = null;
    };
  }, [nodes, loading]);

  // ... render
}
```

For NetworkEmbed:
```typescript
function NetworkEmbed({ node }: { node: NodeViewProps['node'] }) {
  const svgRef = useRef<SVGGElement>(null);
  const rendererRef = useRef<ForceGraphRenderer | null>(null);

  const { nodes, edges, loading } = useEmbedData({
    type: 'network',
    filter: node.attrs.filter,
  });

  useEffect(() => {
    if (!svgRef.current || loading || nodes.length === 0) return;

    // Transform nodes to GraphNode format
    const graphNodes = nodes.map(n => ({
      id: n.id,
      label: n.name,
      group: n.folder || 'default',
    }));

    // Transform edges to GraphLink format
    const graphLinks = edges.map(e => ({
      source: e.source,
      target: e.target,
      type: e.type,
      weight: e.weight || 1,
    }));

    // Create or update renderer
    if (!rendererRef.current) {
      rendererRef.current = new ForceGraphRenderer();
    }

    rendererRef.current.render(svgRef.current, graphNodes, graphLinks, {
      width: node.attrs.width || 600,
      height: node.attrs.height || 400,
    });

    return () => {
      rendererRef.current?.destroy();
    };
  }, [nodes, edges, loading]);

  // ... render
}
```

For TimelineEmbed:
```typescript
function TimelineEmbed({ node }: { node: NodeViewProps['node'] }) {
  const svgRef = useRef<SVGGElement>(null);

  const { nodes, loading } = useEmbedData({
    type: 'timeline',
    filter: node.attrs.filter,
  });

  useEffect(() => {
    if (!svgRef.current || loading || nodes.length === 0) return;

    // Transform nodes to TimelineEvent format
    const events = nodes.map(n => ({
      id: n.id,
      label: n.name,
      timestamp: new Date(n.created_at || Date.now()),
      track: n.folder || 'default',
    }));

    createTimeline(svgRef.current, events, {
      width: node.attrs.width || 600,
      height: node.attrs.height || 400,
    });
  }, [nodes, loading]);

  // ... render
}
```

3. Key patterns to maintain:
   - Use refs for D3 instances to avoid recreation on every render
   - Cleanup on unmount to prevent memory leaks
   - D3 handles enter/update/exit internally
  </action>
  <verify>
TypeScript compiles: `npm run typecheck`
Hook imported: grep for "useEmbedData" in EmbedNode.tsx
Effect cleanup: grep for "unmount\|destroy" in EmbedNode.tsx
  </verify>
  <done>
All three embed types use useEmbedData for live data, with proper D3 instance management and cleanup
  </done>
</task>

<task type="auto">
  <name>Task 3: Add Filter Parameter Support to Embed Commands</name>
  <files>
    src/components/notebook/editor/extensions/EmbedExtension.ts
    src/components/notebook/editor/extensions/slash-commands.ts
  </files>
  <action>
Enhance embed insertion to support filter parameters:

1. Update EmbedExtension setEmbed command signature:
```typescript
setEmbed: (type: EmbedType, options?: { filter?: string; width?: number; height?: number }) => ReturnType;
```

2. Update command implementation:
```typescript
setEmbed: (type, options = {}) => ({ commands }) => {
  return commands.insertContent({
    type: this.name,
    attrs: {
      type,
      filter: options.filter || '',
      width: options.width || 600,
      height: options.height || 400,
    },
  });
},
```

3. For now, slash commands insert without filter (default behavior):
```typescript
action: ({ editor, range }) => {
  editor.chain().focus().deleteRange(range).setEmbed('supergrid').run();
},
```

Filter editing will be added via the toolbar in Plan 98-03.

4. Document the filter syntax in code comments:
```typescript
// Filter syntax follows SQL WHERE clause format:
// - "folder = 'work'" - filter by folder
// - "status = 'active'" - filter by status
// - "created_at > '2024-01-01'" - filter by date
// - Multiple conditions: "folder = 'work' AND status = 'active'"
```
  </action>
  <verify>
TypeScript compiles: `npm run typecheck`
Options parameter: grep for "filter.*width.*height" in EmbedExtension.ts
  </verify>
  <done>
EmbedExtension supports filter, width, height parameters; data updates automatically when these change
  </done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes
2. Start dev server: `npm run dev`
3. Insert /supergrid embed
4. Open another window/tab, add a new card
5. Return to embed - should show new card without refresh
6. Insert /network embed - should show nodes and edges
7. Insert /timeline embed - should show cards on timeline
</verification>

<success_criteria>
- useEmbedData hook fetches nodes/edges based on type
- dataVersion changes trigger automatic refetch
- SuperGrid, Network, Timeline embeds all render live data
- Filter parameter is accepted (toolbar for editing in next plan)
- No memory leaks on unmount
</success_criteria>

<output>
After completion, create `.planning/phases/98-isometry-embeds/98-02-SUMMARY.md`
</output>
