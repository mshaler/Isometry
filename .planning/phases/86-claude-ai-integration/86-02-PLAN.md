---
phase: 86-claude-ai-integration
plan: 02
type: execute
wave: 2
depends_on: [86-01]
files_modified:
  - src/services/claude-ai/claudeService.ts
  - src/services/claude-ai/projectContext.ts
  - src/hooks/useClaudeAI.ts
  - src/components/claude-ai/ClaudeAIChat.tsx
autonomous: true

must_haves:
  truths:
    - "Claude understands Isometry's architecture and concepts"
    - "Active card context is included in conversations"
    - "Database schema available for data queries"
  artifacts:
    - path: "src/services/claude-ai/projectContext.ts"
      provides: "Project context builder"
      contains: "buildSystemPrompt"
    - path: "src/hooks/useClaudeAI.ts"
      provides: "Context-aware chat hook"
      contains: "useProjectContext"
  key_links:
    - from: "projectContext.ts"
      to: "claudeService"
      via: "systemPrompt"
      pattern: "buildSystemPrompt"
---

<objective>
Add Isometry project context to Claude AI conversations.

Purpose: Make Claude understand Isometry's architecture (LATCH, GRAPH, PAFV, SuperGrid) and have awareness of the current card/node being viewed. This transforms the chat from a generic assistant to an Isometry-aware helper.

Output:
- Project context builder that creates rich system prompts
- Active card context injection
- Database schema awareness for data queries
- PAFV/LATCH/GRAPH concept understanding
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/86-claude-ai-integration/86-01-SUMMARY.md
@src/services/claude-ai/claudeService.ts
@src/hooks/useClaudeAI.ts
@src/db/schema.sql
@CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create project context builder</name>
  <files>
    src/services/claude-ai/projectContext.ts
    src/services/claude-ai/index.ts
  </files>
  <action>
Create a project context builder that generates rich system prompts.

**Create src/services/claude-ai/projectContext.ts:**
```typescript
import { devLogger } from '@/utils/logging';

export interface CardContext {
  id: string;
  name: string;
  folder?: string;
  tags?: string[];
  content?: string;
  nodeType?: string;
}

export interface ProjectContext {
  activeCard?: CardContext;
  recentCards?: CardContext[];
  currentView?: 'supergrid' | 'network' | 'kanban' | 'timeline';
  filters?: Record<string, string[]>;
}

/**
 * Isometry Architecture Reference for Claude
 */
const ISOMETRY_ARCHITECTURE = `
## Isometry Architecture

You are integrated into Isometry, a polymorphic data projection platform.

### Core Concepts

**PAFV (Planes → Axes → Facets → Values)**
The spatial projection system that maps data dimensions to screen coordinates.
- Planes: x, y, z (screen coordinates)
- Axes: LATCH dimensions mapped to planes
- Facets: Specific attributes within an axis
- Values: Cards (Nodes + Edges in the LPG)

**LATCH (Location, Alphabet, Time, Category, Hierarchy)**
The five filtering/sorting dimensions. LATCH *separates* data into groups.

**GRAPH (Link, Nest, Sequence, Affinity)**
The four edge types connecting nodes. GRAPH *joins* data across groups.

**LPG (Labeled Property Graph)**
Nodes and edges are both first-class entities with properties. Edges are cards.

### Key Features

**SuperGrid**: Nested dimensional headers with orthogonal density controls.
- Grid Continuum: Gallery → List → Kanban → 2D Grid → nD SuperGrid
- Each view is a different PAFV axis allocation

**Three-Canvas Notebook**:
- Capture: TipTap editor for quick notes
- Shell: Claude AI (you), Claude Code terminal, GSD GUI
- Preview: SuperGrid, Network Graph, Data Inspector

### Data Model

Primary tables: nodes, edges, facets, notebook_cards
- nodes: Cards with LATCH columns (location, time, category, hierarchy)
- edges: Relationships (LINK, NEST, SEQUENCE, AFFINITY)
- facets: Available filtering dimensions for PAFV projection
- notebook_cards: Extended notebook functionality linked to nodes

### Technology Stack

- sql.js (SQLite in WASM) for data storage
- D3.js for all visualization
- React for UI chrome only
- TypeScript strict mode
`;

/**
 * Build a context-aware system prompt for Claude
 */
export function buildSystemPrompt(context?: ProjectContext): string {
  const parts: string[] = [
    'You are a helpful AI assistant integrated into Isometry.',
    ISOMETRY_ARCHITECTURE
  ];

  // Add active card context if available
  if (context?.activeCard) {
    const card = context.activeCard;
    parts.push(`
## Current Context

You are viewing a card with the following details:
- **Name**: ${card.name}
- **ID**: ${card.id}
${card.folder ? `- **Folder**: ${card.folder}` : ''}
${card.tags?.length ? `- **Tags**: ${card.tags.join(', ')}` : ''}
${card.nodeType ? `- **Type**: ${card.nodeType}` : ''}
${card.content ? `\n**Content Preview**:\n\`\`\`\n${card.content.slice(0, 500)}${card.content.length > 500 ? '...' : ''}\n\`\`\`` : ''}
`);
  }

  // Add current view context
  if (context?.currentView) {
    parts.push(`\nUser is currently viewing the ${context.currentView} view.`);
  }

  // Add active filters
  if (context?.filters && Object.keys(context.filters).length > 0) {
    const filterStr = Object.entries(context.filters)
      .map(([key, values]) => `${key}: ${values.join(', ')}`)
      .join('; ');
    parts.push(`\nActive filters: ${filterStr}`);
  }

  // Behavioral guidance
  parts.push(`
## Guidelines

1. When discussing data operations, use SQL terminology (nodes, edges, facets)
2. Reference LATCH dimensions for filtering/sorting suggestions
3. Reference GRAPH edge types for relationship queries
4. Explain SuperGrid concepts when relevant
5. Be concise but thorough - users are developers
6. When asked about architecture, reference the PAFV system
`);

  devLogger.debug('Built system prompt', {
    component: 'projectContext',
    hasActiveCard: !!context?.activeCard,
    currentView: context?.currentView
  });

  return parts.join('\n');
}

/**
 * Build a minimal context for quick queries
 */
export function buildMinimalPrompt(): string {
  return `You are a helpful AI assistant integrated into Isometry, a polymorphic data projection platform. Be concise and technical.`;
}
```

**Update src/services/claude-ai/index.ts:**
```typescript
export { claudeService, type ChatMessage, type StreamCallbacks } from './claudeService';
export { buildSystemPrompt, buildMinimalPrompt, type CardContext, type ProjectContext } from './projectContext';
```
  </action>
  <verify>
    `npm run typecheck` passes.
    buildSystemPrompt returns string with architecture context.
    CardContext and ProjectContext types exported.
  </verify>
  <done>
    Project context builder created.
    Isometry architecture reference embedded.
    Active card context support.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useProjectContext hook</name>
  <files>
    src/hooks/useProjectContext.ts
    src/hooks/index.ts
  </files>
  <action>
Create a hook to gather current project context.

**Create src/hooks/useProjectContext.ts:**
```typescript
import { useMemo, useCallback } from 'react';
import { useFilterContext } from '@/contexts/FilterContext';
import { useSQLiteQuery } from './database/useSQLiteQuery';
import type { CardContext, ProjectContext } from '@/services/claude-ai';
import { devLogger } from '@/utils/logging';

interface UseProjectContextOptions {
  activeNodeId?: string;
}

/**
 * Hook to gather current Isometry project context for Claude AI
 */
export function useProjectContext(options: UseProjectContextOptions = {}) {
  const { state: filterState } = useFilterContext();

  // Query active card if ID provided
  const { data: activeCardData } = useSQLiteQuery<{
    id: string;
    name: string;
    folder: string;
    tags: string;
    node_type: string;
  }>(
    options.activeNodeId
      ? `SELECT id, name, folder, tags, node_type FROM nodes WHERE id = ?`
      : null,
    options.activeNodeId ? [options.activeNodeId] : []
  );

  // Query notebook content if available
  const { data: notebookData } = useSQLiteQuery<{
    markdown_content: string;
  }>(
    options.activeNodeId
      ? `SELECT markdown_content FROM notebook_cards WHERE node_id = ?`
      : null,
    options.activeNodeId ? [options.activeNodeId] : []
  );

  // Build card context from query results
  const activeCard = useMemo((): CardContext | undefined => {
    if (!activeCardData || activeCardData.length === 0) return undefined;

    const card = activeCardData[0];
    const content = notebookData?.[0]?.markdown_content;

    return {
      id: card.id,
      name: card.name,
      folder: card.folder,
      tags: card.tags ? JSON.parse(card.tags) : [],
      nodeType: card.node_type,
      content
    };
  }, [activeCardData, notebookData]);

  // Convert filter state to simple record
  const filters = useMemo((): Record<string, string[]> => {
    const result: Record<string, string[]> = {};

    if (filterState.category?.folder) {
      result.folder = [filterState.category.folder];
    }
    if (filterState.category?.tags?.length) {
      result.tags = filterState.category.tags;
    }
    if (filterState.category?.status) {
      result.status = [filterState.category.status];
    }

    return result;
  }, [filterState]);

  // Build complete project context
  const projectContext = useMemo((): ProjectContext => {
    return {
      activeCard,
      filters: Object.keys(filters).length > 0 ? filters : undefined,
      currentView: 'supergrid' // TODO: Get from view context when available
    };
  }, [activeCard, filters]);

  // Memoized getter for context
  const getContext = useCallback(() => {
    devLogger.debug('Getting project context', {
      component: 'useProjectContext',
      hasActiveCard: !!activeCard,
      filterCount: Object.keys(filters).length
    });
    return projectContext;
  }, [projectContext, activeCard, filters]);

  return {
    projectContext,
    activeCard,
    filters,
    getContext
  };
}
```

**Update src/hooks/index.ts** (add to System hooks section):
```typescript
export { useProjectContext } from './useProjectContext';
```
  </action>
  <verify>
    `npm run typecheck` passes.
    useProjectContext exported from hooks/index.ts.
    Hook returns projectContext object.
  </verify>
  <done>
    useProjectContext hook created.
    Integrates with FilterContext.
    Queries active card from database.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update useClaudeAI to use project context</name>
  <files>
    src/hooks/useClaudeAI.ts
  </files>
  <action>
Update the Claude AI hook to automatically include project context.

**Modify src/hooks/useClaudeAI.ts:**
```typescript
import { useState, useCallback, useRef, useMemo } from 'react';
import { claudeService, type ChatMessage, buildSystemPrompt, type ProjectContext } from '@/services/claude-ai';
import { devLogger } from '@/utils/logging';

interface UseClaudeAIOptions {
  systemPrompt?: string;
  projectContext?: ProjectContext;
  includeArchitecture?: boolean;
}

export function useClaudeAI(options: UseClaudeAIOptions = {}) {
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [streamingContent, setStreamingContent] = useState('');
  const abortRef = useRef(false);

  const isConfigured = claudeService.isConfigured();

  // Build system prompt with project context
  const effectiveSystemPrompt = useMemo(() => {
    // If explicit system prompt provided, use it
    if (options.systemPrompt) {
      return options.systemPrompt;
    }

    // If project context provided or architecture flag set, build rich prompt
    if (options.projectContext || options.includeArchitecture !== false) {
      return buildSystemPrompt(options.projectContext);
    }

    // Default minimal prompt
    return undefined;
  }, [options.systemPrompt, options.projectContext, options.includeArchitecture]);

  /**
   * Generate unique message ID
   */
  const generateId = () => `msg-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`;

  /**
   * Send a message to Claude
   */
  const sendMessage = useCallback(async (content: string) => {
    if (!content.trim() || isLoading) return;

    setError(null);
    abortRef.current = false;

    // Add user message
    const userMessage: ChatMessage = {
      id: generateId(),
      role: 'user',
      content: content.trim(),
      timestamp: new Date()
    };

    setMessages(prev => [...prev, userMessage]);
    setIsLoading(true);
    setStreamingContent('');

    // Prepare messages for API (exclude IDs and timestamps)
    const apiMessages = [...messages, userMessage].map(m => ({
      role: m.role,
      content: m.content
    }));

    try {
      let fullResponse = '';

      await claudeService.sendMessageStreaming(
        apiMessages,
        {
          onText: (text) => {
            if (abortRef.current) return;
            fullResponse += text;
            setStreamingContent(fullResponse);
          },
          onComplete: () => {
            if (abortRef.current) return;

            const assistantMessage: ChatMessage = {
              id: generateId(),
              role: 'assistant',
              content: fullResponse,
              timestamp: new Date()
            };

            setMessages(prev => [...prev, assistantMessage]);
            setStreamingContent('');
            setIsLoading(false);
          },
          onError: (err) => {
            devLogger.error('Claude chat error', { component: 'useClaudeAI', error: err });
            setError(err.message);
            setIsLoading(false);
            setStreamingContent('');
          }
        },
        effectiveSystemPrompt
      );
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Unknown error';
      setError(errorMessage);
      setIsLoading(false);
      setStreamingContent('');
    }
  }, [messages, isLoading, effectiveSystemPrompt]);

  /**
   * Clear chat history
   */
  const clearMessages = useCallback(() => {
    setMessages([]);
    setStreamingContent('');
    setError(null);
  }, []);

  /**
   * Stop current generation
   */
  const stopGeneration = useCallback(() => {
    abortRef.current = true;
    setIsLoading(false);

    // If there's partial content, save it as a message
    if (streamingContent) {
      const partialMessage: ChatMessage = {
        id: generateId(),
        role: 'assistant',
        content: streamingContent + '\n\n[Generation stopped]',
        timestamp: new Date()
      };
      setMessages(prev => [...prev, partialMessage]);
      setStreamingContent('');
    }
  }, [streamingContent]);

  return {
    messages,
    isLoading,
    error,
    streamingContent,
    isConfigured,
    sendMessage,
    clearMessages,
    stopGeneration
  };
}
```
  </action>
  <verify>
    `npm run typecheck` passes.
    useClaudeAI accepts projectContext option.
    System prompt includes architecture by default.
  </verify>
  <done>
    useClaudeAI updated to use project context.
    Architecture context included by default.
    Active card context supported.
  </done>
</task>

<task type="auto">
  <name>Task 4: Update ClaudeAIChat to pass context</name>
  <files>
    src/components/claude-ai/ClaudeAIChat.tsx
  </files>
  <action>
Update the chat component to gather and pass project context.

**Modify ClaudeAIChat.tsx to add context integration:**

Add import:
```typescript
import { useProjectContext } from '@/hooks';
```

Update the component to use project context:
```typescript
export function ClaudeAIChat({ className, systemPrompt }: ClaudeAIChatProps) {
  const [input, setInput] = useState('');
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLTextAreaElement>(null);

  // Get project context (will be undefined if no active card)
  const { projectContext } = useProjectContext();

  const {
    messages,
    isLoading,
    error,
    streamingContent,
    isConfigured,
    sendMessage,
    clearMessages,
    stopGeneration
  } = useClaudeAI({
    systemPrompt,
    projectContext,
    includeArchitecture: true
  });

  // ... rest of component unchanged
```

Also add a context indicator in the UI header area. After the "Start a conversation with Claude" empty state, add:
```typescript
{messages.length === 0 && !streamingContent && (
  <div className="flex items-center justify-center h-full text-gray-500">
    <div className="text-center">
      <Bot size={48} className="mx-auto mb-3 text-gray-600" />
      <p className="text-sm">Start a conversation with Claude</p>
      <p className="text-xs mt-1 text-gray-600">
        Type a message below and press Enter
      </p>
      {projectContext?.activeCard && (
        <p className="text-xs mt-2 text-purple-400">
          Context: {projectContext.activeCard.name}
        </p>
      )}
    </div>
  </div>
)}
```
  </action>
  <verify>
    `npm run typecheck` passes.
    ClaudeAIChat uses useProjectContext.
    Context indicator shows active card name.
  </verify>
  <done>
    ClaudeAIChat now passes project context.
    Context indicator shows active card.
    Architecture context always included.
  </done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes
2. Claude AI understands Isometry concepts when asked
3. Active card context appears in chat empty state
4. Responses reference LATCH/GRAPH/PAFV when relevant
5. System prompt includes architecture reference
</verification>

<success_criteria>
- CLAI-07: Claude knows about LATCH, GRAPH, PAFV, SuperGrid
- CLAI-08: Active card name visible in chat UI
- CLAI-09: System prompt includes architecture reference
- CLAI-10: Filter context included when filters active
- Claude can answer "What is SuperGrid?" accurately
</success_criteria>

<output>
After completion, create `.planning/phases/86-claude-ai-integration/86-02-SUMMARY.md`
</output>
