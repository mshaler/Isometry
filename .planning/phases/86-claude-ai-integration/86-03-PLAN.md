---
phase: 86-claude-ai-integration
plan: 03
type: execute
wave: 3
depends_on: [86-02]
files_modified:
  - src/services/claude-ai/claudeService.ts
  - src/services/claude-ai/tools.ts
  - src/services/claude-ai/index.ts
  - src/hooks/useClaudeAI.ts
autonomous: true

must_haves:
  truths:
    - "Claude can execute tools to query the database"
    - "Claude can search nodes and edges"
    - "Tool results are displayed in chat"
  artifacts:
    - path: "src/services/claude-ai/tools.ts"
      provides: "Tool definitions and handlers"
      contains: "searchNodes"
    - path: "src/services/claude-ai/claudeService.ts"
      provides: "Tool execution support"
      contains: "handleToolUse"
  key_links:
    - from: "claudeService"
      to: "tools.ts"
      via: "tool handler import"
      pattern: "executeToolHandler"
---

<objective>
Add tool execution support so Claude can query the Isometry database.

Purpose: Enable Claude to perform actions within Isometry - searching nodes, querying relationships, and retrieving card details. This makes Claude a functional assistant that can help users navigate and query their data.

Output:
- Tool definitions for database operations
- Tool execution handler in claudeService
- Tool result display in chat
- Core tools: searchNodes, getNode, queryEdges, getStats
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/86-claude-ai-integration/86-02-SUMMARY.md
@src/services/claude-ai/claudeService.ts
@src/db/schema.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define tools and handlers</name>
  <files>
    src/services/claude-ai/tools.ts
    src/services/claude-ai/index.ts
  </files>
  <action>
Create tool definitions and execution handlers.

**Create src/services/claude-ai/tools.ts:**
```typescript
import { DatabaseService } from '@/services/DatabaseService';
import { devLogger } from '@/utils/logging';

/**
 * Tool definitions for Claude AI
 * These follow the Anthropic tool format
 */
export interface ToolDefinition {
  name: string;
  description: string;
  input_schema: {
    type: 'object';
    properties: Record<string, {
      type: string;
      description: string;
      enum?: string[];
    }>;
    required?: string[];
  };
}

export interface ToolResult {
  success: boolean;
  data?: unknown;
  error?: string;
}

/**
 * Available tools for Claude
 */
export const tools: ToolDefinition[] = [
  {
    name: 'search_nodes',
    description: 'Search for nodes (cards) in the database using full-text search. Returns matching nodes with their details.',
    input_schema: {
      type: 'object',
      properties: {
        query: {
          type: 'string',
          description: 'Search query text. Uses FTS5 full-text search.'
        },
        limit: {
          type: 'number',
          description: 'Maximum number of results to return (default: 10)'
        },
        folder: {
          type: 'string',
          description: 'Optional folder filter'
        }
      },
      required: ['query']
    }
  },
  {
    name: 'get_node',
    description: 'Get detailed information about a specific node by ID.',
    input_schema: {
      type: 'object',
      properties: {
        id: {
          type: 'string',
          description: 'The node ID to retrieve'
        }
      },
      required: ['id']
    }
  },
  {
    name: 'query_edges',
    description: 'Query edges (relationships) between nodes. Can filter by edge type and source/target.',
    input_schema: {
      type: 'object',
      properties: {
        source_id: {
          type: 'string',
          description: 'Filter by source node ID'
        },
        target_id: {
          type: 'string',
          description: 'Filter by target node ID'
        },
        edge_type: {
          type: 'string',
          description: 'Filter by edge type',
          enum: ['LINK', 'NEST', 'SEQUENCE', 'AFFINITY']
        },
        limit: {
          type: 'number',
          description: 'Maximum number of results (default: 20)'
        }
      }
    }
  },
  {
    name: 'get_stats',
    description: 'Get statistics about the database - total nodes, edges, folders, tags.',
    input_schema: {
      type: 'object',
      properties: {}
    }
  },
  {
    name: 'list_folders',
    description: 'List all folders in the database with node counts.',
    input_schema: {
      type: 'object',
      properties: {}
    }
  },
  {
    name: 'list_tags',
    description: 'List all tags in the database with usage counts.',
    input_schema: {
      type: 'object',
      properties: {
        limit: {
          type: 'number',
          description: 'Maximum number of tags to return (default: 50)'
        }
      }
    }
  }
];

/**
 * Execute a tool and return the result
 */
export async function executeTool(
  name: string,
  input: Record<string, unknown>,
  db: DatabaseService
): Promise<ToolResult> {
  devLogger.debug('Executing tool', { component: 'tools', name, input });

  try {
    switch (name) {
      case 'search_nodes':
        return searchNodes(input, db);
      case 'get_node':
        return getNode(input, db);
      case 'query_edges':
        return queryEdges(input, db);
      case 'get_stats':
        return getStats(db);
      case 'list_folders':
        return listFolders(db);
      case 'list_tags':
        return listTags(input, db);
      default:
        return { success: false, error: `Unknown tool: ${name}` };
    }
  } catch (error) {
    devLogger.error('Tool execution failed', { component: 'tools', name, error });
    return {
      success: false,
      error: error instanceof Error ? error.message : String(error)
    };
  }
}

// Tool implementations

function searchNodes(input: Record<string, unknown>, db: DatabaseService): ToolResult {
  const query = input.query as string;
  const limit = (input.limit as number) || 10;
  const folder = input.folder as string | undefined;

  let sql = `
    SELECT n.id, n.name, n.folder, n.tags, n.status, n.created_at
    FROM nodes_fts
    JOIN nodes n ON nodes_fts.rowid = n.rowid
    WHERE nodes_fts MATCH ?
    AND n.deleted_at IS NULL
  `;
  const params: unknown[] = [query];

  if (folder) {
    sql += ` AND n.folder = ?`;
    params.push(folder);
  }

  sql += ` ORDER BY rank LIMIT ?`;
  params.push(limit);

  const results = db.query(sql, params);
  return { success: true, data: results };
}

function getNode(input: Record<string, unknown>, db: DatabaseService): ToolResult {
  const id = input.id as string;

  const results = db.query(`
    SELECT n.*, nc.markdown_content
    FROM nodes n
    LEFT JOIN notebook_cards nc ON n.id = nc.node_id
    WHERE n.id = ? AND n.deleted_at IS NULL
  `, [id]);

  if (results.length === 0) {
    return { success: false, error: `Node not found: ${id}` };
  }

  return { success: true, data: results[0] };
}

function queryEdges(input: Record<string, unknown>, db: DatabaseService): ToolResult {
  const sourceId = input.source_id as string | undefined;
  const targetId = input.target_id as string | undefined;
  const edgeType = input.edge_type as string | undefined;
  const limit = (input.limit as number) || 20;

  let sql = `
    SELECT e.*,
           s.name as source_name,
           t.name as target_name
    FROM edges e
    JOIN nodes s ON e.source_id = s.id
    JOIN nodes t ON e.target_id = t.id
    WHERE 1=1
  `;
  const params: unknown[] = [];

  if (sourceId) {
    sql += ` AND e.source_id = ?`;
    params.push(sourceId);
  }
  if (targetId) {
    sql += ` AND e.target_id = ?`;
    params.push(targetId);
  }
  if (edgeType) {
    sql += ` AND e.edge_type = ?`;
    params.push(edgeType);
  }

  sql += ` LIMIT ?`;
  params.push(limit);

  const results = db.query(sql, params);
  return { success: true, data: results };
}

function getStats(db: DatabaseService): ToolResult {
  const nodeCount = db.query(`SELECT COUNT(*) as count FROM nodes WHERE deleted_at IS NULL`)[0].count;
  const edgeCount = db.query(`SELECT COUNT(*) as count FROM edges`)[0].count;
  const folderCount = db.query(`SELECT COUNT(DISTINCT folder) as count FROM nodes WHERE folder IS NOT NULL AND deleted_at IS NULL`)[0].count;

  // Get tag count from JSON tags column
  const tagResult = db.query(`
    SELECT COUNT(*) as count FROM (
      SELECT DISTINCT value FROM nodes, json_each(nodes.tags)
      WHERE nodes.deleted_at IS NULL AND nodes.tags IS NOT NULL
    )
  `);
  const tagCount = tagResult[0]?.count || 0;

  return {
    success: true,
    data: {
      nodes: nodeCount,
      edges: edgeCount,
      folders: folderCount,
      tags: tagCount
    }
  };
}

function listFolders(db: DatabaseService): ToolResult {
  const results = db.query(`
    SELECT folder, COUNT(*) as node_count
    FROM nodes
    WHERE folder IS NOT NULL AND deleted_at IS NULL
    GROUP BY folder
    ORDER BY node_count DESC
  `);
  return { success: true, data: results };
}

function listTags(input: Record<string, unknown>, db: DatabaseService): ToolResult {
  const limit = (input.limit as number) || 50;

  const results = db.query(`
    SELECT value as tag, COUNT(*) as usage_count
    FROM nodes, json_each(nodes.tags)
    WHERE nodes.deleted_at IS NULL AND nodes.tags IS NOT NULL
    GROUP BY value
    ORDER BY usage_count DESC
    LIMIT ?
  `, [limit]);

  return { success: true, data: results };
}
```

**Update src/services/claude-ai/index.ts:**
```typescript
export { claudeService, type ChatMessage, type StreamCallbacks } from './claudeService';
export { buildSystemPrompt, buildMinimalPrompt, type CardContext, type ProjectContext } from './projectContext';
export { tools, executeTool, type ToolDefinition, type ToolResult } from './tools';
```
  </action>
  <verify>
    `npm run typecheck` passes.
    tools array exported with 6 tool definitions.
    executeTool function handles all tool types.
  </verify>
  <done>
    Tool definitions created.
    Tool handlers implemented.
    Exports added to index.ts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update claudeService with tool support</name>
  <files>
    src/services/claude-ai/claudeService.ts
  </files>
  <action>
Update claudeService to support tool use in messages.

**Modify src/services/claude-ai/claudeService.ts:**

Add tool imports and update the streaming method:
```typescript
import Anthropic from '@anthropic-ai/sdk';
import { devLogger } from '@/utils/logging';
import { tools, executeTool, type ToolResult } from './tools';
import { DatabaseService } from '@/services/DatabaseService';

// ... existing interfaces ...

export interface ToolUseEvent {
  type: 'tool_use';
  toolName: string;
  toolInput: Record<string, unknown>;
  toolId: string;
}

export interface StreamCallbacks {
  onText: (text: string) => void;
  onComplete: () => void;
  onError: (error: Error) => void;
  onToolUse?: (event: ToolUseEvent) => void;
  onToolResult?: (toolId: string, result: ToolResult) => void;
}

// ... existing ClaudeService class ...

// Add new method to ClaudeService:
/**
 * Send a message with tool support
 */
async sendMessageWithTools(
  messages: Array<{ role: 'user' | 'assistant'; content: string | unknown[] }>,
  callbacks: StreamCallbacks,
  systemPrompt?: string,
  db?: DatabaseService
): Promise<void> {
  try {
    const client = this.getClient();

    // Initial request with tools
    let response = await client.messages.create({
      model: this.model,
      max_tokens: 4096,
      system: systemPrompt || 'You are a helpful AI assistant integrated into Isometry.',
      tools: tools,
      messages: messages.map(m => ({
        role: m.role,
        content: m.content as string
      }))
    });

    // Process response, handling tool use
    while (response.stop_reason === 'tool_use') {
      // Find tool use blocks
      const toolUseBlocks = response.content.filter(
        block => block.type === 'tool_use'
      );

      // Execute tools and collect results
      const toolResults: Array<{
        type: 'tool_result';
        tool_use_id: string;
        content: string;
      }> = [];

      for (const block of toolUseBlocks) {
        if (block.type === 'tool_use') {
          const toolUseBlock = block as {
            type: 'tool_use';
            id: string;
            name: string;
            input: Record<string, unknown>;
          };

          callbacks.onToolUse?.({
            type: 'tool_use',
            toolName: toolUseBlock.name,
            toolInput: toolUseBlock.input,
            toolId: toolUseBlock.id
          });

          // Execute tool if db is available
          let result: ToolResult;
          if (db) {
            result = await executeTool(toolUseBlock.name, toolUseBlock.input, db);
          } else {
            result = {
              success: false,
              error: 'Database not available for tool execution'
            };
          }

          callbacks.onToolResult?.(toolUseBlock.id, result);

          toolResults.push({
            type: 'tool_result',
            tool_use_id: toolUseBlock.id,
            content: JSON.stringify(result)
          });
        }
      }

      // Extract any text content from the response
      for (const block of response.content) {
        if (block.type === 'text') {
          callbacks.onText(block.text);
        }
      }

      // Continue conversation with tool results
      const newMessages = [
        ...messages,
        { role: 'assistant' as const, content: response.content },
        { role: 'user' as const, content: toolResults }
      ];

      response = await client.messages.create({
        model: this.model,
        max_tokens: 4096,
        system: systemPrompt || 'You are a helpful AI assistant integrated into Isometry.',
        tools: tools,
        messages: newMessages as Anthropic.Messages.MessageParam[]
      });
    }

    // Final text response
    for (const block of response.content) {
      if (block.type === 'text') {
        callbacks.onText(block.text);
      }
    }

    callbacks.onComplete();
  } catch (error) {
    devLogger.error('Claude API error with tools', { component: 'ClaudeService', error });
    callbacks.onError(error instanceof Error ? error : new Error(String(error)));
  }
}
```
  </action>
  <verify>
    `npm run typecheck` passes.
    sendMessageWithTools method added.
    Tool execution loop implemented.
  </verify>
  <done>
    claudeService updated with tool support.
    Tool use events and results callbacks.
    Iterative tool execution loop.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update useClaudeAI hook for tools</name>
  <files>
    src/hooks/useClaudeAI.ts
  </files>
  <action>
Add tool support and result tracking to the hook.

**Update useClaudeAI.ts:**

Add new state and callback handlers:
```typescript
import { useState, useCallback, useRef, useMemo } from 'react';
import { claudeService, type ChatMessage, buildSystemPrompt, type ProjectContext, type ToolResult } from '@/services/claude-ai';
import { useDatabaseService } from './database/useDatabaseService';
import { devLogger } from '@/utils/logging';

interface ToolEvent {
  toolName: string;
  toolInput: Record<string, unknown>;
  result?: ToolResult;
}

interface UseClaudeAIOptions {
  systemPrompt?: string;
  projectContext?: ProjectContext;
  includeArchitecture?: boolean;
  enableTools?: boolean;
}

export function useClaudeAI(options: UseClaudeAIOptions = {}) {
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [streamingContent, setStreamingContent] = useState('');
  const [toolEvents, setToolEvents] = useState<ToolEvent[]>([]);
  const abortRef = useRef(false);

  const { db } = useDatabaseService();
  const isConfigured = claudeService.isConfigured();

  // ... rest of existing code with modifications to sendMessage ...

  const sendMessage = useCallback(async (content: string) => {
    // ... existing validation ...

    setToolEvents([]);

    try {
      let fullResponse = '';

      if (options.enableTools && db) {
        // Use tool-enabled endpoint
        await claudeService.sendMessageWithTools(
          apiMessages,
          {
            onText: (text) => {
              if (abortRef.current) return;
              fullResponse += text;
              setStreamingContent(fullResponse);
            },
            onComplete: () => {
              // ... handle complete ...
            },
            onError: (err) => {
              // ... handle error ...
            },
            onToolUse: (event) => {
              setToolEvents(prev => [...prev, {
                toolName: event.toolName,
                toolInput: event.toolInput
              }]);
            },
            onToolResult: (toolId, result) => {
              setToolEvents(prev =>
                prev.map(e =>
                  e.toolName === toolId ? { ...e, result } : e
                )
              );
            }
          },
          effectiveSystemPrompt,
          db
        );
      } else {
        // Use existing streaming endpoint
        await claudeService.sendMessageStreaming(/* ... */);
      }
    } catch (err) {
      // ... existing error handling ...
    }
  }, [messages, isLoading, effectiveSystemPrompt, options.enableTools, db]);

  return {
    messages,
    isLoading,
    error,
    streamingContent,
    isConfigured,
    toolEvents,
    sendMessage,
    clearMessages,
    stopGeneration
  };
}
```
  </action>
  <verify>
    `npm run typecheck` passes.
    toolEvents state added.
    Tool callbacks wired to sendMessageWithTools.
  </verify>
  <done>
    useClaudeAI updated with tool support.
    Tool events tracked in state.
    Database service integration.
  </done>
</task>

<task type="auto">
  <name>Task 4: Display tool results in chat</name>
  <files>
    src/components/claude-ai/ClaudeAIChat.tsx
  </files>
  <action>
Update the chat UI to show tool executions and results.

**Add tool display component to ClaudeAIChat.tsx:**

```typescript
interface ClaudeAIChatProps {
  className?: string;
  systemPrompt?: string;
  enableTools?: boolean;
}

// Add tool event display in the chat:
{toolEvents.length > 0 && (
  <div className="bg-gray-800/50 rounded-lg p-3 border border-gray-700">
    <div className="text-xs text-gray-400 mb-2">Tool Executions</div>
    {toolEvents.map((event, i) => (
      <div key={i} className="flex items-start gap-2 text-xs mb-2">
        <span className="text-purple-400">{event.toolName}</span>
        {event.result && (
          <span className={event.result.success ? 'text-green-400' : 'text-red-400'}>
            {event.result.success ? '✓' : '✗'}
          </span>
        )}
      </div>
    ))}
  </div>
)}
```

Pass enableTools to useClaudeAI:
```typescript
const { ..., toolEvents } = useClaudeAI({
  systemPrompt,
  projectContext,
  includeArchitecture: true,
  enableTools
});
```
  </action>
  <verify>
    `npm run typecheck` passes.
    Tool events display in chat.
    Success/failure indicators shown.
  </verify>
  <done>
    Tool execution UI added.
    Results displayed inline.
    Enable via prop.
  </done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes
2. Claude uses tools when asked database questions
3. Tool execution shows in chat UI
4. "How many nodes are there?" triggers get_stats tool
5. "Search for projects" triggers search_nodes tool
</verification>

<success_criteria>
- CLAI-11: Tools defined and exported
- CLAI-12: Tool execution works with database
- CLAI-13: Tool events displayed in UI
- CLAI-14: Search and stats tools functional
- Claude can answer "How many nodes are in the database?"
</success_criteria>

<output>
After completion, create `.planning/phases/86-claude-ai-integration/86-03-SUMMARY.md`
</output>
