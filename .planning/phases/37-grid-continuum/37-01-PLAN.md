---
phase: 37-grid-continuum
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/types/views.ts, src/d3/ViewContinuum.ts]
autonomous: true

must_haves:
  truths:
    - "ViewState can track current view type and per-view axis mappings"
    - "ViewContinuum can orchestrate switching between different view classes"
    - "ViewContinuum preserves selection state and LATCH filters across switches"
    - "ViewContinuum caches query results for consistent projection"
  artifacts:
    - path: "src/types/views.ts"
      provides: "ViewType enum, ViewState interface, ViewAxisMapping interface"
      exports: ["ViewType", "ViewState", "ViewAxisMapping"]
    - path: "src/d3/ViewContinuum.ts"
      provides: "Orchestrator managing view switching and state preservation"
      exports: ["ViewContinuum"]
  key_links:
    - from: "src/d3/ViewContinuum.ts"
      to: "localStorage"
      via: "state persistence"
      pattern: "localStorage\\.setItem.*ViewState"
    - from: "src/d3/ViewContinuum.ts"
      to: "view classes"
      via: "common interface delegation"
      pattern: "render\\(cards, axisMapping, activeFilters\\)"
---

<objective>
Establish view infrastructure and orchestration layer for seamless transitions between List, Kanban, and SuperGrid projections.

Purpose: Provide the foundational architecture for polymorphic data projection where view transitions are PAFV axis-to-plane remappings, not data changes. This enables the "any axis can map to any plane" principle from the architecture truth document.
Output: Type definitions and ViewContinuum orchestrator that manages view switching, state preservation, and transition coordination.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/37-grid-continuum/37-CONTEXT.md
@.planning/phases/37-grid-continuum/37-RESEARCH.md
@src/d3/SuperGrid.ts
@src/types/grid.ts
</context>

<tasks>

<task type="auto">
  <name>Create view type definitions and state interfaces</name>
  <files>src/types/views.ts</files>
  <action>
    Create comprehensive type definitions for view continuum system. Define ViewType enum with 'list', 'kanban', 'supergrid' values. Create ViewAxisMapping interface for PAFV axis-to-plane mappings per view type. Define ViewState interface tracking current view type, per-view axis mappings, per-view scroll/zoom state, focused card ID, and selection state (view-independent card ID set).

    Key interface requirements from CONTEXT.md:
    - ViewState stored per-canvas in localStorage (consistent with Phase 36 Janus pattern)
    - Selection persists as card IDs across view switches
    - Each view type stores its own PAFV axis-to-plane mapping
    - Focus/scroll position tracked by semantic card ID, not pixel coordinates

    Follow existing type patterns from src/types/grid.ts for consistency.
  </action>
  <verify>npm run typecheck passes with zero errors</verify>
  <done>ViewType enum, ViewState interface, and ViewAxisMapping interface exist and compile cleanly</done>
</task>

<task type="auto">
  <name>Implement ViewContinuum orchestrator class</name>
  <files>src/d3/ViewContinuum.ts</files>
  <action>
    Create ViewContinuum orchestrator that manages view switching, state preservation, and transition coordination. Owns SVG container and delegates rendering to active view class (ListView | KanbanView | SuperGrid).

    Core responsibilities:
    - Own and manage SVG container element
    - Manage ViewState (current view, per-view states) with localStorage persistence
    - Cache query result from LATCH filters, re-project on view switch
    - Coordinate FLIP animation transitions between views using D3 transitions
    - Preserve selection state, focus position, and LATCH filters across switches

    Architecture from CONTEXT.md: ViewContinuum owns SVG container, ViewState, cached query results, and delegates to view classes via common interface.

    Animation requirements: 300ms duration with d3.easeCubicOut easing, interruptible via selection.interrupt().

    Data layer: One query cached in memory, multiple projections. Re-query only when LATCH filters change, not on view switch.

    Follow existing D3 class patterns from SuperGrid.ts for consistency.
  </action>
  <verify>npm run typecheck passes, ViewContinuum class instantiates without errors</verify>
  <done>ViewContinuum orchestrator exists with view management, state persistence, and FLIP animation coordination methods</done>
</task>

</tasks>

<verification>
- ViewType enum provides 'list', 'kanban', 'supergrid' options
- ViewState interface captures all necessary state for view transitions
- ViewContinuum class follows established D3 patterns from SuperGrid
- State persistence uses localStorage matching Phase 36 approach
- FLIP animation infrastructure ready for view class integration
</verification>

<success_criteria>
- Type definitions enable view-agnostic state management
- ViewContinuum orchestrator can manage view switching lifecycle
- State persistence preserves user context across view transitions
- Foundation ready for ListView, KanbanView, and SuperGrid integration
</success_criteria>

<output>
After completion, create `.planning/phases/37-grid-continuum/37-01-SUMMARY.md`
</output>