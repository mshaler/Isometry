---
phase: 56-supergrid-pafv-projection
plan: 03
type: execute
wave: 2
depends_on: ["56-02"]
files_modified:
  - src/d3/grid-rendering/GridRenderingEngine.ts
autonomous: true

must_haves:
  truths:
    - "Cards render at computed grid positions"
    - "Column and row headers render from projection"
    - "Grid layout respects 2D positioning"
  artifacts:
    - path: "src/d3/grid-rendering/GridRenderingEngine.ts"
      provides: "2D grid rendering with projection headers"
      contains: "renderProjectionHeaders"
---

<objective>
Render cards at 2D grid positions computed from PAFV projection.

Purpose: Visual grid layout based on axis mappings.

Output: Cards appear in correct row/column based on their facet values.
</objective>

<context>
@.planning/phases/56-supergrid-pafv-projection/56-02-SUMMARY.md
@src/d3/grid-rendering/GridRenderingEngine.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add projection-aware grid layout</name>
  <files>
    src/d3/grid-rendering/GridRenderingEngine.ts
  </files>
  <action>
Update updateGridLayout() to use computed positions when projection exists:

```typescript
private updateGridLayout(): void {
  if (!this.currentData) return;

  // If we have projection and headers, use 2D grid layout
  if (this.currentProjection && this.currentHeaders) {
    this.updateProjectedGridLayout();
    return;
  }

  // Original flow-based layout...
  // (existing code)
}

/**
 * Update layout using projection-computed positions
 */
private updateProjectedGridLayout(): void {
  if (!this.currentData?.cards || !this.currentHeaders) return;

  const headerOffset = this.config.headerHeight + this.config.padding;
  const rowHeaderWidth = 120; // Width for row labels

  this.currentData.cards.forEach((card) => {
    const cardRecord = card as Record<string, unknown>;
    const row = cardRecord._projectedRow as number;
    const col = cardRecord._projectedCol as number;

    // Calculate position in grid
    if (col >= 0) {
      cardRecord.x = rowHeaderWidth + this.config.padding +
                     col * (this.config.cardWidth + this.config.padding);
    }
    if (row >= 0) {
      cardRecord.y = headerOffset +
                     row * (this.config.cardHeight + this.config.padding);
    }
  });

  // Update grid dimensions
  const numCols = this.currentHeaders.columns.length || 1;
  const numRows = this.currentHeaders.rows.length || 1;

  const gridWidth = rowHeaderWidth + numCols * (this.config.cardWidth + this.config.padding) + this.config.padding;
  const gridHeight = headerOffset + numRows * (this.config.cardHeight + this.config.padding) + this.config.padding;

  if (this.callbacks.onGridResize) {
    this.callbacks.onGridResize(gridWidth, gridHeight);
  }

  superGridLogger.debug('Projected grid layout:', {
    columns: numCols,
    rows: numRows,
    gridWidth,
    gridHeight,
  });
}
```
  </action>
  <verify>
    - updateProjectedGridLayout method exists
    - Cards get x/y from projected row/col
  </verify>
</task>

<task type="auto">
  <name>Task 2: Add projection header rendering</name>
  <files>
    src/d3/grid-rendering/GridRenderingEngine.ts
  </files>
  <action>
Add method to render column and row headers from projection:

```typescript
/**
 * Render headers from projection (column + row labels)
 */
private renderProjectionHeaders(): void {
  if (!this.currentHeaders) return;

  const headerContainer = this.container.select('.headers');
  headerContainer.selectAll('*').remove();

  const rowHeaderWidth = 120;
  const { columns, rows } = this.currentHeaders;

  // Render column headers
  headerContainer
    .selectAll('.col-header')
    .data(columns)
    .join('g')
    .attr('class', 'col-header')
    .attr('transform', (_, i) =>
      `translate(${rowHeaderWidth + this.config.padding + i * (this.config.cardWidth + this.config.padding)}, 0)`)
    .each(function(d) {
      const g = d3.select(this);
      g.append('rect')
        .attr('width', this.config.cardWidth)
        .attr('height', this.config.headerHeight)
        .attr('fill', '#f0f0f0')
        .attr('stroke', '#ddd')
        .attr('rx', 4);
      g.append('text')
        .attr('x', this.config.cardWidth / 2)
        .attr('y', this.config.headerHeight / 2 + 4)
        .attr('text-anchor', 'middle')
        .attr('font-size', '12px')
        .attr('fill', '#333')
        .text(d);
    }.bind(this));

  // Render row headers
  const headerOffset = this.config.headerHeight + this.config.padding;
  headerContainer
    .selectAll('.row-header')
    .data(rows)
    .join('g')
    .attr('class', 'row-header')
    .attr('transform', (_, i) =>
      `translate(0, ${headerOffset + i * (this.config.cardHeight + this.config.padding)})`)
    .each(function(d) {
      const g = d3.select(this);
      g.append('rect')
        .attr('width', rowHeaderWidth - 4)
        .attr('height', this.config.cardHeight)
        .attr('fill', '#f5f5f5')
        .attr('stroke', '#ddd')
        .attr('rx', 4);
      g.append('text')
        .attr('x', (rowHeaderWidth - 4) / 2)
        .attr('y', this.config.cardHeight / 2 + 4)
        .attr('text-anchor', 'middle')
        .attr('font-size', '11px')
        .attr('fill', '#666')
        .text(d);
    }.bind(this));

  superGridLogger.debug('Rendered projection headers:', {
    columns: columns.length,
    rows: rows.length,
  });
}
```
  </action>
  <verify>
    - renderProjectionHeaders method exists
    - Column headers render from currentHeaders.columns
    - Row headers render from currentHeaders.rows
  </verify>
</task>

<task type="auto">
  <name>Task 3: Wire projection headers into render flow</name>
  <files>
    src/d3/grid-rendering/GridRenderingEngine.ts
  </files>
  <action>
Update render() to use projection headers when available:

```typescript
public render(activeFilters: unknown[] = []): void {
  this.setupGridStructure();

  if (!this.currentData) {
    this.renderEmptyState();
    return;
  }

  // Compute positions from projection
  if (this.currentProjection && this.currentData.cards) {
    this.computeAllPositions(this.currentData.cards);
  }

  this.updateGridLayout();

  // Use projection headers if available, else fallback
  if (this.currentProjection && this.currentHeaders) {
    this.renderProjectionHeaders();
  } else if (this.config.enableHeaders) {
    this.renderHierarchicalHeaders(activeFilters);
  } else {
    this.renderSimpleFallbackHeader();
  }

  this.renderCards();
}
```
  </action>
  <verify>
    - render() calls renderProjectionHeaders when projection exists
  </verify>
</task>

</tasks>

<verification>
1. grep for "updateProjectedGridLayout" in GridRenderingEngine.ts
2. grep for "renderProjectionHeaders" in GridRenderingEngine.ts
3. Visual: Open app, drag facet to X-axis well, see cards reorganize into columns
4. Visual: Drag facet to Y-axis well, see cards organize into rows
</verification>

<success_criteria>
- Cards position at (x, y) computed from row/col indices
- Column headers show unique X-axis facet values
- Row headers show unique Y-axis facet values
- Changing projection triggers grid reorganization
</success_criteria>

<output>
After completion, create `.planning/phases/56-supergrid-pafv-projection/56-03-SUMMARY.md`
</output>
