---
phase: 56-supergrid-pafv-projection
plan: 02
type: execute
wave: 1
depends_on: ["56-01"]
files_modified:
  - src/d3/grid-rendering/GridRenderingEngine.ts
  - src/types/grid.ts
autonomous: true

must_haves:
  truths:
    - "GridRenderingEngine computes cell positions from projection"
    - "Headers are generated from unique facet values"
    - "Cards with null facet values go to 'Unassigned' bucket"
  artifacts:
    - path: "src/d3/grid-rendering/GridRenderingEngine.ts"
      provides: "computePositions and generateHeaders methods"
      contains: "computeCellPositions"
    - path: "src/types/grid.ts"
      provides: "GridHeaders interface"
      contains: "GridHeaders"
---

<objective>
Implement position computation in GridRenderingEngine using PAFV projection.

Purpose: Cards position based on their X-axis and Y-axis facet values.

Output: Each card gets a (row, col) position computed from projection facets.
</objective>

<context>
@.planning/phases/56-supergrid-pafv-projection/56-01-SUMMARY.md
@src/d3/grid-rendering/GridRenderingEngine.ts
@src/types/grid.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add GridHeaders interface to grid.ts</name>
  <files>
    src/types/grid.ts
  </files>
  <action>
Add after the ProjectedCellPosition interface:

```typescript
/**
 * Generated headers from unique facet values
 */
export interface GridHeaders {
  columns: string[];  // Unique X-axis values
  rows: string[];     // Unique Y-axis values
}
```
  </action>
  <verify>
    - GridHeaders interface exists
  </verify>
</task>

<task type="auto">
  <name>Task 2: Add header generation to GridRenderingEngine</name>
  <files>
    src/d3/grid-rendering/GridRenderingEngine.ts
  </files>
  <action>
1. Add import for GridHeaders:
   ```typescript
   import type { GridData, AxisData, PAFVProjection, GridHeaders } from '../../types/grid';
   ```

2. Add private member after currentProjection:
   ```typescript
   private currentHeaders: GridHeaders | null = null;
   ```

3. Add method after getProjection():
   ```typescript
   /**
    * Generate column and row headers from card data and projection
    */
   private generateProjectionHeaders(cards: unknown[]): GridHeaders {
     if (!this.currentProjection) {
       return { columns: [], rows: [] };
     }

     const xFacet = this.currentProjection.xAxis?.facet;
     const yFacet = this.currentProjection.yAxis?.facet;

     // Extract unique X-axis values
     const columns: string[] = xFacet
       ? [...new Set(cards.map(c => c[xFacet]).filter(v => v != null))].sort()
       : [];

     // Extract unique Y-axis values
     const rows: string[] = yFacet
       ? [...new Set(cards.map(c => c[yFacet]).filter(v => v != null))].sort()
       : [];

     // Add "Unassigned" bucket if there are cards with null values
     if (xFacet && cards.some(c => c[xFacet] == null)) {
       columns.push('Unassigned');
     }
     if (yFacet && cards.some(c => c[yFacet] == null)) {
       rows.push('Unassigned');
     }

     superGridLogger.debug('Generated projection headers:', {
       columns: columns.length,
       rows: rows.length,
     });

     return { columns, rows };
   }
   ```
  </action>
  <verify>
    - generateProjectionHeaders method exists
    - currentHeaders member exists
  </verify>
</task>

<task type="auto">
  <name>Task 3: Add position computation to GridRenderingEngine</name>
  <files>
    src/d3/grid-rendering/GridRenderingEngine.ts
  </files>
  <action>
Add method after generateProjectionHeaders():

```typescript
/**
 * Compute cell position for a card based on projection
 */
private computeCellPosition(card: unknown, headers: GridHeaders): { row: number; col: number } {
  if (!this.currentProjection) {
    return { row: -1, col: -1 };
  }

  const xFacet = this.currentProjection.xAxis?.facet;
  const yFacet = this.currentProjection.yAxis?.facet;

  // Get X position
  let col = -1;
  if (xFacet) {
    const xValue = card[xFacet];
    col = xValue != null
      ? headers.columns.indexOf(String(xValue))
      : headers.columns.indexOf('Unassigned');
  }

  // Get Y position
  let row = -1;
  if (yFacet) {
    const yValue = card[yFacet];
    row = yValue != null
      ? headers.rows.indexOf(String(yValue))
      : headers.rows.indexOf('Unassigned');
  }

  return { row, col };
}

/**
 * Compute positions for all cards based on projection
 */
private computeAllPositions(cards: unknown[]): void {
  if (!this.currentProjection) {
    return;
  }

  // Generate headers from unique values
  this.currentHeaders = this.generateProjectionHeaders(cards);

  // Compute position for each card
  cards.forEach(card => {
    const pos = this.computeCellPosition(card, this.currentHeaders!);
    card._projectedRow = pos.row;
    card._projectedCol = pos.col;
  });

  superGridLogger.debug('Computed positions for cards:', {
    total: cards.length,
    withPosition: cards.filter(c => c._projectedRow >= 0 || c._projectedCol >= 0).length,
  });
}
```
  </action>
  <verify>
    - computeCellPosition method exists
    - computeAllPositions method exists
  </verify>
</task>

<task type="auto">
  <name>Task 4: Call position computation in render flow</name>
  <files>
    src/d3/grid-rendering/GridRenderingEngine.ts
  </files>
  <action>
Update the render() method to compute positions before layout:

Find the render method and add position computation after the data check:

```typescript
public render(activeFilters: unknown[] = []): void {
  this.setupGridStructure();

  if (!this.currentData) {
    this.renderEmptyState();
    return;
  }

  // Compute positions from projection (NEW)
  if (this.currentProjection && this.currentData.cards) {
    this.computeAllPositions(this.currentData.cards);
  }

  this.updateGridLayout();
  // ... rest of method
}
```
  </action>
  <verify>
    - render() calls computeAllPositions when projection exists
  </verify>
</task>

<task type="auto">
  <name>Task 5: Add getHeaders accessor</name>
  <files>
    src/d3/grid-rendering/GridRenderingEngine.ts
  </files>
  <action>
Add accessor after getProjection():

```typescript
/**
 * Get current computed headers
 */
public getHeaders(): GridHeaders | null {
  return this.currentHeaders;
}
```
  </action>
  <verify>
    - getHeaders() method exists
  </verify>
</task>

</tasks>

<verification>
1. grep for "GridHeaders" in src/types/grid.ts
2. grep for "computeCellPosition" in GridRenderingEngine.ts
3. grep for "_projectedRow" in GridRenderingEngine.ts
4. Visual: Check console for "Computed positions for cards" log when Navigator mapping changes
</verification>

<success_criteria>
- GridHeaders interface defined
- generateProjectionHeaders extracts unique facet values
- computeCellPosition returns (row, col) for each card
- computeAllPositions annotates cards with _projectedRow and _projectedCol
- render() calls position computation when projection exists
</success_criteria>

<output>
After completion, create `.planning/phases/56-supergrid-pafv-projection/56-02-SUMMARY.md`
</output>
