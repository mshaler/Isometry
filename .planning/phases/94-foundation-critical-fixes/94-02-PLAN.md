---
phase: 94-foundation-critical-fixes
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/ui/useTipTapEditor.ts
  - src/components/notebook/editor/extensions/slash-commands.ts
  - src/components/notebook/editor/extensions/wiki-links.ts
autonomous: true

must_haves:
  truths:
    - "User can paste HTML from external sources and malicious scripts are sanitized"
    - "User can switch between cards 20+ times without memory growth"
    - "No console warnings about undestroyed Tippy instances"
  artifacts:
    - path: "src/hooks/ui/useTipTapEditor.ts"
      provides: "DOMPurify paste handler"
      contains: "DOMPurify.sanitize"
    - path: "src/components/notebook/editor/extensions/slash-commands.ts"
      provides: "Proper Tippy cleanup"
      contains: "onDestroy"
  key_links:
    - from: "src/hooks/ui/useTipTapEditor.ts"
      to: "dompurify"
      via: "paste handler"
      pattern: "editorProps.*handlePaste"
---

<objective>
Add security hardening (paste sanitization) and fix memory leaks (Tippy.js cleanup)

Purpose: Prevent XSS attacks via pasted HTML content and ensure proper cleanup of Tippy instances when switching between cards.

Output: Editor sanitizes pasted content via DOMPurify; SlashCommands and WikiLink extensions properly destroy Tippy instances on extension destroy.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/hooks/ui/useTipTapEditor.ts
@src/components/notebook/editor/extensions/slash-commands.ts
@src/components/notebook/editor/extensions/wiki-links.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DOMPurify paste sanitization to TipTap editor</name>
  <files>src/hooks/ui/useTipTapEditor.ts</files>
  <action>
    1. Import DOMPurify (already installed as transitive dependency of html2pdf.js):
       ```typescript
       import DOMPurify from 'dompurify';
       ```

    2. Add `editorProps` to the useEditor configuration to intercept paste events:
       ```typescript
       const editor = useEditor({
         immediatelyRender: true,
         shouldRerenderOnTransaction: false,

         // Add paste sanitization
         editorProps: {
           handlePaste: (view, event, slice) => {
             // Get HTML from clipboard
             const html = event.clipboardData?.getData('text/html');

             if (html) {
               // Sanitize HTML to prevent XSS
               const sanitized = DOMPurify.sanitize(html, {
                 ALLOWED_TAGS: [
                   'p', 'br', 'strong', 'b', 'em', 'i', 'u', 's',
                   'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
                   'ul', 'ol', 'li', 'blockquote', 'code', 'pre',
                   'a', 'span', 'div'
                 ],
                 ALLOWED_ATTR: ['href', 'title', 'class'],
                 FORBID_TAGS: ['script', 'style', 'iframe', 'object', 'embed'],
                 FORBID_ATTR: ['onerror', 'onclick', 'onload', 'onmouseover']
               });

               // Let TipTap handle the sanitized content
               // Return false to let default paste handler work with sanitized content
               // The clipboard data is already read, so we can proceed
             }

             // Return false to let TipTap's default handler process the paste
             return false;
           },
         },

         extensions: [
           // ... existing extensions
         ],
         // ... rest of config
       });
       ```

    3. Alternative approach if the above doesn't properly sanitize (preferred):
       Use TipTap's built-in transformPastedHTML:
       ```typescript
       editorProps: {
         transformPastedHTML: (html) => {
           return DOMPurify.sanitize(html, {
             ALLOWED_TAGS: [
               'p', 'br', 'strong', 'b', 'em', 'i', 'u', 's',
               'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
               'ul', 'ol', 'li', 'blockquote', 'code', 'pre',
               'a', 'span', 'div'
             ],
             ALLOWED_ATTR: ['href', 'title', 'class'],
           });
         },
       },
       ```

    Use whichever approach TipTap's API supports. `transformPastedHTML` is cleaner if available.
  </action>
  <verify>
    1. Run `npm run typecheck` - should pass
    2. Manual test: Copy HTML with script tag from another source, paste into editor, verify script doesn't execute and content is sanitized
    3. Open browser dev tools Network tab, paste malicious HTML, verify no XSS execution
  </verify>
  <done>
    - DOMPurify imported
    - Paste handler configured in useEditor
    - Pasted HTML is sanitized before insertion
    - TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Tippy.js cleanup to SlashCommands extension</name>
  <files>src/components/notebook/editor/extensions/slash-commands.ts</files>
  <action>
    The SlashCommands extension creates Tippy instances in the render callback but doesn't properly track and destroy them when the extension is destroyed.

    1. Update the suggestion render config in `useTipTapEditor.ts` to track Tippy instances:
       ```typescript
       // In createSlashCommandSuggestion render callback
       let component: ReactRenderer<SlashCommandMenuRef>;
       let popup: TippyInstance[];
       let destroyed = false;

       return {
         onStart: (props) => {
           if (destroyed) return; // Guard against calls after destruction
           // ... existing onStart code
         },
         onUpdate: (props) => {
           if (destroyed) return;
           // ... existing onUpdate code
         },
         onKeyDown: (props) => {
           if (destroyed) return false;
           // ... existing onKeyDown code
         },
         onExit: () => {
           if (destroyed) return;
           destroyed = true;
           popup?.[0]?.destroy();
           component?.destroy();
         },
       };
       ```

    2. The cleanup happens in `onExit`, which TipTap calls when suggestion is dismissed. The issue is when the entire editor is destroyed - we need to ensure cleanup happens.

    3. Since the render config is created per-editor instance (in useTipTapEditor), the cleanup should happen when the editor is destroyed. Add cleanup in the useEffect that handles editor lifecycle:
       ```typescript
       // After editor creation, track cleanup
       useEffect(() => {
         return () => {
           // Editor cleanup will call suggestion's onExit
           // But we can also force cleanup here if needed
           editor?.destroy();
         };
       }, [editor]);
       ```

    The key fix is ensuring `popup?.[0]?.destroy()` and `component?.destroy()` are ALWAYS called, even on editor destruction.
  </action>
  <verify>
    1. Run `npm run dev`
    2. Open browser dev tools Memory tab
    3. Switch between cards 20+ times
    4. Take heap snapshots - no growing Tippy instance count
    5. Check console for any "destroyed" or cleanup-related warnings
  </verify>
  <done>
    - SlashCommands suggestion render has proper cleanup guards
    - Tippy instances destroyed on extension exit
    - No memory leak on card switching
  </done>
</task>

<task type="auto">
  <name>Task 3: Add Tippy.js cleanup to WikiLink extension</name>
  <files>src/components/notebook/editor/extensions/wiki-links.ts, src/hooks/ui/useTipTapEditor.ts</files>
  <action>
    Same pattern as SlashCommands - the WikiLink extension also creates Tippy instances for the autocomplete popup.

    1. In `useTipTapEditor.ts`, update the WikiLink suggestion render callback:
       ```typescript
       WikiLink.configure({
         suggestion: createWikiLinkSuggestion(
           queryCards,
           handleLinkSelect,
           sourceCardId,
           () => {
             let component: ReactRenderer<WikiLinkMenuRef>;
             let popup: TippyInstance[];
             let destroyed = false;

             return {
               onStart: (props) => {
                 if (destroyed) return;
                 // ... existing code
               },
               onUpdate: (props) => {
                 if (destroyed) return;
                 // ... existing code
               },
               onKeyDown: (props) => {
                 if (destroyed) return false;
                 // ... existing code
               },
               onExit: () => {
                 if (destroyed) return;
                 destroyed = true;
                 popup?.[0]?.destroy();
                 component?.destroy();
               },
             };
           }
         ),
       }),
       ```

    2. Add null checks before accessing popup/component:
       ```typescript
       onUpdate: (props) => {
         if (destroyed || !component || !popup?.[0]) return;
         // ...
       },
       ```

    3. Both extensions now follow the same cleanup pattern.
  </action>
  <verify>
    1. Run `npm run dev`
    2. Type `[[` to trigger wiki link suggestion multiple times
    3. Switch cards multiple times
    4. Memory tab should show stable Tippy instance count
  </verify>
  <done>
    - WikiLink suggestion render has proper cleanup guards
    - Tippy instances destroyed on extension exit
    - Both extensions follow consistent cleanup pattern
  </done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes with zero errors
2. `npm test -- --run` passes all tests
3. Security verification:
   - Paste HTML: `<script>alert('xss')</script><b>safe</b>` into editor
   - Alert should NOT appear
   - Bold text should appear
4. Memory verification:
   - Open Memory tab in Chrome DevTools
   - Take heap snapshot
   - Switch between 20+ cards (creating/dismissing suggestions)
   - Take another heap snapshot
   - Compare: Tippy instance count should not grow unboundedly
</verification>

<success_criteria>
- FOUND-02 requirement satisfied: Pasted HTML sanitized, no XSS execution
- FOUND-03 requirement satisfied: No Tippy.js memory leaks on card switching
- DOMPurify.sanitize() called on all pasted HTML
- Both suggestion extensions have proper cleanup guards
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/94-foundation-critical-fixes/94-02-SUMMARY.md`
</output>
