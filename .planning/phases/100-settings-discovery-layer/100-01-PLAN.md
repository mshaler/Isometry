---
phase: 100-settings-discovery
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/settings.ts
  - src/hooks/useSettings.ts
autonomous: true

must_haves:
  truths:
    - "Settings can be saved and retrieved by key"
    - "Settings persist across page refresh"
    - "Empty settings return null or default value"
    - "Settings are seeded on first database initialization"
  artifacts:
    - path: "src/db/settings.ts"
      provides: "SettingsService with CRUD operations"
      exports: ["createSettingsService", "SettingsService"]
    - path: "src/hooks/useSettings.ts"
      provides: "React hook for type-safe settings access"
      exports: ["useSetting"]
  key_links:
    - from: "src/db/settings.ts"
      to: "settings table in schema.sql"
      via: "sql.js db.exec/db.run"
      pattern: "SELECT.*FROM settings|INSERT INTO settings"
    - from: "src/hooks/useSettings.ts"
      to: "src/db/settings.ts"
      via: "createSettingsService import"
      pattern: "import.*createSettingsService"
---

<objective>
Create a type-safe settings registry service and React hook for persisting user preferences.

Purpose: Enable user preferences (theme, status colors, default filters) to persist across sessions without hardcoding values. This is the foundation for eliminating hardcoded LATCH filter values in Phase 101.

Output: `src/db/settings.ts` (service) and `src/hooks/useSettings.ts` (React hook)
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/100-settings-discovery-layer/100-RESEARCH.md

# Key existing files
@src/db/schema.sql (settings table at lines 344-356)
@src/hooks/useGSDTaskToggle.ts (TanStack Query pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Settings Service</name>
  <files>src/db/settings.ts</files>
  <action>
Create SettingsService with CRUD operations wrapping the existing `settings` table:

1. Define `SettingsService` interface with:
   - `getSetting<T>(key: string): T | null` — SELECT with JSON.parse
   - `setSetting<T>(key: string, value: T): void` — UPSERT with JSON.stringify
   - `deleteSetting(key: string): void` — DELETE
   - `getAllSettings(): Record<string, unknown>` — SELECT all for debugging

2. Implement `createSettingsService(db: Database): SettingsService` factory:
   - Use sql.js synchronous `db.exec()` for SELECT
   - Use sql.js `db.run()` for INSERT/UPDATE/DELETE
   - UPSERT via `ON CONFLICT(key) DO UPDATE SET value = excluded.value, updated_at = excluded.updated_at`
   - Handle JSON.parse errors gracefully (log warning, return null)

3. Add `seedDefaultSettings(db: Database): void`:
   - Check if each default exists before inserting (avoid overwriting user values)
   - Default settings: theme='NeXTSTEP', sidebar_collapsed=false, right_sidebar_collapsed=false
   - These defaults already exist in schema.sql, so this function handles edge cases

Import `Database` type from 'sql.js'. Follow patterns from src/services/supergrid/HeaderDiscoveryService.ts for sql.js usage.

Do NOT use async/await — sql.js queries are synchronous.
  </action>
  <verify>
TypeScript compiles: `npm run typecheck` passes with no new errors.
  </verify>
  <done>
SettingsService interface and createSettingsService factory exported from src/db/settings.ts. getSetting returns parsed JSON or null. setSetting performs UPSERT. seedDefaultSettings handles first-run initialization.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useSettings React Hook</name>
  <files>src/hooks/useSettings.ts</files>
  <action>
Create a React hook for type-safe settings access with TanStack Query caching:

1. Implement `useSetting<T>(key: string, defaultValue: T): [T, (value: T) => void]`:
   - Use `useQuery` with queryKey: `['setting', key]`
   - Set `staleTime: Infinity` (settings rarely change externally)
   - queryFn: call createSettingsService(db).getSetting<T>(key) ?? defaultValue
   - `enabled: !!db` to wait for database initialization

2. Create `setValue` callback using `useMutation` or direct update:
   - Call createSettingsService(db).setSetting(key, value)
   - Use `queryClient.setQueryData(['setting', key], value)` for instant UI update
   - Return mutation error if write fails

3. Add `useAllSettings(): Record<string, unknown>` hook for debugging/dev tools:
   - Returns all settings as object
   - Useful for settings inspector panel (future)

Import dependencies:
- `useQuery`, `useQueryClient` from '@tanstack/react-query'
- `useCallback` from 'react'
- `useDatabase` from existing database hook (grep for useDatabaseContext or similar)
- `createSettingsService` from '../db/settings'

Pattern reference: src/hooks/useGSDTaskToggle.ts for TanStack Query mutation pattern.
  </action>
  <verify>
TypeScript compiles: `npm run typecheck` passes. Hook exports visible in IDE autocomplete.
  </verify>
  <done>
useSetting hook exported, returns [value, setValue] tuple. Value comes from cache or database. setValue updates both database and cache. Works with any JSON-serializable type T.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add Settings Tests</name>
  <files>src/db/__tests__/settings.test.ts</files>
  <action>
Create unit tests for SettingsService:

1. Test getSetting returns null for missing key
2. Test getSetting returns parsed value for existing key
3. Test setSetting creates new entry
4. Test setSetting updates existing entry (UPSERT)
5. Test deleteSetting removes entry
6. Test seedDefaultSettings only inserts if missing (doesn't overwrite)

Setup:
- Use in-memory sql.js database
- Initialize with schema.sql
- Follow existing test patterns in src/db/__tests__/ or src/superstack/__tests__/

Use Vitest (project's test framework). Check existing tests for import patterns.
  </action>
  <verify>
Run: `npm run test -- src/db/__tests__/settings.test.ts`
All tests pass.
  </verify>
  <done>
6+ tests covering CRUD operations and edge cases. Tests use in-memory sql.js database.
  </done>
</task>

</tasks>

<verification>
1. `npm run typecheck` — zero TypeScript errors
2. `npm run test -- src/db/__tests__/settings.test.ts` — all tests pass
3. SettingsService correctly reads/writes to settings table
4. useSetting hook provides type-safe access with caching
</verification>

<success_criteria>
- SETTINGS-01: Settings table CRUD works (getSetting, setSetting, deleteSetting)
- SETTINGS-02: getSetting returns parsed JSON or null
- SETTINGS-03: setSetting performs UPSERT with timestamp
- SETTINGS-04: seedDefaultSettings handles first-run initialization
- Tests verify all CRUD operations
- Hook provides reactive access to settings
</success_criteria>

<output>
After completion, create `.planning/phases/100-settings-discovery-layer/100-01-SUMMARY.md`
</output>
