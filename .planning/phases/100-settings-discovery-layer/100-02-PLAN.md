---
phase: 100-settings-discovery
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/facet-discovery.ts
  - src/hooks/useFacetValues.ts
autonomous: true

must_haves:
  truths:
    - "Folder values discovered from actual data"
    - "Status values discovered from actual data"
    - "Generic facet discovery works for any column"
    - "Discovery results cached for 5 minutes"
    - "Multi-select facets (tags) handled via json_each"
  artifacts:
    - path: "src/services/facet-discovery.ts"
      provides: "Query builders for facet value discovery"
      exports: ["discoverFolderValues", "discoverStatusValues", "discoverFacetValues", "buildFacetDiscoveryQuery"]
    - path: "src/hooks/useFacetValues.ts"
      provides: "React hook with TanStack Query caching"
      exports: ["useFacetValues", "useFolderValues", "useStatusValues"]
  key_links:
    - from: "src/services/facet-discovery.ts"
      to: "cards table"
      via: "SELECT DISTINCT column FROM cards"
      pattern: "SELECT DISTINCT.*FROM cards"
    - from: "src/hooks/useFacetValues.ts"
      to: "src/services/facet-discovery.ts"
      via: "discovery function imports"
      pattern: "import.*discoverFacetValues"
    - from: "src/hooks/useFacetValues.ts"
      to: "@tanstack/react-query"
      via: "useQuery with staleTime"
      pattern: "staleTime.*5.*60.*1000|300000"
---

<objective>
Create facet value discovery queries and React hooks for dynamically populating UI dropdowns.

Purpose: Replace hardcoded LATCH filter options (status, folder, priority) with values discovered from actual data. This enables schema-on-read architecture where the UI adapts to any imported dataset.

Output: `src/services/facet-discovery.ts` (query builders) and `src/hooks/useFacetValues.ts` (cached hooks)
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/100-settings-discovery-layer/100-RESEARCH.md

# Key existing patterns
@src/services/supergrid/HeaderDiscoveryService.ts (SQL query execution pattern)
@src/services/property-classifier.ts (existing discovery logic)
@src/hooks/useGSDTaskToggle.ts (TanStack Query pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Facet Discovery Service</name>
  <files>src/services/facet-discovery.ts</files>
  <action>
Create facet value discovery query builders:

1. Define `DiscoveredValue` interface:
```typescript
interface DiscoveredValue {
  value: string;
  count: number;
}
```

2. Implement `discoverFolderValues(db: Database): DiscoveredValue[]`:
   - `SELECT DISTINCT folder, COUNT(*) as count FROM cards WHERE folder IS NOT NULL AND folder != '' AND deleted_at IS NULL GROUP BY folder ORDER BY count DESC LIMIT 100`

3. Implement `discoverStatusValues(db: Database): DiscoveredValue[]`:
   - Same pattern as folder, column = 'status'

4. Implement generic `discoverFacetValues(db: Database, column: string, options?: { excludeNull?: boolean; limit?: number; isMultiSelect?: boolean }): DiscoveredValue[]`:
   - For standard columns: GROUP BY column
   - For multi-select (tags): Use `CROSS JOIN json_each(column)` with `json_valid(column)` guard
   - Default: excludeNull=true, limit=100

5. Add `buildFacetDiscoveryQuery(column: string, options?: {...}): { sql: string; params: unknown[] }` for testability:
   - Returns SQL string and params array
   - Used by discoverFacetValues internally

Multi-select pattern (CRITICAL — handles malformed JSON safely):
```sql
SELECT je.value, COUNT(*) as count
FROM cards
CROSS JOIN json_each(cards.tags) AS je
WHERE deleted_at IS NULL
  AND tags IS NOT NULL
  AND json_valid(tags)  -- IMPORTANT: Guards against non-array values
GROUP BY je.value
ORDER BY count DESC
LIMIT ?
```

Import `Database` from 'sql.js'. Follow src/services/supergrid/HeaderDiscoveryService.ts for sql.js execution patterns.
  </action>
  <verify>
TypeScript compiles: `npm run typecheck` passes with no new errors.
  </verify>
  <done>
Discovery functions exported: discoverFolderValues, discoverStatusValues, discoverFacetValues. Multi-select handling via json_each with json_valid guard. Generic function works for any column.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useFacetValues Hook</name>
  <files>src/hooks/useFacetValues.ts</files>
  <action>
Create React hooks with TanStack Query caching for facet discovery:

1. Implement `useFacetValues(column: string, options?: { isMultiSelect?: boolean })`:
```typescript
export function useFacetValues(column: string, options?: { isMultiSelect?: boolean }) {
  const db = useDatabase();  // Find existing hook

  return useQuery({
    queryKey: ['facet-values', column, options?.isMultiSelect],
    queryFn: async () => {
      if (!db) return [];
      return discoverFacetValues(db, column, options);
    },
    staleTime: 5 * 60 * 1000,  // 5 minutes (DISCOVER-04 requirement)
    gcTime: 10 * 60 * 1000,    // 10 minutes
    enabled: !!db
  });
}
```

2. Add convenience hooks:
   - `useFolderValues()` — calls useFacetValues('folder')
   - `useStatusValues()` — calls useFacetValues('status')
   - `useTagValues()` — calls useFacetValues('tags', { isMultiSelect: true })

3. Return type: `UseQueryResult<DiscoveredValue[], Error>`
   - Provides { data, isLoading, error, refetch } from TanStack Query

Import:
- `useQuery` from '@tanstack/react-query'
- Find existing database hook (grep for useDatabase, useDatabaseContext, or useSQLite)
- `discoverFacetValues, DiscoveredValue` from '../services/facet-discovery'
  </action>
  <verify>
TypeScript compiles: `npm run typecheck` passes. Hooks are importable.
  </verify>
  <done>
useFacetValues, useFolderValues, useStatusValues, useTagValues hooks exported. 5-minute staleTime configured per DISCOVER-04. Returns TanStack Query result with data/isLoading/error.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add Discovery Integration Tests</name>
  <files>src/services/__tests__/facet-discovery.test.ts</files>
  <action>
Create integration tests for facet discovery:

1. Setup: Create in-memory sql.js database with test data
   - Insert cards with various folder/status/tags values
   - Include null values and empty strings (should be excluded)
   - Include tags as JSON arrays: `'["tag1", "tag2"]'`

2. Test discoverFolderValues:
   - Returns distinct folders ordered by count
   - Excludes null and empty folders
   - Excludes deleted cards (deleted_at IS NOT NULL)

3. Test discoverStatusValues:
   - Same pattern as folder

4. Test discoverFacetValues generic:
   - Works for any column name
   - Respects excludeNull option
   - Respects limit option

5. Test multi-select (tags) handling:
   - json_each explodes array values into separate rows
   - Returns each tag with correct count
   - Handles cards with multiple tags
   - Handles malformed JSON gracefully (no crash)

6. Test edge cases:
   - Empty table returns empty array (not null, not error)
   - Column doesn't exist returns empty array with warning log (not crash)

Use Vitest. Use existing test fixtures pattern if available, otherwise create minimal test data inline.
  </action>
  <verify>
Run: `npm run test -- src/services/__tests__/facet-discovery.test.ts`
All tests pass.
  </verify>
  <done>
10+ tests covering standard discovery, multi-select handling, edge cases. Tests use real sql.js database with test data.
  </done>
</task>

</tasks>

<verification>
1. `npm run typecheck` — zero TypeScript errors
2. `npm run test -- src/services/__tests__/facet-discovery.test.ts` — all tests pass
3. Discovery queries return correct data from cards table
4. Multi-select json_each handles tags correctly
5. TanStack Query hooks cache results for 5 minutes
</verification>

<success_criteria>
- DISCOVER-01: `discoverFolderValues()` returns distinct folders from data
- DISCOVER-02: `discoverStatusValues()` returns distinct statuses from data
- DISCOVER-03: `discoverFacetValues(column)` generic query works for any facet
- DISCOVER-04: Results cached via TanStack Query with 5-minute staleTime
- Multi-select facets (tags) explode via json_each
- Edge cases handled (empty data, malformed JSON)
</success_criteria>

<output>
After completion, create `.planning/phases/100-settings-discovery-layer/100-02-SUMMARY.md`
</output>
