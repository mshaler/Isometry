---
phase: 38-foundation-verification-architecture-reconciliation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: ["src/hooks/useDatabaseService.ts", "src/components/SuperGridDemo.tsx", "src/d3/SuperGrid.ts", "src/components/ViewContinuumDemo.tsx", "src/components/supergrid/SuperGrid.tsx"]
autonomous: true

must_haves:
  truths:
    - "SuperGrid and demo components access sql.js Database directly without adapter patterns"
    - "Single unified approach to sql.js integration eliminates competing patterns"
    - "Zero serialization overhead achieved through direct Database reference access"
    - "Bridge elimination architecture fully operational without adapter code"
    - "All existing SuperGrid functionality preserved during architectural consolidation"
  artifacts:
    - path: "src/hooks/useDatabaseService.ts"
      provides: "Unified database access hook replacing adapter patterns"
      exports: ["useDatabaseService"]
    - path: "src/d3/SuperGrid.ts"
      provides: "Database service passed as constructor parameter from hook-using component"
      contains: "constructor.*database.*ReturnType"
    - path: "src/components/SuperGridDemo.tsx"
      provides: "Adapter pattern removed, direct hook usage implemented"
      min_lines: 300
  key_links:
    - from: "Demo component"
      to: "useDatabaseService hook"
      via: "Direct hook call in component"
      pattern: "const.*database.*=.*useDatabaseService"
    - from: "Demo component"
      to: "SuperGrid constructor"
      via: "Database service parameter passing"
      pattern: "new SuperGrid\\(.*database"
    - from: "SuperGrid queries"
      to: "sql.js Database"
      via: "Direct database.exec() calls"
      pattern: "database\\.exec\\(.*\\)"
---

<objective>
Eliminate competing sql.js integration patterns by consolidating DatabaseService class and SQLiteProvider React context into a single unified approach, removing adapter code that violates bridge elimination architecture principles.

Purpose: Resolve architectural mismatch where DatabaseService (class-based) and SQLiteProvider (React context) require adapter patterns that reintroduce serialization boundaries the bridge elimination was designed to eliminate.
Output: Clean, unified sql.js access pattern with true zero-serialization architecture.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/38-foundation-verification-architecture-reconciliation/38-RESEARCH.md
@src/db/DatabaseService.ts
@src/db/SQLiteProvider.tsx
@src/d3/SuperGrid.ts
@src/components/SuperGridDemo.tsx
@src/components/ViewContinuumDemo.tsx
@src/components/supergrid/SuperGrid.tsx
</context>

<tasks>

<task type="auto">
  <name>Create Unified Database Access Hook</name>
  <files>src/hooks/useDatabaseService.ts</files>
  <action>
    Create a new unified hook that provides DatabaseService-compatible interface while using SQLiteProvider internally.

    Implementation pattern from research:
    ```typescript
    import { useSQLite } from '../db/SQLiteProvider';
    import type { Database } from 'sql.js-fts5';

    export function useDatabaseService() {
      const { db, execute, run } = useSQLite();

      if (!db) {
        throw new Error('Database not ready');
      }

      return {
        // Direct database access for zero serialization
        db,

        // DatabaseService-compatible interface
        query: (sql: string, params: any[] = []) => execute(sql, params),
        run: (sql: string, params: any[] = []) => run(sql, params),

        // Additional methods SuperGrid needs
        isReady: () => !!db,
        getRawDatabase: () => db,
        export: () => db.export(),
        close: () => db.close(),

        // Transaction support
        transaction: <T>(fn: () => T): T => {
          db.exec("BEGIN TRANSACTION");
          try {
            const result = fn();
            db.exec("COMMIT");
            return result;
          } catch (error) {
            db.exec("ROLLBACK");
            throw error;
          }
        },

        // Position update methods (preserve SuperGrid functionality)
        updateCardPosition: (cardId: string, x: number, y: number) => {
          if (!cardId || typeof x !== 'number' || typeof y !== 'number') {
            return { success: false, error: 'Invalid parameters' };
          }

          try {
            // Check if card exists
            const existing = execute("SELECT id FROM nodes WHERE id = ? AND deleted_at IS NULL", [cardId]);
            if (existing.length === 0) {
              return { success: false, error: 'Card not found' };
            }

            // Update position
            run(`
              UPDATE nodes
              SET grid_x = ?, grid_y = ?, modified_at = datetime('now')
              WHERE id = ?
            `, [Math.round(x * 100) / 100, Math.round(y * 100) / 100, cardId]);

            return { success: true };
          } catch (error) {
            return { success: false, error: String(error) };
          }
        },

        // Header state methods (preserve Phase 36 functionality)
        saveHeaderState: (datasetId: string, appContext: string, expandedLevels: string[], zoomLevel: string, panLevel: string) => {
          try {
            // Create table if needed
            run(`
              CREATE TABLE IF NOT EXISTS header_state (
                dataset_id TEXT NOT NULL,
                app_context TEXT NOT NULL,
                expanded_levels TEXT NOT NULL DEFAULT '[]',
                zoom_level TEXT NOT NULL DEFAULT 'leaf',
                pan_level TEXT NOT NULL DEFAULT 'dense',
                last_updated TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
                PRIMARY KEY (dataset_id, app_context)
              )
            `);

            // Upsert state
            run(`
              INSERT OR REPLACE INTO header_state
              (dataset_id, app_context, expanded_levels, zoom_level, pan_level, last_updated)
              VALUES (?, ?, ?, ?, ?, datetime('now'))
            `, [datasetId, appContext, JSON.stringify(expandedLevels), zoomLevel, panLevel]);

            return { success: true };
          } catch (error) {
            return { success: false, error: String(error) };
          }
        },

        loadHeaderState: (datasetId: string, appContext: string) => {
          try {
            const result = execute(`
              SELECT expanded_levels, zoom_level, pan_level, last_updated
              FROM header_state
              WHERE dataset_id = ? AND app_context = ?
            `, [datasetId, appContext]);

            if (result.length === 0) return null;

            const state = result[0];
            return {
              expandedLevels: JSON.parse(state.expanded_levels as string || '[]'),
              zoomLevel: state.zoom_level as string,
              panLevel: state.pan_level as string,
              lastUpdated: state.last_updated as string
            };
          } catch (error) {
            console.error('Load header state failed:', error);
            return null;
          }
        }
      };
    }
    ```

    This hook provides DatabaseService interface while using SQLiteProvider internally, eliminating the need for adapter patterns.
  </action>
  <verify>grep -c "useDatabaseService" src/hooks/useDatabaseService.ts should return 1 (the export)</verify>
  <done>Unified database access hook created that provides DatabaseService interface via SQLiteProvider without adapter patterns</done>
</task>

<task type="auto">
  <name>Update SuperGrid to Accept Database Service Parameter</name>
  <files>src/d3/SuperGrid.ts</files>
  <action>
    Modify SuperGrid class to accept database service as a constructor parameter (from components using the hook) instead of trying to use React hooks directly in the class constructor.

    Key changes:
    1. Remove DatabaseService import if present
    2. Update constructor to accept database service parameter
    3. Update type to match useDatabaseService return type
    4. Preserve all existing functionality including position updates and header state

    Replace:
    ```typescript
    import type { DatabaseService } from '../db/DatabaseService';

    export class SuperGrid {
      private database: DatabaseService;

      constructor(
        container: SVGElement,
        database: DatabaseService,
        config: GridConfig = {},
        // ...
      ) {
        this.database = database;
        // ...
      }
    ```

    With:
    ```typescript
    // Remove DatabaseService import
    // Add type import for the hook return type
    import type { useDatabaseService } from '../hooks/useDatabaseService';

    export class SuperGrid {
      private database: ReturnType<typeof useDatabaseService>;

      constructor(
        container: SVGElement,
        database: ReturnType<typeof useDatabaseService>,
        config: GridConfig = {},
        callbacks: { /* same callbacks */ } = {}
      ) {
        this.database = database;
        // ... rest unchanged
      }
    ```

    Update all this.database usage to use hook interface:
    - this.database.query() → unchanged (hook provides this)
    - this.database.run() → unchanged (hook provides this)
    - this.database.updateCardPosition() → unchanged (hook provides this)
    - this.database.saveHeaderState() → unchanged (hook provides this)
    - this.database.getRawDatabase() → unchanged (hook provides this)

    The hook provides the same interface, so most method calls remain unchanged.
    The key architectural change is that components call useDatabaseService() and pass the result to SuperGrid constructor.

    This fixes the React hooks rule violation by keeping hooks in React components and passing the service to the class.
  </action>
  <verify>grep -c "ReturnType<typeof useDatabaseService>" src/d3/SuperGrid.ts should return at least 2 (type and constructor parameter)</verify>
  <done>SuperGrid class updated to accept database service parameter from hook-using components, fixing React hooks rule violation</done>
</task>

<task type="auto">
  <name>Remove Adapter Patterns from Demo Components</name>
  <files>src/components/SuperGridDemo.tsx</files>
  <action>
    Remove the adapter pattern code that creates a DatabaseService-compatible object from SQLiteProvider.

    Key changes:

    1. Remove the adapter creation code (lines 92-200 approximately):
    ```typescript
    // DELETE THIS ENTIRE SECTION:
    // Create DatabaseService adapter from SQLite context
    useEffect(() => {
      if (!db) {
        setDbService(null);
        return;
      }

      // Create a simple DatabaseService adapter that wraps...
      const adapter = {
        isReady: () => !!db,
        query: function(sql: string, params: any[] = []) {
          // ... 80+ lines of adapter code
        },
        // ... more adapter methods
      };

      setDbService(adapter as any);
    }, [db]);
    ```

    2. Remove dbService state:
    ```typescript
    // REMOVE:
    const [dbService, setDbService] = useState<DatabaseService | null>(null);
    ```

    3. Add useDatabaseService hook usage:
    ```typescript
    // ADD:
    import { useDatabaseService } from '../hooks/useDatabaseService';

    // In component body:
    const databaseService = useDatabaseService();
    ```

    4. Update SuperGrid initialization to pass database service parameter:
    ```typescript
    // CHANGE FROM:
    const grid = new SuperGrid(container, dbService, config, callbacks);

    // TO:
    const grid = new SuperGrid(container, databaseService, config, callbacks);
    ```

    5. Update useEffect dependencies to use databaseService instead of dbService:
    ```typescript
    // Update the useEffect that creates SuperGrid to depend on databaseService
    // instead of dbService
    ```

    6. Update imports - remove DatabaseService import if no longer used:
    ```typescript
    // Remove if not used elsewhere:
    import type { DatabaseService } from '../db/DatabaseService';
    ```

    The component should be cleaner and simpler after removing ~100 lines of adapter code.
    All functionality should work the same because SuperGrid gets the same database service interface, but now via the unified hook.
  </action>
  <verify>grep -c "adapter" src/components/SuperGridDemo.tsx should return 0 (all adapter code removed)</verify>
  <done>Demo component adapter patterns removed, SuperGrid initialization simplified to use unified hook approach with parameter passing</done>
</task>

<task type="auto">
  <name>Update Additional Components</name>
  <files>src/components/ViewContinuumDemo.tsx, src/components/supergrid/SuperGrid.tsx</files>
  <action>
    Apply the same adapter removal pattern to any other components that use similar DatabaseService adapter patterns.

    For ViewContinuumDemo.tsx:
    1. Check if it has similar adapter creation code
    2. If yes, apply same removal pattern as SuperGridDemo.tsx
    3. Update SuperGrid instantiation to pass database parameter from useDatabaseService hook

    For src/components/supergrid/SuperGrid.tsx:
    1. Check if this is a wrapper component that needs similar updates
    2. Apply same pattern - remove adapters, use hook-based approach with parameter passing

    If either file doesn't exist or doesn't have adapter patterns, document that in the task execution.

    The goal is to eliminate ALL adapter patterns throughout the codebase that bridge between SQLiteProvider and DatabaseService interfaces.

    Search pattern to identify adapters:
    - Look for objects with query/run methods that wrap db.prepare() calls
    - Look for DatabaseService type casting with "as any"
    - Look for comments mentioning "adapter" or "wrapper"

    After cleanup, the only sql.js access should be:
    1. SQLiteProvider context (useSQLite hook)
    2. useDatabaseService hook (unified interface)
    3. Direct hook usage in components that pass service to SuperGrid

    Pattern for each component:
    ```typescript
    import { useDatabaseService } from '../hooks/useDatabaseService';

    function Component() {
      const databaseService = useDatabaseService();

      // Pass to SuperGrid constructor
      const grid = new SuperGrid(container, databaseService, config, callbacks);
    }
    ```
  </action>
  <verify>grep -r "adapter.*DatabaseService\|DatabaseService.*adapter" src/components/ should return no matches</verify>
  <done>All adapter patterns eliminated from components, unified database access approach implemented with proper parameter passing throughout codebase</done>
</task>

</tasks>

<verification>
1. useDatabaseService hook provides unified interface replacing adapter patterns
2. SuperGrid class accepts database service as constructor parameter (no hooks in constructor)
3. Demo components use hook and pass service to SuperGrid constructor
4. All existing SuperGrid functionality preserved (position updates, header state)
5. True zero-serialization architecture achieved - direct Database reference access
</verification>

<success_criteria>
- Single unified sql.js integration approach eliminates competing patterns
- Adapter patterns completely removed from codebase
- SuperGrid and demo components access Database directly via hook with proper parameter passing
- React hooks rules followed (hooks only in React components, not class constructors)
- Bridge elimination architecture fully operational without serialization boundaries
- All existing functionality preserved during architectural consolidation
</success_criteria>

<output>
After completion, create `.planning/phases/38-foundation-verification-architecture-reconciliation/38-02-SUMMARY.md`
</output>