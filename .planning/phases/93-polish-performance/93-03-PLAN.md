---
phase: 93-polish-performance
plan: 03
type: execute
wave: 2
depends_on: ["93-01"]
files_modified:
  - src/d3/header-interaction/HeaderAnimationController.ts
  - src/components/supergrid/SuperGridScrollContainer.tsx
  - src/components/supergrid/SuperGrid.css
autonomous: false

must_haves:
  truths:
    - "Headers remain visible (sticky) when scrolling data area"
    - "Collapse/expand animations complete in 300ms without frame drops"
    - "Animations maintain 55+ fps without visual stutter"
  artifacts:
    - path: "src/d3/header-interaction/HeaderAnimationController.ts"
      provides: "GPU-accelerated collapse/expand animations"
      exports: ["HeaderAnimationController"]
    - path: "src/components/supergrid/SuperGridScrollContainer.tsx"
      provides: "Enhanced sticky header behavior"
      exports: ["SuperGridScrollContainer"]
  key_links:
    - from: "src/d3/header-interaction/HeaderAnimationController.ts"
      to: "D3 transitions"
      via: "transform: scale() and opacity animations"
      pattern: "style\\('transform'"
    - from: "src/components/supergrid/SuperGridScrollContainer.tsx"
      to: "CSS position: sticky"
      via: "z-index layering for headers"
      pattern: "position: sticky"
---

<objective>
Enhance collapse/expand animations to use GPU-accelerated transforms (UX-02) and verify sticky header behavior during virtual scrolling (PERF-02).

Purpose: UX-02 requires smooth animations. Current HeaderAnimationController animates width/height which triggers layout recalculation on every frame (poor FPS). PERF-02 requires sticky headers during scroll. CSS sticky is already implemented but needs verification with virtual scrolling.

Output: Updated HeaderAnimationController with GPU-accelerated transforms, verified sticky header behavior with virtualized grid
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/93-polish-performance/93-RESEARCH.md
@.planning/phases/93-polish-performance/93-01-PLAN.md

@src/d3/header-interaction/HeaderAnimationController.ts
@src/components/supergrid/SuperGridScrollContainer.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Upgrade HeaderAnimationController to GPU-accelerated transforms</name>
  <files>src/d3/header-interaction/HeaderAnimationController.ts</files>
  <action>
Update HeaderAnimationController to use GPU-accelerated CSS properties (transform, opacity) instead of layout-triggering properties (width, height).

Key changes:

1. **Replace animateParentSpanChanges method** (around lines 214-237):
Instead of animating `width` directly, use `transform: scaleX()`:

```typescript
private animateParentSpanChanges(parentNode: HeaderNode, transitionId: string): void {
  const parentElement = this.container
    .selectAll('.header-node')
    .filter((d: unknown) => (d as HeaderNode).id === parentNode.id);

  if (parentElement.empty()) return;

  // Get current and target widths for scale calculation
  const currentRect = parentElement.select('.header-background').node() as SVGRectElement | null;
  const currentWidth = currentRect ? parseFloat(currentRect.getAttribute('width') || '0') : 0;
  const targetWidth = parentNode.width;
  const scaleX = targetWidth / (currentWidth || 1);

  // GPU-accelerated: use transform instead of width
  // This avoids layout recalculation on every frame
  parentElement.select('.header-background')
    .interrupt()
    .transition(`parent-span-${transitionId}`)
    .duration(this.config.animationDuration)
    .ease(d3.easeQuadOut)
    .style('transform', `scaleX(${scaleX})`)
    .style('transform-origin', 'left center')
    .on('end', function() {
      // Reset transform and set final width (layout only once at end)
      d3.select(this)
        .style('transform', null)
        .attr('width', targetWidth);
    });

  // Text positioning uses opacity fade during width change
  parentElement.select('.header-label')
    .interrupt()
    .transition(`parent-text-${transitionId}`)
    .duration(this.config.animationDuration / 2)
    .ease(d3.easeQuadOut)
    .style('opacity', 0)
    .transition()
    .duration(this.config.animationDuration / 2)
    .style('opacity', 1)
    .attr('x', this.getTextX(parentNode));
}
```

2. **Replace animateChildPositioning method** (around lines 239-262):
Use `transform: translateX()` for GPU-accelerated positioning:

```typescript
private animateChildPositioning(childNodes: HeaderNode[], transitionId: string): void {
  childNodes.forEach((childNode, index) => {
    const childElement = this.container
      .selectAll('.header-node')
      .filter((d: unknown) => (d as HeaderNode).id === childNode.id);

    if (childElement.empty()) return;

    // Stagger child animations for fluid cascading effect
    const delay = index * 50;

    // GPU-accelerated: use transform + opacity
    childElement
      .interrupt()
      .transition(`child-position-${transitionId}-${index}`)
      .delay(delay)
      .duration(this.config.animationDuration)
      .ease(d3.easeQuadOut)
      .style('transform', `translateX(${childNode.x}px)`)
      .style('opacity', childNode.isVisible ? 1 : 0)
      .on('end', function() {
        // Reset transform and set final position (layout only once at end)
        d3.select(this)
          .style('transform', null)
          .attr('transform', `translate(${childNode.x}, 0)`);
      });
  });
}
```

3. **Add GPU animation helper method**:
```typescript
/**
 * Animate element collapse using GPU-accelerated scaleY
 * Per Chrome DevRel: transform and opacity skip layout/paint
 */
private animateCollapseGPU(
  element: d3.Selection<SVGGElement, unknown, null, undefined>,
  isExpanding: boolean,
  transitionId: string
): void {
  element
    .interrupt()
    .transition(`collapse-gpu-${transitionId}`)
    .duration(this.config.animationDuration)
    .ease(d3.easeQuadOut)
    .style('transform', isExpanding ? 'scaleY(1)' : 'scaleY(0)')
    .style('transform-origin', 'top')
    .style('opacity', isExpanding ? 1 : 0);
}
```

4. **Update animateToggle to use GPU path**:
```typescript
animateToggle(node: HeaderNode): void {
  // Use GPU-accelerated animation path
  this.animateHeaderExpansionGPU(node);
}

private animateHeaderExpansionGPU(node: HeaderNode): void {
  const transitionId = `toggle-${node.id}-${Date.now()}`;
  this.runningTransitions.add(transitionId);

  try {
    const childNodes = node.children || [];

    if (childNodes.length > 0) {
      // Animate children with GPU transforms
      childNodes.forEach((child, index) => {
        const childElement = this.container
          .selectAll('.header-node')
          .filter((d: unknown) => (d as HeaderNode).id === child.id);

        if (!childElement.empty()) {
          const delay = index * 40; // Faster stagger for GPU animations

          childElement
            .interrupt()
            .transition(`child-gpu-${transitionId}-${index}`)
            .delay(delay)
            .duration(this.config.animationDuration)
            .ease(d3.easeQuadOut)
            .style('transform', node.isExpanded
              ? 'scaleY(1) translateY(0)'
              : 'scaleY(0) translateY(-10px)')
            .style('transform-origin', 'top')
            .style('opacity', node.isExpanded ? 1 : 0);
        }
      });
    }

    // Animate expand icon
    this.animateExpandIcon(node, transitionId);

  } finally {
    setTimeout(() => {
      this.runningTransitions.delete(transitionId);
    }, this.config.animationDuration);
  }
}
```

These changes ensure:
- No layout recalculation during animation frames
- GPU compositing for transform and opacity
- Layout update only once at animation end
- Smoother 60fps animations
  </action>
  <verify>
Run `npm run check:types` to verify no TypeScript errors.
Run `npm run dev` and:
1. Click header collapse/expand buttons
2. Open Chrome DevTools Performance tab
3. Record while triggering animations
4. Verify no purple "Layout" bars during animation frames
5. FPS should stay at 55+ during animations
  </verify>
  <done>
HeaderAnimationController uses GPU-accelerated transforms (scaleX, scaleY, translateX, opacity) instead of width/height. No layout recalculation during animation frames.
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance SuperGridScrollContainer for virtual scrolling compatibility</name>
  <files>
    src/components/supergrid/SuperGridScrollContainer.tsx
    src/components/supergrid/SuperGrid.css
  </files>
  <action>
Verify and enhance sticky header behavior to work with virtualized content.

1. **Update SuperGridScrollContainer.tsx** to ensure sticky headers work with TanStack Virtual:

The key issue from research: "When overflow: auto is set on the container for virtual scrolling, CSS position: sticky stops working on nested headers."

Solution: Place sticky headers outside the virtual scroll container using CSS Grid.

Update the component to support both modes (with/without virtualization):

```typescript
// Add prop for virtualized mode
interface SuperGridScrollContainerProps {
  // ... existing props ...
  /** Enable virtualization mode layout */
  virtualized?: boolean;
}

export function SuperGridScrollContainer({
  // ... existing destructured props ...
  virtualized = false,
}: SuperGridScrollContainerProps): JSX.Element {
  // For virtualized mode, headers must be positioned outside the scroll container
  // to maintain sticky behavior

  if (virtualized) {
    return (
      <div
        className={`supergrid supergrid--virtualized ${className}`}
        style={{
          display: 'grid',
          gridTemplateColumns: `${headerWidth}px 1fr`,
          gridTemplateRows: `${headerHeight}px 1fr`,
          width: '100%',
          height: '100%',
          position: 'relative',
        }}
      >
        {/* Corner cell - fixed position, NOT inside scroll container */}
        <div
          className="supergrid__corner supergrid__corner--fixed"
          style={{
            position: 'relative', // Not sticky, but fixed in grid
            zIndex: 3,
            width: headerWidth,
            height: headerHeight,
            background: '#f5f5f5',
            borderRight: '1px solid #e5e7eb',
            borderBottom: '1px solid #e5e7eb',
          }}
        >
          {cornerContent}
        </div>

        {/* Column headers - fixed in grid row, scrolls horizontally with data */}
        <div
          className="supergrid__column-headers supergrid__column-headers--virtualized"
          style={{
            position: 'relative',
            zIndex: 2,
            background: '#f5f5f5',
            borderBottom: '1px solid #e5e7eb',
            overflowX: 'hidden', // Hidden - synced via JS scroll listener
          }}
        >
          <svg
            ref={columnHeaderRef}
            width={contentWidth}
            height={headerHeight}
            style={{ display: 'block' }}
          />
        </div>

        {/* Row headers - fixed in grid column, scrolls vertically with data */}
        <div
          className="supergrid__row-headers supergrid__row-headers--virtualized"
          style={{
            position: 'relative',
            zIndex: 1,
            gridRow: 2,
            background: '#f5f5f5',
            borderRight: '1px solid #e5e7eb',
            overflowY: 'hidden', // Hidden - synced via JS scroll listener
          }}
        >
          <svg
            ref={rowHeaderRef}
            width={headerWidth}
            height={contentHeight}
            style={{ display: 'block' }}
          />
        </div>

        {/* Data grid - the only scrollable container */}
        <div
          className="supergrid__data-grid supergrid__data-grid--virtualized"
          style={{
            gridRow: 2,
            gridColumn: 2,
            overflow: 'auto', // Only this element scrolls
            transformOrigin: '0 0',
          }}
          onScroll={(e) => {
            // Sync header scroll positions
            const target = e.currentTarget;
            const colHeaders = target.parentElement?.querySelector('.supergrid__column-headers--virtualized');
            const rowHeaders = target.parentElement?.querySelector('.supergrid__row-headers--virtualized');

            if (colHeaders) {
              colHeaders.scrollLeft = target.scrollLeft;
            }
            if (rowHeaders) {
              rowHeaders.scrollTop = target.scrollTop;
            }
          }}
        >
          <svg
            ref={dataGridRef}
            width={contentWidth}
            height={contentHeight}
            style={{ display: 'block' }}
          />
        </div>
      </div>
    );
  }

  // Non-virtualized mode (existing implementation)
  return (
    // ... existing return statement unchanged ...
  );
}
```

2. **Add CSS for virtualized mode** to SuperGrid.css:

```css
/* Virtualized mode - headers outside scroll container */
.supergrid--virtualized {
  /* CSS Grid layout handles sticky behavior via grid placement */
}

.supergrid__column-headers--virtualized {
  /* Sync scroll with data grid via JS */
  scroll-behavior: auto;
}

.supergrid__row-headers--virtualized {
  /* Sync scroll with data grid via JS */
  scroll-behavior: auto;
}

.supergrid__data-grid--virtualized {
  /* Smooth scrolling for better UX */
  scroll-behavior: smooth;
  -webkit-overflow-scrolling: touch; /* iOS momentum scrolling */
}

/* Ensure no sticky conflicts in virtualized mode */
.supergrid--virtualized .supergrid__corner--fixed,
.supergrid--virtualized .supergrid__column-headers--virtualized,
.supergrid--virtualized .supergrid__row-headers--virtualized {
  position: relative !important; /* Override any inherited sticky */
}
```

Key changes:
- `virtualized` prop enables new layout mode
- Headers placed outside scroll container (no sticky needed)
- Single scroll container with onScroll sync to headers
- CSS Grid handles fixed header positioning
  </action>
  <verify>
Run `npm run check:types` to verify no TypeScript errors.
Run `npm run dev` and:
1. Scroll the virtualized grid horizontally - column headers should stay visible
2. Scroll vertically - row headers should stay visible
3. Corner cell should remain fixed at top-left intersection
4. No visual tearing or desync between headers and data
  </verify>
  <done>
SuperGridScrollContainer supports virtualized mode with headers outside scroll container. Scroll sync keeps headers aligned with data. CSS Grid handles fixed positioning.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
GPU-accelerated collapse/expand animations and verified sticky header behavior with virtual scrolling
  </what-built>
  <how-to-verify>
1. Run `npm run dev`
2. Navigate to SuperGrid view with data
3. Test collapse/expand animations:
   - Click header collapse buttons
   - Verify smooth animation (no stutter)
   - Open DevTools Performance tab, record while animating
   - Should see no purple "Layout" bars during animation
4. Test sticky headers with large dataset:
   - Load grid with 1000+ cells (use alto-index data)
   - Scroll horizontally - column headers should stay visible
   - Scroll vertically - row headers should stay visible
   - Corner cell should remain fixed at intersection
5. Verify FPS:
   - FPS monitor (top-right in dev mode) should show 30+ fps during scroll
   - During animations, FPS should stay at 55+ (visually smooth, no stutter)
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
1. Run `npm run check:types` - zero TypeScript errors
2. Run `npm run check:lint` - no new ESLint errors
3. Chrome DevTools Performance tab: No layout recalculation during animations
4. FPS monitor shows 30+ fps during scroll, 55+ during animations (visually smooth)
5. Headers remain visible during all scroll operations
</verification>

<success_criteria>
1. HeaderAnimationController uses transform/opacity (GPU-accelerated)
2. No "Layout" events in Chrome DevTools during animations
3. Sticky headers work with virtualized content
4. FPS stays at 30+ during scroll (PERF-01)
5. FPS stays at 55+ during animations (visually smooth, no stutter - UX-02)
6. Corner cell, column headers, row headers all remain visible during scroll (PERF-02)
</success_criteria>

<output>
After completion, create `.planning/phases/93-polish-performance/93-03-SUMMARY.md`
</output>
