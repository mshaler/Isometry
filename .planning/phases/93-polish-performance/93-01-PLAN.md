---
phase: 93-polish-performance
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/supergrid/SuperGridVirtualized.tsx
  - src/hooks/useVirtualizedGrid.ts
  - src/hooks/useFPSMonitor.ts
  - src/d3/SuperGridEngine/VirtualRenderer.ts
autonomous: true

must_haves:
  truths:
    - "User can scroll a 10K cell grid at 30+ fps without frame drops"
    - "Only visible cells are rendered in DOM (virtualized)"
    - "FPS counter shows actual frame rate during development"
  artifacts:
    - path: "src/components/supergrid/SuperGridVirtualized.tsx"
      provides: "TanStack Virtual wrapper for SuperGrid"
      exports: ["SuperGridVirtualized"]
    - path: "src/hooks/useVirtualizedGrid.ts"
      provides: "Hook integrating TanStack Virtual with D3 data binding"
      exports: ["useVirtualizedGrid"]
    - path: "src/hooks/useFPSMonitor.ts"
      provides: "Development-only FPS monitoring hook"
      exports: ["useFPSMonitor"]
    - path: "src/d3/SuperGridEngine/VirtualRenderer.ts"
      provides: "D3 renderer for virtualized cells"
      exports: ["VirtualRenderer"]
  key_links:
    - from: "src/components/supergrid/SuperGridVirtualized.tsx"
      to: "@tanstack/react-virtual"
      via: "useVirtualizer hook"
      pattern: "useVirtualizer"
    - from: "src/d3/SuperGridEngine/VirtualRenderer.ts"
      to: "src/d3/grid-rendering/DataCellRenderer.ts"
      via: "shared cell rendering logic"
      pattern: "renderCell"
---

<objective>
Implement virtual scrolling for SuperGrid data cells using TanStack Virtual (already installed) to maintain 30+ fps when rendering 10K+ cells.

Purpose: PERF-01 requires 30+ fps for >1000 cells. Current implementation renders all cells in DOM which causes severe performance degradation at scale. TanStack Virtual calculates visible rows and D3 binds data only to visible cells.

Output: SuperGridVirtualized component, useVirtualizedGrid hook, useFPSMonitor hook (dev-only), VirtualRenderer class
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/93-polish-performance/93-RESEARCH.md

@src/components/supergrid/SuperGrid.tsx
@src/components/supergrid/SuperGridScrollContainer.tsx
@src/d3/grid-rendering/DataCellRenderer.ts
@src/hooks/useDataCellRenderer.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useFPSMonitor hook for performance validation</name>
  <files>src/hooks/useFPSMonitor.ts</files>
  <action>
Create a development-only FPS monitoring hook using requestAnimationFrame:

```typescript
// src/hooks/useFPSMonitor.ts
import { useState, useEffect, useRef, useCallback } from 'react';

interface FPSMonitorState {
  fps: number;
  isPerformant: boolean;  // >= 30fps (PERF-01 requirement)
  isSmooth: boolean;      // >= 55fps (target 60fps with buffer)
  avgFps: number;         // Rolling average over 1 second
}

export function useFPSMonitor(enabled: boolean = true): FPSMonitorState {
  const [state, setState] = useState<FPSMonitorState>({
    fps: 60,
    isPerformant: true,
    isSmooth: true,
    avgFps: 60,
  });

  const framesRef = useRef<number[]>([]);
  const rafIdRef = useRef<number | null>(null);

  useEffect(() => {
    // Only run in development and when enabled
    if (process.env.NODE_ENV !== 'development' || !enabled) {
      return;
    }

    let lastTime = performance.now();

    const tick = (currentTime: number) => {
      // Calculate delta since last frame
      const delta = currentTime - lastTime;
      lastTime = currentTime;

      // Add frame timestamp
      framesRef.current.push(currentTime);

      // Keep only last second of frames
      const oneSecondAgo = currentTime - 1000;
      framesRef.current = framesRef.current.filter(t => t > oneSecondAgo);

      // Calculate FPS (frames in last second)
      const currentFPS = framesRef.current.length;

      setState({
        fps: currentFPS,
        isPerformant: currentFPS >= 30,
        isSmooth: currentFPS >= 55,
        avgFps: currentFPS,
      });

      rafIdRef.current = requestAnimationFrame(tick);
    };

    rafIdRef.current = requestAnimationFrame(tick);

    return () => {
      if (rafIdRef.current !== null) {
        cancelAnimationFrame(rafIdRef.current);
      }
    };
  }, [enabled]);

  return state;
}
```

Key design decisions:
- Only runs in development (process.env.NODE_ENV check)
- Uses requestAnimationFrame for accurate frame timing
- Tracks rolling 1-second average for stable readings
- Returns isPerformant (30+ fps) per PERF-01 requirement
  </action>
  <verify>
Run `npm run check:types` to verify no TypeScript errors.
Create a simple test: `import { useFPSMonitor } from '@/hooks/useFPSMonitor'` compiles.
  </verify>
  <done>
useFPSMonitor hook exists at src/hooks/useFPSMonitor.ts, exports FPSMonitorState interface and useFPSMonitor function, compiles without TypeScript errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useVirtualizedGrid hook integrating TanStack Virtual with D3</name>
  <files>src/hooks/useVirtualizedGrid.ts</files>
  <action>
Create a hook that bridges TanStack Virtual with D3.js data binding:

```typescript
// src/hooks/useVirtualizedGrid.ts
import { useRef, useEffect, useMemo } from 'react';
import { useVirtualizer } from '@tanstack/react-virtual';
import * as d3 from 'd3';
import type { DataCellData } from '@/d3/grid-rendering/DataCellRenderer';
import type { D3CoordinateSystem } from '@/types/grid';

interface UseVirtualizedGridOptions {
  cells: DataCellData[];
  coordinateSystem: D3CoordinateSystem;
  containerRef: React.RefObject<HTMLDivElement>;
  overscan?: number;  // Extra rows to render for smooth scrolling (default: 5)
}

interface VirtualizedGridResult {
  virtualRows: Array<{
    index: number;
    start: number;
    size: number;
    cell: DataCellData;
  }>;
  totalHeight: number;
  totalWidth: number;
  isVirtualizing: boolean;  // true if cell count > threshold
}

const VIRTUALIZATION_THRESHOLD = 100;  // Start virtualizing above this

export function useVirtualizedGrid({
  cells,
  coordinateSystem,
  containerRef,
  overscan = 5,
}: UseVirtualizedGridOptions): VirtualizedGridResult {
  const { cellHeight, cellWidth } = coordinateSystem;

  // Calculate grid dimensions
  const maxGridY = useMemo(() => {
    if (cells.length === 0) return 0;
    return Math.max(...cells.map(c => c.gridY)) + 1;
  }, [cells]);

  const maxGridX = useMemo(() => {
    if (cells.length === 0) return 0;
    return Math.max(...cells.map(c => c.gridX)) + 1;
  }, [cells]);

  // Determine if we should virtualize
  const shouldVirtualize = cells.length > VIRTUALIZATION_THRESHOLD;

  // TanStack Virtual row virtualizer
  const rowVirtualizer = useVirtualizer({
    count: maxGridY,
    getScrollElement: () => containerRef.current,
    estimateSize: () => cellHeight,
    overscan,
    enabled: shouldVirtualize,
  });

  // Map virtual rows to cells
  const virtualRows = useMemo(() => {
    if (!shouldVirtualize) {
      // Return all cells without virtualization
      return cells.map((cell, index) => ({
        index,
        start: cell.gridY * cellHeight,
        size: cellHeight,
        cell,
      }));
    }

    // Get visible row indices from virtualizer
    const visibleRowIndices = new Set(
      rowVirtualizer.getVirtualItems().map(item => item.index)
    );

    // Filter cells to only visible rows
    return cells
      .filter(cell => visibleRowIndices.has(cell.gridY))
      .map((cell, index) => {
        const virtualItem = rowVirtualizer.getVirtualItems().find(
          item => item.index === cell.gridY
        );
        return {
          index,
          start: virtualItem?.start ?? cell.gridY * cellHeight,
          size: virtualItem?.size ?? cellHeight,
          cell,
        };
      });
  }, [cells, shouldVirtualize, rowVirtualizer, cellHeight]);

  return {
    virtualRows,
    totalHeight: maxGridY * cellHeight,
    totalWidth: maxGridX * cellWidth,
    isVirtualizing: shouldVirtualize,
  };
}
```

Key design decisions:
- Uses VIRTUALIZATION_THRESHOLD of 100 cells (start virtualizing above this)
- Integrates TanStack Virtual's useVirtualizer with cell data
- Returns isVirtualizing flag for conditional rendering logic
- Calculates total dimensions for scroll container sizing
  </action>
  <verify>
Run `npm run check:types` to verify no TypeScript errors.
Import from hook index: `import { useVirtualizedGrid } from '@/hooks'` compiles after adding export.
  </verify>
  <done>
useVirtualizedGrid hook exists at src/hooks/useVirtualizedGrid.ts, integrates TanStack Virtual with D3 cell data, compiles without TypeScript errors, exported from hooks index.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create SuperGridVirtualized component and VirtualRenderer</name>
  <files>
    src/components/supergrid/SuperGridVirtualized.tsx
    src/d3/SuperGridEngine/VirtualRenderer.ts
    src/hooks/index.ts
  </files>
  <action>
Create the VirtualRenderer class for D3 rendering of virtualized cells:

```typescript
// src/d3/SuperGridEngine/VirtualRenderer.ts
import * as d3 from 'd3';
import type { DataCellData, CellDensityState } from '@/d3/grid-rendering/DataCellRenderer';
import type { D3CoordinateSystem } from '@/types/grid';

interface VirtualRendererConfig {
  coordinateSystem: D3CoordinateSystem;
  densityState: CellDensityState;
  selectedIds: Set<string>;
  onCellClick?: (cell: DataCellData, event: MouseEvent) => void;
}

export class VirtualRenderer {
  private container: d3.Selection<SVGGElement, unknown, null, undefined>;
  private config: VirtualRendererConfig;

  constructor(
    container: d3.Selection<SVGGElement, unknown, null, undefined>,
    config: VirtualRendererConfig
  ) {
    this.container = container;
    this.config = config;
  }

  /**
   * Render only visible cells using D3 join pattern
   * ALWAYS use .join() with key function per CLAUDE.md D3 patterns
   */
  render(visibleCells: DataCellData[]): void {
    const { cellWidth, cellHeight, logicalToScreen } = this.config.coordinateSystem;
    const { densityState, selectedIds, onCellClick } = this.config;
    const isCollapsed = densityState.valueDensity === 'collapsed';

    // D3 join pattern with key function (CLAUDE.md requirement)
    this.container
      .selectAll<SVGGElement, DataCellData>('.virtual-cell')
      .data(visibleCells, d => d.id)
      .join(
        enter => {
          const g = enter.append('g')
            .attr('class', 'virtual-cell')
            .attr('data-cell-id', d => d.id);

          // Cell background
          g.append('rect')
            .attr('class', 'cell-bg')
            .attr('width', cellWidth - 2)
            .attr('height', cellHeight - 2)
            .attr('fill', '#ffffff')
            .attr('stroke', '#e5e7eb')
            .attr('stroke-width', 1)
            .attr('rx', 4);

          // Cell content (count badge or card preview)
          if (isCollapsed) {
            // Collapsed mode: count badge (circle with number)
            g.append('circle')
              .attr('class', 'cell-count-bg')
              .attr('cx', cellWidth / 2)
              .attr('cy', cellHeight / 2)
              .attr('r', 16)
              .attr('fill', '#f3f4f6');

            g.append('text')
              .attr('class', 'cell-count')
              .attr('x', cellWidth / 2)
              .attr('y', cellHeight / 2)
              .attr('text-anchor', 'middle')
              .attr('dominant-baseline', 'central')
              .attr('font-size', '12px')
              .attr('fill', '#374151')
              .text(d => d.nodeCount.toString());
          } else {
            // Leaf mode: card chip preview
            g.append('text')
              .attr('class', 'cell-label')
              .attr('x', 8)
              .attr('y', 20)
              .attr('font-size', '11px')
              .attr('fill', '#374151')
              .text(d => d.nodeCount === 1 ? 'Card' : `${d.nodeCount} cards`);
          }

          return g;
        },
        update => {
          // Update position (handled by transform below)
          // Update selection state
          update.select('.cell-bg')
            .attr('stroke', d => selectedIds.has(d.nodeIds[0] || '') ? '#3b82f6' : '#e5e7eb')
            .attr('stroke-width', d => selectedIds.has(d.nodeIds[0] || '') ? 2 : 1)
            .attr('fill', d => selectedIds.has(d.nodeIds[0] || '') ? '#dbeafe' : '#ffffff');

          return update;
        },
        exit => exit.remove()
      )
      // Position all cells using transform (GPU-accelerated)
      .attr('transform', d => {
        const { x, y } = logicalToScreen(d.gridX, d.gridY);
        return `translate(${x + 1}, ${y + 1})`;
      })
      // Add click handler
      .on('click', (event: MouseEvent, d: DataCellData) => {
        onCellClick?.(d, event);
      });
  }

  /**
   * Update configuration (e.g., density state changes)
   */
  updateConfig(config: Partial<VirtualRendererConfig>): void {
    this.config = { ...this.config, ...config };
  }

  /**
   * Clear all rendered cells
   */
  clear(): void {
    this.container.selectAll('.virtual-cell').remove();
  }
}
```

Create the SuperGridVirtualized component:

```typescript
// src/components/supergrid/SuperGridVirtualized.tsx
import { useRef, useEffect, useCallback } from 'react';
import { useVirtualizedGrid } from '@/hooks/useVirtualizedGrid';
import { useFPSMonitor } from '@/hooks/useFPSMonitor';
import { VirtualRenderer } from '@/d3/SuperGridEngine/VirtualRenderer';
import * as d3 from 'd3';
import type { DataCellData, CellDensityState } from '@/d3/grid-rendering/DataCellRenderer';
import type { D3CoordinateSystem } from '@/types/grid';

interface SuperGridVirtualizedProps {
  cells: DataCellData[];
  coordinateSystem: D3CoordinateSystem;
  densityState: CellDensityState;
  selectedIds: Set<string>;
  onCellClick?: (cell: DataCellData, event: MouseEvent) => void;
  showFPSMonitor?: boolean;  // Development feature flag
}

export function SuperGridVirtualized({
  cells,
  coordinateSystem,
  densityState,
  selectedIds,
  onCellClick,
  showFPSMonitor = process.env.NODE_ENV === 'development',
}: SuperGridVirtualizedProps): JSX.Element {
  const containerRef = useRef<HTMLDivElement>(null);
  const svgRef = useRef<SVGSVGElement>(null);
  const rendererRef = useRef<VirtualRenderer | null>(null);

  // Virtual scrolling hook
  const { virtualRows, totalHeight, totalWidth, isVirtualizing } = useVirtualizedGrid({
    cells,
    coordinateSystem,
    containerRef,
  });

  // FPS monitoring (dev-only)
  const { fps, isPerformant } = useFPSMonitor(showFPSMonitor);

  // Initialize VirtualRenderer
  useEffect(() => {
    if (!svgRef.current) return;

    const g = d3.select(svgRef.current).select<SVGGElement>('.virtual-cells');
    if (g.empty()) return;

    rendererRef.current = new VirtualRenderer(g, {
      coordinateSystem,
      densityState,
      selectedIds,
      onCellClick,
    });

    return () => {
      rendererRef.current?.clear();
      rendererRef.current = null;
    };
  }, [coordinateSystem]);

  // Update renderer config when props change
  useEffect(() => {
    rendererRef.current?.updateConfig({ densityState, selectedIds, onCellClick });
  }, [densityState, selectedIds, onCellClick]);

  // Render visible cells when virtualRows change
  useEffect(() => {
    if (!rendererRef.current) return;

    const visibleCells = virtualRows.map(row => row.cell);
    rendererRef.current.render(visibleCells);
  }, [virtualRows]);

  return (
    <div
      ref={containerRef}
      className="supergrid-virtualized"
      style={{
        width: '100%',
        height: '100%',
        overflow: 'auto',
        position: 'relative',
      }}
    >
      {/* FPS Monitor (dev-only) */}
      {showFPSMonitor && (
        <div
          className="supergrid-fps-monitor"
          style={{
            position: 'fixed',
            top: 8,
            right: 8,
            padding: '4px 8px',
            background: isPerformant ? '#10b981' : '#ef4444',
            color: 'white',
            borderRadius: 4,
            fontSize: 12,
            fontFamily: 'monospace',
            zIndex: 9999,
          }}
        >
          {fps} FPS {isVirtualizing ? '(virtualized)' : ''}
        </div>
      )}

      {/* Virtualized content container */}
      <div
        style={{
          height: totalHeight,
          width: totalWidth,
          position: 'relative',
        }}
      >
        <svg
          ref={svgRef}
          width={totalWidth}
          height={totalHeight}
          style={{ position: 'absolute', top: 0, left: 0 }}
        >
          <g className="virtual-cells" />
        </svg>
      </div>
    </div>
  );
}
```

Update hooks/index.ts to export new hooks:

Add to existing exports:
```typescript
export { useFPSMonitor } from './useFPSMonitor';
export { useVirtualizedGrid } from './useVirtualizedGrid';
```
  </action>
  <verify>
Run `npm run check:types` to verify no TypeScript errors.
Run `npm run dev` and verify the app starts without errors.
Manually inspect that SuperGridVirtualized can be imported.
  </verify>
  <done>
- VirtualRenderer class exists at src/d3/SuperGridEngine/VirtualRenderer.ts
- SuperGridVirtualized component exists at src/components/supergrid/SuperGridVirtualized.tsx
- Both hooks exported from src/hooks/index.ts
- All files compile without TypeScript errors
- FPS monitor shows in development mode (green = 30+ fps)
  </done>
</task>

</tasks>

<verification>
1. Run `npm run check:types` - zero TypeScript errors
2. Run `npm run check:lint` - no new ESLint errors introduced
3. Import test: `import { SuperGridVirtualized } from '@/components/supergrid/SuperGridVirtualized'` compiles
4. Import test: `import { useFPSMonitor, useVirtualizedGrid } from '@/hooks'` compiles
5. FPS monitor visible in dev mode when component renders
</verification>

<success_criteria>
1. SuperGridVirtualized component renders cells using TanStack Virtual
2. Only visible cells are in DOM (verified via browser DevTools Elements panel)
3. FPS counter shows 30+ fps when scrolling 1000+ cell grid
4. D3 join pattern with key function used throughout (per CLAUDE.md)
5. No TypeScript compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/93-polish-performance/93-01-SUMMARY.md`
</output>
