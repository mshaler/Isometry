---
phase: 93-polish-performance
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/supergrid/SuperGridVirtualized.tsx
  - src/components/supergrid/SuperGrid.tsx
  - src/hooks/useVirtualizedGrid.ts
  - src/hooks/useFPSMonitor.ts
  - src/d3/SuperGridEngine/VirtualRenderer.ts
  - src/hooks/index.ts
autonomous: true

must_haves:
  truths:
    - "User can scroll a 10K cell grid at 30+ fps without frame drops"
    - "Only visible cells are rendered in DOM (virtualized)"
    - "FPS counter shows actual frame rate during development"
  artifacts:
    - path: "src/components/supergrid/SuperGridVirtualized.tsx"
      provides: "TanStack Virtual wrapper for SuperGrid"
      exports: ["SuperGridVirtualized"]
    - path: "src/hooks/useVirtualizedGrid.ts"
      provides: "Hook integrating TanStack Virtual with D3 data binding"
      exports: ["useVirtualizedGrid"]
    - path: "src/hooks/useFPSMonitor.ts"
      provides: "Development-only FPS monitoring hook"
      exports: ["useFPSMonitor"]
    - path: "src/d3/SuperGridEngine/VirtualRenderer.ts"
      provides: "D3 renderer for virtualized cells using DataCellRenderer"
      exports: ["VirtualRenderer"]
  key_links:
    - from: "src/components/supergrid/SuperGridVirtualized.tsx"
      to: "@tanstack/react-virtual"
      via: "useVirtualizer hook"
      pattern: "useVirtualizer"
    - from: "src/d3/SuperGridEngine/VirtualRenderer.ts"
      to: "src/d3/grid-rendering/DataCellRenderer.ts"
      via: "imports and delegates to DataCellRenderer.render()"
      pattern: "import.*DataCellRenderer"
    - from: "src/components/supergrid/SuperGrid.tsx"
      to: "src/components/supergrid/SuperGridVirtualized.tsx"
      via: "conditional rendering based on cell count"
      pattern: "SuperGridVirtualized"
---

<objective>
Implement virtual scrolling for SuperGrid data cells using TanStack Virtual (already installed) to maintain 30+ fps when rendering 10K+ cells.

Purpose: PERF-01 requires 30+ fps for >1000 cells. Current implementation renders all cells in DOM which causes severe performance degradation at scale. TanStack Virtual calculates visible rows and D3 binds data only to visible cells.

Output: SuperGridVirtualized component, useVirtualizedGrid hook, useFPSMonitor hook (dev-only), VirtualRenderer class, SuperGrid integration
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/93-polish-performance/93-RESEARCH.md

@src/components/supergrid/SuperGrid.tsx
@src/components/supergrid/SuperGridScrollContainer.tsx
@src/d3/grid-rendering/DataCellRenderer.ts
@src/hooks/useDataCellRenderer.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useFPSMonitor hook for performance validation</name>
  <files>src/hooks/useFPSMonitor.ts</files>
  <action>
Create a development-only FPS monitoring hook using requestAnimationFrame:

```typescript
// src/hooks/useFPSMonitor.ts
import { useState, useEffect, useRef, useCallback } from 'react';

interface FPSMonitorState {
  fps: number;
  isPerformant: boolean;  // >= 30fps (PERF-01 requirement)
  isSmooth: boolean;      // >= 55fps (target 60fps with buffer)
  avgFps: number;         // Rolling average over 1 second
}

export function useFPSMonitor(enabled: boolean = true): FPSMonitorState {
  const [state, setState] = useState<FPSMonitorState>({
    fps: 60,
    isPerformant: true,
    isSmooth: true,
    avgFps: 60,
  });

  const framesRef = useRef<number[]>([]);
  const rafIdRef = useRef<number | null>(null);

  useEffect(() => {
    // Only run in development and when enabled
    if (process.env.NODE_ENV !== 'development' || !enabled) {
      return;
    }

    let lastTime = performance.now();

    const tick = (currentTime: number) => {
      // Calculate delta since last frame
      const delta = currentTime - lastTime;
      lastTime = currentTime;

      // Add frame timestamp
      framesRef.current.push(currentTime);

      // Keep only last second of frames
      const oneSecondAgo = currentTime - 1000;
      framesRef.current = framesRef.current.filter(t => t > oneSecondAgo);

      // Calculate FPS (frames in last second)
      const currentFPS = framesRef.current.length;

      setState({
        fps: currentFPS,
        isPerformant: currentFPS >= 30,
        isSmooth: currentFPS >= 55,
        avgFps: currentFPS,
      });

      rafIdRef.current = requestAnimationFrame(tick);
    };

    rafIdRef.current = requestAnimationFrame(tick);

    return () => {
      if (rafIdRef.current !== null) {
        cancelAnimationFrame(rafIdRef.current);
      }
    };
  }, [enabled]);

  return state;
}
```

Key design decisions:
- Only runs in development (process.env.NODE_ENV check)
- Uses requestAnimationFrame for accurate frame timing
- Tracks rolling 1-second average for stable readings
- Returns isPerformant (30+ fps) per PERF-01 requirement
  </action>
  <verify>
Run `npm run check:types` to verify no TypeScript errors.
Create a simple test: `import { useFPSMonitor } from '@/hooks/useFPSMonitor'` compiles.
  </verify>
  <done>
useFPSMonitor hook exists at src/hooks/useFPSMonitor.ts, exports FPSMonitorState interface and useFPSMonitor function, compiles without TypeScript errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useVirtualizedGrid hook integrating TanStack Virtual with D3</name>
  <files>src/hooks/useVirtualizedGrid.ts</files>
  <action>
Create a hook that bridges TanStack Virtual with D3.js data binding:

```typescript
// src/hooks/useVirtualizedGrid.ts
import { useRef, useEffect, useMemo } from 'react';
import { useVirtualizer } from '@tanstack/react-virtual';
import * as d3 from 'd3';
import type { DataCellData } from '@/d3/grid-rendering/DataCellRenderer';
import type { D3CoordinateSystem } from '@/types/grid';

interface UseVirtualizedGridOptions {
  cells: DataCellData[];
  coordinateSystem: D3CoordinateSystem;
  containerRef: React.RefObject<HTMLDivElement>;
  overscan?: number;  // Extra rows to render for smooth scrolling (default: 5)
}

interface VirtualizedGridResult {
  virtualRows: Array<{
    index: number;
    start: number;
    size: number;
    cell: DataCellData;
  }>;
  totalHeight: number;
  totalWidth: number;
  isVirtualizing: boolean;  // true if cell count > threshold
}

const VIRTUALIZATION_THRESHOLD = 100;  // Start virtualizing above this

export function useVirtualizedGrid({
  cells,
  coordinateSystem,
  containerRef,
  overscan = 5,
}: UseVirtualizedGridOptions): VirtualizedGridResult {
  const { cellHeight, cellWidth } = coordinateSystem;

  // Calculate grid dimensions
  const maxGridY = useMemo(() => {
    if (cells.length === 0) return 0;
    return Math.max(...cells.map(c => c.gridY)) + 1;
  }, [cells]);

  const maxGridX = useMemo(() => {
    if (cells.length === 0) return 0;
    return Math.max(...cells.map(c => c.gridX)) + 1;
  }, [cells]);

  // Determine if we should virtualize
  const shouldVirtualize = cells.length > VIRTUALIZATION_THRESHOLD;

  // TanStack Virtual row virtualizer
  const rowVirtualizer = useVirtualizer({
    count: maxGridY,
    getScrollElement: () => containerRef.current,
    estimateSize: () => cellHeight,
    overscan,
    enabled: shouldVirtualize,
  });

  // Map virtual rows to cells
  const virtualRows = useMemo(() => {
    if (!shouldVirtualize) {
      // Return all cells without virtualization
      return cells.map((cell, index) => ({
        index,
        start: cell.gridY * cellHeight,
        size: cellHeight,
        cell,
      }));
    }

    // Get visible row indices from virtualizer
    const visibleRowIndices = new Set(
      rowVirtualizer.getVirtualItems().map(item => item.index)
    );

    // Filter cells to only visible rows
    return cells
      .filter(cell => visibleRowIndices.has(cell.gridY))
      .map((cell, index) => {
        const virtualItem = rowVirtualizer.getVirtualItems().find(
          item => item.index === cell.gridY
        );
        return {
          index,
          start: virtualItem?.start ?? cell.gridY * cellHeight,
          size: virtualItem?.size ?? cellHeight,
          cell,
        };
      });
  }, [cells, shouldVirtualize, rowVirtualizer, cellHeight]);

  return {
    virtualRows,
    totalHeight: maxGridY * cellHeight,
    totalWidth: maxGridX * cellWidth,
    isVirtualizing: shouldVirtualize,
  };
}
```

Key design decisions:
- Uses VIRTUALIZATION_THRESHOLD of 100 cells (start virtualizing above this)
- Integrates TanStack Virtual's useVirtualizer with cell data
- Returns isVirtualizing flag for conditional rendering logic
- Calculates total dimensions for scroll container sizing
  </action>
  <verify>
Run `npm run check:types` to verify no TypeScript errors.
Import from hook index: `import { useVirtualizedGrid } from '@/hooks'` compiles after adding export.
  </verify>
  <done>
useVirtualizedGrid hook exists at src/hooks/useVirtualizedGrid.ts, integrates TanStack Virtual with D3 cell data, compiles without TypeScript errors, exported from hooks index.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create VirtualRenderer delegating to DataCellRenderer</name>
  <files>
    src/d3/SuperGridEngine/VirtualRenderer.ts
    src/hooks/index.ts
  </files>
  <action>
Create the VirtualRenderer class that delegates to existing DataCellRenderer for actual cell rendering:

```typescript
// src/d3/SuperGridEngine/VirtualRenderer.ts
import * as d3 from 'd3';
import { DataCellRenderer, type CellDensityState, type DataCellRenderOptions } from '@/d3/grid-rendering/DataCellRenderer';
import type { DataCellData } from '@/types/grid';
import type { D3CoordinateSystem } from '@/types/grid';
import type { Node } from '@/types/node';

interface VirtualRendererConfig {
  coordinateSystem: D3CoordinateSystem;
  densityState: CellDensityState;
  selectedIds: Set<string>;
  onCellClick?: (node: Node, event: MouseEvent) => void;
}

/**
 * VirtualRenderer - Delegates to DataCellRenderer for consistent cell rendering
 *
 * This class wraps DataCellRenderer to render only visible cells from
 * virtualized scrolling. It does NOT re-implement cell rendering logic.
 */
export class VirtualRenderer {
  private container: d3.Selection<SVGGElement, unknown, null, undefined>;
  private config: VirtualRendererConfig;
  private dataCellRenderer: DataCellRenderer;

  constructor(
    container: d3.Selection<SVGGElement, unknown, null, undefined>,
    config: VirtualRendererConfig
  ) {
    this.container = container;
    this.config = config;
    // Create DataCellRenderer instance with coordinate system
    this.dataCellRenderer = new DataCellRenderer(config.coordinateSystem);
  }

  /**
   * Render only visible cells by delegating to DataCellRenderer
   * Uses the same D3 join pattern and rendering logic as non-virtualized mode
   */
  render(visibleCells: DataCellData[]): void {
    const { densityState, selectedIds, onCellClick } = this.config;

    // Convert onCellClick to match DataCellRenderer signature
    const renderOptions: DataCellRenderOptions = {
      densityState,
      selectedIds,
      onCellClick: onCellClick,
      transitionDuration: 150, // Shorter transitions for virtualized scrolling
    };

    // Delegate to DataCellRenderer - it handles all D3 join logic
    this.dataCellRenderer.render(this.container, visibleCells, renderOptions);
  }

  /**
   * Update configuration (e.g., density state changes)
   */
  updateConfig(config: Partial<VirtualRendererConfig>): void {
    this.config = { ...this.config, ...config };
    // Re-create DataCellRenderer if coordinate system changed
    if (config.coordinateSystem) {
      this.dataCellRenderer = new DataCellRenderer(config.coordinateSystem);
    }
  }

  /**
   * Clear all rendered cells
   */
  clear(): void {
    this.container.selectAll('.data-cell').remove();
  }
}
```

Update hooks/index.ts to export new hooks (add these lines):

```typescript
// Add to Performance hooks section:
export { useFPSMonitor } from './useFPSMonitor';
export { useVirtualizedGrid } from './useVirtualizedGrid';
```
  </action>
  <verify>
Run `npm run check:types` to verify no TypeScript errors.
Verify VirtualRenderer imports DataCellRenderer: `grep "import.*DataCellRenderer" src/d3/SuperGridEngine/VirtualRenderer.ts`
  </verify>
  <done>
- VirtualRenderer class exists at src/d3/SuperGridEngine/VirtualRenderer.ts
- VirtualRenderer imports and delegates to DataCellRenderer (not re-implementing)
- Both hooks exported from src/hooks/index.ts
- All files compile without TypeScript errors
  </done>
</task>

<task type="auto">
  <name>Task 4: Create SuperGridVirtualized and integrate into SuperGrid.tsx</name>
  <files>
    src/components/supergrid/SuperGridVirtualized.tsx
    src/components/supergrid/SuperGrid.tsx
  </files>
  <action>
Create the SuperGridVirtualized component:

```typescript
// src/components/supergrid/SuperGridVirtualized.tsx
import { useRef, useEffect, useCallback } from 'react';
import { useVirtualizedGrid } from '@/hooks/useVirtualizedGrid';
import { useFPSMonitor } from '@/hooks/useFPSMonitor';
import { VirtualRenderer } from '@/d3/SuperGridEngine/VirtualRenderer';
import * as d3 from 'd3';
import type { DataCellData } from '@/types/grid';
import type { CellDensityState } from '@/d3/grid-rendering/DataCellRenderer';
import type { D3CoordinateSystem } from '@/types/grid';
import type { Node } from '@/types/node';

interface SuperGridVirtualizedProps {
  cells: DataCellData[];
  coordinateSystem: D3CoordinateSystem;
  densityState: CellDensityState;
  selectedIds: Set<string>;
  onCellClick?: (node: Node, event: MouseEvent) => void;
  showFPSMonitor?: boolean;  // Development feature flag
}

export function SuperGridVirtualized({
  cells,
  coordinateSystem,
  densityState,
  selectedIds,
  onCellClick,
  showFPSMonitor = process.env.NODE_ENV === 'development',
}: SuperGridVirtualizedProps): JSX.Element {
  const containerRef = useRef<HTMLDivElement>(null);
  const svgRef = useRef<SVGSVGElement>(null);
  const rendererRef = useRef<VirtualRenderer | null>(null);

  // Virtual scrolling hook
  const { virtualRows, totalHeight, totalWidth, isVirtualizing } = useVirtualizedGrid({
    cells,
    coordinateSystem,
    containerRef,
  });

  // FPS monitoring (dev-only)
  const { fps, isPerformant } = useFPSMonitor(showFPSMonitor);

  // Initialize VirtualRenderer
  useEffect(() => {
    if (!svgRef.current) return;

    const g = d3.select(svgRef.current).select<SVGGElement>('.virtual-cells');
    if (g.empty()) return;

    rendererRef.current = new VirtualRenderer(g, {
      coordinateSystem,
      densityState,
      selectedIds,
      onCellClick,
    });

    return () => {
      rendererRef.current?.clear();
      rendererRef.current = null;
    };
  }, [coordinateSystem]);

  // Update renderer config when props change
  useEffect(() => {
    rendererRef.current?.updateConfig({ densityState, selectedIds, onCellClick });
  }, [densityState, selectedIds, onCellClick]);

  // Render visible cells when virtualRows change
  useEffect(() => {
    if (!rendererRef.current) return;

    const visibleCells = virtualRows.map(row => row.cell);
    rendererRef.current.render(visibleCells);
  }, [virtualRows]);

  return (
    <div
      ref={containerRef}
      className="supergrid-virtualized"
      style={{
        width: '100%',
        height: '100%',
        overflow: 'auto',
        position: 'relative',
      }}
    >
      {/* FPS Monitor (dev-only) */}
      {showFPSMonitor && (
        <div
          className="supergrid-fps-monitor"
          style={{
            position: 'fixed',
            top: 8,
            right: 8,
            padding: '4px 8px',
            background: isPerformant ? '#10b981' : '#ef4444',
            color: 'white',
            borderRadius: 4,
            fontSize: 12,
            fontFamily: 'monospace',
            zIndex: 9999,
          }}
        >
          {fps} FPS {isVirtualizing ? '(virtualized)' : ''}
        </div>
      )}

      {/* Virtualized content container */}
      <div
        style={{
          height: totalHeight,
          width: totalWidth,
          position: 'relative',
        }}
      >
        <svg
          ref={svgRef}
          width={totalWidth}
          height={totalHeight}
          style={{ position: 'absolute', top: 0, left: 0 }}
        >
          <g className="virtual-cells" />
        </svg>
      </div>
    </div>
  );
}
```

Update SuperGrid.tsx to integrate SuperGridVirtualized:

1. Add import at top of file (around line 19-20):
```typescript
import { SuperGridVirtualized } from './SuperGridVirtualized';
```

2. Add constant for virtualization threshold (after imports, around line 45):
```typescript
/** Threshold for switching to virtualized rendering */
const VIRTUALIZATION_THRESHOLD = 100;
```

3. In the return statement, replace the D3 data cell SVG section (around lines 668-681) with conditional rendering:

Find this section:
```typescript
{/* D3 Data Cell Rendering (Phase 92-02) */}
<svg
  className="supergrid__data-cells-svg"
  ...
```

Replace with:
```typescript
{/* D3 Data Cell Rendering - Virtualized for large datasets */}
{dataCells.length > VIRTUALIZATION_THRESHOLD ? (
  <SuperGridVirtualized
    cells={dataCells}
    coordinateSystem={coordinateSystem}
    densityState={{ valueDensity: densityState.valueDensity }}
    selectedIds={selection.selectedIds}
    onCellClick={handleCellClick}
  />
) : (
  <svg
    className="supergrid__data-cells-svg"
    style={{
      position: 'absolute',
      top: 0,
      left: 0,
      width: '100%',
      height: '100%',
      pointerEvents: 'none',
    }}
  >
    <g ref={dataGridRef} style={{ pointerEvents: 'auto' }} />
  </svg>
)}
```

This ensures:
- Small datasets (<100 cells) use direct D3 rendering (no virtualization overhead)
- Large datasets (>=100 cells) use SuperGridVirtualized for performance
- Both paths use the same DataCellRenderer for consistent appearance
  </action>
  <verify>
Run `npm run check:types` to verify no TypeScript errors.
Run `npm run dev` and verify:
1. With <100 cells: standard D3 rendering (no FPS monitor)
2. With >=100 cells: SuperGridVirtualized with FPS monitor (dev mode)
3. Scroll a large dataset - FPS should stay at 30+
  </verify>
  <done>
- SuperGridVirtualized component exists at src/components/supergrid/SuperGridVirtualized.tsx
- SuperGrid.tsx conditionally renders SuperGridVirtualized for large datasets
- Virtualization threshold is 100 cells
- FPS monitor shows in development mode (green = 30+ fps)
- All files compile without TypeScript errors
  </done>
</task>

</tasks>

<verification>
1. Run `npm run check:types` - zero TypeScript errors
2. Run `npm run check:lint` - no new ESLint errors introduced
3. Import test: `import { SuperGridVirtualized } from '@/components/supergrid/SuperGridVirtualized'` compiles
4. Import test: `import { useFPSMonitor, useVirtualizedGrid } from '@/hooks'` compiles
5. FPS monitor visible in dev mode when rendering 100+ cells
6. VirtualRenderer delegates to DataCellRenderer (grep confirms import)
</verification>

<success_criteria>
1. SuperGridVirtualized component renders cells using TanStack Virtual
2. VirtualRenderer delegates to DataCellRenderer (not re-implementing)
3. SuperGrid.tsx conditionally uses SuperGridVirtualized for large datasets
4. Only visible cells are in DOM (verified via browser DevTools Elements panel)
5. FPS counter shows 30+ fps when scrolling 1000+ cell grid
6. D3 join pattern with key function used throughout (per CLAUDE.md)
7. No TypeScript compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/93-polish-performance/93-01-SUMMARY.md`
</output>
