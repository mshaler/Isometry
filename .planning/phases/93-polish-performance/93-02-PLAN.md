---
phase: 93-polish-performance
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/supergrid/SuperGrid.tsx
  - src/components/supergrid/SuperGridEmptyState.tsx
  - src/components/supergrid/SuperGridAccessibility.tsx
autonomous: true

must_haves:
  truths:
    - "Screen reader announces grid structure (rows, columns, cells)"
    - "User sees informative message when grid has no data"
    - "User sees different empty states for 'no data' vs 'filtered out' vs 'error'"
    - "Arrow keys navigate between grid cells"
  artifacts:
    - path: "src/components/supergrid/SuperGridEmptyState.tsx"
      provides: "Empty state variants (first-use, no-results, error)"
      exports: ["SuperGridEmptyState", "EmptyStateType"]
    - path: "src/components/supergrid/SuperGridAccessibility.tsx"
      provides: "ARIA grid wrapper with keyboard navigation hook"
      exports: ["SuperGridAccessibility", "useGridKeyboardNavigation"]
  key_links:
    - from: "src/components/supergrid/SuperGrid.tsx"
      to: "src/components/supergrid/SuperGridEmptyState.tsx"
      via: "conditional render when nodes.length === 0"
      pattern: "SuperGridEmptyState"
    - from: "src/components/supergrid/SuperGrid.tsx"
      to: "src/hooks/data/usePAFV"
      via: "usePAFV hook for filter state detection"
      pattern: "const \\{ state: pafvState \\} = usePAFV"
    - from: "src/components/supergrid/SuperGridAccessibility.tsx"
      to: "SuperGrid.tsx"
      via: "role='grid' wrapper with aria attributes"
      pattern: "role=\"grid\""
---

<objective>
Add ARIA accessibility attributes for screen reader support (A11Y-01) and create informative empty state variants (UX-01).

Purpose: A11Y-01 requires ARIA labels for screen readers. UX-01 requires informative empty states. Currently, empty grid shows minimal "No Data" message without actionable guidance.

Output: SuperGridEmptyState component with 3 variants, SuperGridAccessibility wrapper with ARIA grid pattern, keyboard navigation hook
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/93-polish-performance/93-RESEARCH.md

@src/components/supergrid/SuperGrid.tsx
@src/hooks/data/usePAFV.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SuperGridEmptyState component with three variants</name>
  <files>src/components/supergrid/SuperGridEmptyState.tsx</files>
  <action>
Create an empty state component following UX best practices from research:
- Clear explanation (why empty)
- Actionable CTA (what to do next)
- Optional visual (icon)

```typescript
// src/components/supergrid/SuperGridEmptyState.tsx
import { type ReactNode } from 'react';

export type EmptyStateType = 'first-use' | 'no-results' | 'error';

interface SuperGridEmptyStateProps {
  type: EmptyStateType;
  /** Optional error message for 'error' type */
  errorMessage?: string;
  /** Optional custom action button */
  action?: ReactNode;
  /** Optional SQL query for debugging */
  sql?: string;
}

/**
 * SuperGridEmptyState - Informative empty state variants (UX-01)
 *
 * Three variants per research:
 * 1. first-use: No data yet, guide user to add items
 * 2. no-results: Filters active, no matches found
 * 3. error: Query or load failed
 */
export function SuperGridEmptyState({
  type,
  errorMessage,
  action,
  sql,
}: SuperGridEmptyStateProps): JSX.Element {
  const config = getEmptyStateConfig(type, errorMessage);

  return (
    <div
      className="supergrid-empty-state"
      role="status"
      aria-live="polite"
      style={{
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
        padding: '48px 24px',
        textAlign: 'center',
        minHeight: '300px',
        background: '#fafafa',
        borderRadius: '8px',
        border: '1px dashed #e5e7eb',
      }}
    >
      {/* Icon */}
      <div
        className="supergrid-empty-state__icon"
        style={{
          fontSize: '48px',
          marginBottom: '16px',
          opacity: 0.8,
        }}
        aria-hidden="true"
      >
        {config.icon}
      </div>

      {/* Title */}
      <h3
        className="supergrid-empty-state__title"
        style={{
          fontSize: '18px',
          fontWeight: 600,
          color: '#1f2937',
          margin: '0 0 8px 0',
        }}
      >
        {config.title}
      </h3>

      {/* Description */}
      <p
        className="supergrid-empty-state__description"
        style={{
          fontSize: '14px',
          color: '#6b7280',
          margin: '0 0 24px 0',
          maxWidth: '400px',
          lineHeight: 1.5,
        }}
      >
        {config.description}
      </p>

      {/* Action button */}
      {action ? (
        action
      ) : config.actionLabel ? (
        <button
          className="supergrid-empty-state__action"
          style={{
            padding: '8px 16px',
            fontSize: '14px',
            fontWeight: 500,
            color: '#ffffff',
            background: '#3b82f6',
            border: 'none',
            borderRadius: '6px',
            cursor: 'pointer',
          }}
          onClick={config.actionHandler}
        >
          {config.actionLabel}
        </button>
      ) : null}

      {/* Debug info for error state */}
      {type === 'error' && sql && (
        <details
          style={{
            marginTop: '24px',
            fontSize: '12px',
            color: '#9ca3af',
            maxWidth: '100%',
          }}
        >
          <summary style={{ cursor: 'pointer' }}>SQL Query (Debug)</summary>
          <code
            style={{
              display: 'block',
              marginTop: '8px',
              padding: '8px',
              background: '#f3f4f6',
              borderRadius: '4px',
              overflowX: 'auto',
              whiteSpace: 'pre-wrap',
              wordBreak: 'break-all',
            }}
          >
            {sql}
          </code>
        </details>
      )}
    </div>
  );
}

interface EmptyStateConfig {
  icon: string;
  title: string;
  description: string;
  actionLabel?: string;
  actionHandler?: () => void;
}

function getEmptyStateConfig(type: EmptyStateType, errorMessage?: string): EmptyStateConfig {
  switch (type) {
    case 'first-use':
      return {
        icon: '\u{1F4CA}', // Bar chart emoji (Unicode escape)
        title: 'No Data Yet',
        description: 'Import data from Apple Notes, Markdown files, or create your first card to get started.',
        actionLabel: 'Import Data',
        actionHandler: () => {
          // Dispatch custom event for Shell to handle import
          window.dispatchEvent(new CustomEvent('supergrid:import-request'));
        },
      };

    case 'no-results':
      return {
        icon: '\u{1F50D}', // Magnifying glass emoji (Unicode escape)
        title: 'No Matching Results',
        description: 'Your current filters don\'t match any items. Try adjusting your LATCH filters or clearing the search.',
        actionLabel: 'Clear Filters',
        actionHandler: () => {
          // Dispatch custom event for FilterContext to clear
          window.dispatchEvent(new CustomEvent('supergrid:clear-filters'));
        },
      };

    case 'error':
      return {
        icon: '\u{26A0}\u{FE0F}', // Warning emoji (Unicode escape)
        title: 'Failed to Load Data',
        description: errorMessage || 'An error occurred while loading the grid data. Please try again.',
        actionLabel: 'Retry',
        actionHandler: () => {
          // Dispatch custom event to trigger reload
          window.dispatchEvent(new CustomEvent('supergrid:retry-load'));
        },
      };
  }
}
```

Key design decisions:
- role="status" + aria-live="polite" for screen reader announcements
- Three distinct variants with appropriate icons and CTAs
- Custom event dispatch for actions (Shell can listen and respond)
- SQL query shown in debug details for error state
- Unicode escapes for emojis per CALL-02 decision from Phase 96
  </action>
  <verify>
Run `npm run check:types` to verify no TypeScript errors.
Import test: `import { SuperGridEmptyState } from '@/components/supergrid/SuperGridEmptyState'` compiles.
  </verify>
  <done>
SuperGridEmptyState component exists with three variants (first-use, no-results, error), each with icon, title, description, and action button. Compiles without TypeScript errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SuperGridAccessibility with ARIA grid pattern and keyboard navigation</name>
  <files>src/components/supergrid/SuperGridAccessibility.tsx</files>
  <action>
Create an accessibility wrapper implementing W3C ARIA grid pattern from research:

```typescript
// src/components/supergrid/SuperGridAccessibility.tsx
import { useRef, useEffect, useCallback, type ReactNode, type RefObject } from 'react';

interface SuperGridAccessibilityProps {
  children: ReactNode;
  rowCount: number;
  colCount: number;
  /** Label for screen readers */
  label?: string;
  /** Enable keyboard navigation */
  enableKeyboardNav?: boolean;
  /** Callback when cell receives focus */
  onCellFocus?: (rowIndex: number, colIndex: number) => void;
}

/**
 * SuperGridAccessibility - ARIA grid wrapper (A11Y-01)
 *
 * Implements W3C ARIA Authoring Practices Guide grid pattern:
 * - role="grid" with aria-rowcount, aria-colcount
 * - Arrow key navigation between cells
 * - Roving tabindex (one focusable cell at a time)
 */
export function SuperGridAccessibility({
  children,
  rowCount,
  colCount,
  label = 'Data grid with row and column headers',
  enableKeyboardNav = true,
  onCellFocus,
}: SuperGridAccessibilityProps): JSX.Element {
  const gridRef = useRef<HTMLDivElement>(null);

  // Initialize keyboard navigation
  useGridKeyboardNavigation(gridRef, {
    enabled: enableKeyboardNav,
    onCellFocus,
  });

  return (
    <div
      ref={gridRef}
      role="grid"
      aria-label={label}
      aria-rowcount={rowCount}
      aria-colcount={colCount}
      tabIndex={0}
      className="supergrid-accessible"
    >
      {children}
    </div>
  );
}

interface GridKeyboardNavOptions {
  enabled: boolean;
  onCellFocus?: (rowIndex: number, colIndex: number) => void;
}

/**
 * useGridKeyboardNavigation - Arrow key navigation for ARIA grid
 *
 * Implements roving tabindex pattern:
 * - Only one cell has tabIndex=0 at a time
 * - Arrow keys move focus between cells
 * - Home/End move to first/last cell in row
 */
export function useGridKeyboardNavigation(
  gridRef: RefObject<HTMLElement>,
  options: GridKeyboardNavOptions
): void {
  const { enabled, onCellFocus } = options;

  const handleKeyDown = useCallback((event: KeyboardEvent) => {
    if (!enabled) return;

    const grid = gridRef.current;
    if (!grid) return;

    const currentCell = document.activeElement;
    if (!currentCell || !grid.contains(currentCell)) return;

    // Find current position
    const row = currentCell.closest('[role="row"]');
    if (!row) return;

    const cells = Array.from(row.querySelectorAll('[role="gridcell"], [role="rowheader"], [role="columnheader"]'));
    const currentColIndex = cells.indexOf(currentCell as Element);
    const rows = Array.from(grid.querySelectorAll('[role="row"]'));
    const currentRowIndex = rows.indexOf(row as Element);

    let nextCell: Element | null = null;
    let nextRowIndex = currentRowIndex;
    let nextColIndex = currentColIndex;

    switch (event.key) {
      case 'ArrowRight':
        nextColIndex = Math.min(currentColIndex + 1, cells.length - 1);
        nextCell = cells[nextColIndex] || null;
        break;

      case 'ArrowLeft':
        nextColIndex = Math.max(currentColIndex - 1, 0);
        nextCell = cells[nextColIndex] || null;
        break;

      case 'ArrowDown': {
        nextRowIndex = Math.min(currentRowIndex + 1, rows.length - 1);
        const nextRow = rows[nextRowIndex];
        const nextRowCells = nextRow?.querySelectorAll('[role="gridcell"], [role="rowheader"], [role="columnheader"]');
        nextCell = nextRowCells?.[currentColIndex] || null;
        break;
      }

      case 'ArrowUp': {
        nextRowIndex = Math.max(currentRowIndex - 1, 0);
        const prevRow = rows[nextRowIndex];
        const prevRowCells = prevRow?.querySelectorAll('[role="gridcell"], [role="rowheader"], [role="columnheader"]');
        nextCell = prevRowCells?.[currentColIndex] || null;
        break;
      }

      case 'Home':
        if (event.ctrlKey) {
          // Ctrl+Home: first cell in grid
          const firstRow = rows[0];
          const firstRowCells = firstRow?.querySelectorAll('[role="gridcell"], [role="rowheader"], [role="columnheader"]');
          nextCell = firstRowCells?.[0] || null;
          nextRowIndex = 0;
          nextColIndex = 0;
        } else {
          // Home: first cell in current row
          nextCell = cells[0] || null;
          nextColIndex = 0;
        }
        break;

      case 'End':
        if (event.ctrlKey) {
          // Ctrl+End: last cell in grid
          const lastRow = rows[rows.length - 1];
          const lastRowCells = lastRow?.querySelectorAll('[role="gridcell"], [role="rowheader"], [role="columnheader"]');
          nextCell = lastRowCells?.[lastRowCells.length - 1] || null;
          nextRowIndex = rows.length - 1;
          nextColIndex = cells.length - 1;
        } else {
          // End: last cell in current row
          nextCell = cells[cells.length - 1] || null;
          nextColIndex = cells.length - 1;
        }
        break;

      default:
        return; // Don't prevent default for other keys
    }

    if (nextCell && nextCell !== currentCell) {
      event.preventDefault();

      // Roving tabindex: remove from current, add to next
      (currentCell as HTMLElement).tabIndex = -1;
      (nextCell as HTMLElement).tabIndex = 0;
      (nextCell as HTMLElement).focus();

      // Notify parent of focus change
      onCellFocus?.(nextRowIndex, nextColIndex);
    }
  }, [enabled, gridRef, onCellFocus]);

  useEffect(() => {
    const grid = gridRef.current;
    if (!grid || !enabled) return;

    grid.addEventListener('keydown', handleKeyDown);
    return () => grid.removeEventListener('keydown', handleKeyDown);
  }, [gridRef, enabled, handleKeyDown]);
}

/**
 * Helper component for ARIA row
 */
export function GridRow({
  children,
  rowIndex,
}: {
  children: ReactNode;
  rowIndex: number;
}): JSX.Element {
  return (
    <div role="row" aria-rowindex={rowIndex}>
      {children}
    </div>
  );
}

/**
 * Helper component for ARIA grid cell
 */
export function GridCell({
  children,
  colIndex,
  isHeader = false,
  isRowHeader = false,
}: {
  children: ReactNode;
  colIndex: number;
  isHeader?: boolean;
  isRowHeader?: boolean;
}): JSX.Element {
  const role = isHeader ? 'columnheader' : isRowHeader ? 'rowheader' : 'gridcell';

  return (
    <div
      role={role}
      aria-colindex={colIndex}
      tabIndex={-1} // Roving tabindex: -1 by default, 0 when focused
    >
      {children}
    </div>
  );
}
```

Key design decisions:
- Implements W3C ARIA grid pattern from research
- Roving tabindex pattern (one cell focusable at a time)
- Arrow keys + Home/End navigation
- Ctrl+Home/End for grid-level navigation
- Helper components for consistent ARIA roles
  </action>
  <verify>
Run `npm run check:types` to verify no TypeScript errors.
Import test: `import { SuperGridAccessibility, useGridKeyboardNavigation } from '@/components/supergrid/SuperGridAccessibility'` compiles.
  </verify>
  <done>
SuperGridAccessibility component exists with ARIA grid pattern, useGridKeyboardNavigation hook implements arrow key navigation, GridRow and GridCell helper components provided. All compile without TypeScript errors.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate empty state into SuperGrid with filter detection</name>
  <files>src/components/supergrid/SuperGrid.tsx</files>
  <action>
Update SuperGrid.tsx to use the new empty state component with proper pafvState access.

NOTE: SuperGrid.tsx already imports usePAFV at line 21:
```typescript
import { usePAFV, useSQLiteQuery } from '@/hooks';
```

And already has pafvState at line 143:
```typescript
const { state: pafvState } = usePAFV();
```

1. Add import for SuperGridEmptyState at top of file (around line 19):
```typescript
import { SuperGridEmptyState, type EmptyStateType } from './SuperGridEmptyState';
```

2. Replace the existing error state (lines 557-569) with new component:
```typescript
// Error state
if (error) {
  return (
    <div className="supergrid supergrid--error">
      <SuperGridEmptyState
        type="error"
        errorMessage={error.message}
        sql={sql}
      />
    </div>
  );
}
```

3. Replace the existing empty state (lines 572-580) with filter-aware variant:
```typescript
// Empty state - determine type based on filter context
// pafvState is already available from usePAFV() hook at line 143
if (!nodes?.length) {
  // Determine empty state type by checking if PAFV has active mappings
  // pafvState.mappings contains axis mappings - if any exist, filters are active
  const hasActiveFilters = pafvState.mappings.length > 0;
  const emptyType: EmptyStateType = hasActiveFilters ? 'no-results' : 'first-use';

  return (
    <div className="supergrid supergrid--empty">
      <SuperGridEmptyState
        type={emptyType}
        sql={sql}
      />
    </div>
  );
}
```

Key implementation notes:
- pafvState is already available from existing usePAFV() hook call
- Check pafvState.mappings.length > 0 to detect active filters
- 'no-results' when filters are active but no matches
- 'first-use' when no filters and no data (fresh start)
  </action>
  <verify>
Run `npm run check:types` to verify no TypeScript errors.
Run `npm run dev` and verify:
1. Empty state shows "No Data Yet" when no nodes and no filters
2. Empty state shows "No Matching Results" when filters active but no matches
3. Error state shows "Failed to Load Data" with SQL query details
  </verify>
  <done>
- SuperGrid uses SuperGridEmptyState for empty/error states
- Filter detection uses existing pafvState from usePAFV hook
- Displays 'no-results' when pafvState.mappings.length > 0
- Displays 'first-use' when no mappings (fresh state)
- No TypeScript errors
  </done>
</task>

<task type="auto">
  <name>Task 4: Integrate ARIA accessibility wrapper into SuperGrid</name>
  <files>src/components/supergrid/SuperGrid.tsx</files>
  <action>
Add ARIA accessibility wrapper and roles to SuperGrid.tsx.

1. Add import for SuperGridAccessibility (add to existing import block around line 19):
```typescript
import { SuperGridAccessibility } from './SuperGridAccessibility';
```

2. Wrap the main grid content with SuperGridAccessibility (around line 583-767).
Find the return statement that starts:
```typescript
return (
  <div
    ref={gridRef}
    className={`supergrid supergrid--${gridLayout.effectiveMode}`}
```

Wrap it with SuperGridAccessibility:
```typescript
return (
  <SuperGridAccessibility
    rowCount={gridData.rowHeaders.length}
    colCount={gridData.columnHeaders.length}
    label={`SuperGrid with ${nodes.length} items in ${gridData.cells.length} cells`}
    enableKeyboardNav={true}
  >
    <div
      ref={gridRef}
      className={`supergrid supergrid--${gridLayout.effectiveMode}`}
      data-mode={gridLayout.effectiveMode}
      data-columns={gridLayout.hasColumns}
      data-rows={gridLayout.hasRows}
    >
      {/* ... rest of existing content unchanged ... */}
    </div>
  </SuperGridAccessibility>
);
```

3. Add ARIA roles to cell rendering (around lines 704-748):
Update the supergrid__cell div to include ARIA attributes:
```typescript
<div
  key={`${cell.rowKey}-${cell.colKey}`}
  className="supergrid__cell"
  role="gridcell"
  aria-rowindex={rowIndex + 1}
  aria-colindex={colIndex + 1}
  tabIndex={-1}
  data-row={cell.rowKey}
  data-col={cell.colKey}
  style={{ gridColumn, gridRow }}
>
```

4. Add role="row" to row container wrapper (if applicable, or wrap cells in row groups).
Since cells are positioned via CSS Grid, add wrapper divs with role="row" or use CSS Grid's implicit row semantics.

For header cells, add role="columnheader" to column headers and role="rowheader" to row headers in the SuperStack component rendering area.

Key implementation notes:
- SuperGridAccessibility wrapper adds role="grid" with aria-rowcount/aria-colcount
- Individual cells get role="gridcell" with aria-rowindex/aria-colindex (1-indexed)
- tabIndex={-1} on cells for roving tabindex pattern (one focused cell has tabIndex=0)
- Arrow key navigation handled by useGridKeyboardNavigation hook in the wrapper
  </action>
  <verify>
Run `npm run check:types` to verify no TypeScript errors.
Run `npm run dev` and verify:
1. Arrow keys navigate between grid cells (check with DevTools focused element)
2. Screen reader announces "grid with X rows, Y columns" (test with VoiceOver on Mac: Cmd+F5)
3. Tab enters grid, arrows navigate cells, Tab exits grid
  </verify>
  <done>
- SuperGrid wrapped with SuperGridAccessibility
- Grid has role="grid" with aria-rowcount, aria-colcount
- Cells have role="gridcell" with aria-rowindex, aria-colindex
- Roving tabindex pattern: cells have tabIndex={-1}
- Arrow key navigation works between cells
- No TypeScript errors
  </done>
</task>

</tasks>

<verification>
1. Run `npm run check:types` - zero TypeScript errors
2. Run `npm run check:lint` - no new ESLint errors
3. Manual test: Empty grid shows appropriate message for each scenario
4. Manual test: Arrow keys navigate between visible cells
5. VoiceOver (Cmd+F5 on Mac): Announces "grid" and cell contents
</verification>

<success_criteria>
1. SuperGridEmptyState renders three distinct variants with appropriate CTAs
2. SuperGridAccessibility wraps grid with proper ARIA roles
3. Empty state correctly detects filter state via pafvState.mappings.length
4. Arrow key navigation moves focus between cells
5. Screen reader announces grid structure (rows, columns)
6. No TypeScript compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/93-polish-performance/93-02-SUMMARY.md`
</output>
