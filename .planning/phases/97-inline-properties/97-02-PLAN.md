# Plan 97-02: Hashtag Mark with Autocomplete

## Objective

Implement `#tag` syntax with autocomplete from existing tags and bidirectional sync to PropertyEditor tags field.

## Requirements Coverage

- **PROP-03**: User can type `#tag` and it auto-completes from existing tags
- **PROP-04**: Tags sync to PropertyEditor tags field

## Design

### TipTap Extension Architecture

Create `HashtagExtension.ts` using TipTap Suggestion (same pattern as WikiLink):

```typescript
// Pattern: #tagname
// - Trigger: # symbol
// - Autocomplete: show existing tags from database
// - Renders as: styled tag badge
// - Syncs: extracted tags update PropertyEditor.tags
```

### Files to Create

1. **`src/components/notebook/editor/extensions/HashtagExtension.ts`**
   - TipTap Mark extension with Suggestion plugin
   - Attributes: `tag` (the tag value)
   - Styled as tag badge: colored background, rounded

2. **`src/components/notebook/editor/HashtagMenu.tsx`**
   - Dropdown menu component for tag suggestions
   - Keyboard navigation (up/down/enter/escape)
   - Filter by typed query

3. **`src/hooks/capture/useHashtagSync.ts`**
   - Extracts all `#tag` marks from editor content
   - Syncs to PropertyEditor tags field
   - Handles bidirectional updates (PropertyEditor → editor)

4. **`src/services/TagService.ts`**
   - Query existing tags from nodes table
   - Cache for performance
   - Used by autocomplete

### Files to Modify

1. **`src/components/notebook/editor/extensions/index.ts`**
   - Export HashtagExtension

2. **`src/hooks/ui/useTipTapEditor.ts`**
   - Add HashtagExtension to editor config
   - Wire up tag autocomplete query function
   - Wire up useHashtagSync

## Implementation Steps

### Step 1: Create TagService (~10 min)

```typescript
// src/services/TagService.ts
import { useSQLiteStore } from '@/stores/sqliteStore';

export class TagService {
  private static cache: string[] | null = null;
  private static cacheExpiry: number = 0;
  private static CACHE_TTL = 60000; // 1 minute

  static async getAllTags(): Promise<string[]> {
    const now = Date.now();
    if (this.cache && now < this.cacheExpiry) {
      return this.cache;
    }

    const db = useSQLiteStore.getState().db;
    if (!db) return [];

    // Query distinct tags from nodes.tags (JSON array)
    const results = db.exec(`
      SELECT DISTINCT value as tag
      FROM nodes, json_each(nodes.tags)
      WHERE nodes.deleted_at IS NULL
      ORDER BY tag
    `);

    const tags = results[0]?.values.map(row => row[0] as string) || [];
    this.cache = tags;
    this.cacheExpiry = now + this.CACHE_TTL;

    return tags;
  }

  static invalidateCache(): void {
    this.cache = null;
    this.cacheExpiry = 0;
  }

  static searchTags(query: string): Promise<string[]> {
    return this.getAllTags().then(tags =>
      tags.filter(tag =>
        tag.toLowerCase().includes(query.toLowerCase())
      ).slice(0, 10)
    );
  }
}
```

### Step 2: Create HashtagExtension (~20 min)

```typescript
// src/components/notebook/editor/extensions/HashtagExtension.ts
import { Mark, mergeAttributes } from '@tiptap/core';
import Suggestion, { SuggestionOptions, SuggestionProps } from '@tiptap/suggestion';
import { PluginKey } from '@tiptap/pm/state';

export interface HashtagOptions {
  HTMLAttributes: Record<string, unknown>;
  suggestion: Partial<SuggestionOptions<string>>;
}

export const HashtagExtension = Mark.create<HashtagOptions>({
  name: 'hashtag',

  addOptions() {
    return {
      HTMLAttributes: {},
      suggestion: {},
    };
  },

  addAttributes() {
    return {
      tag: {
        default: null,
        parseHTML: (element) => element.getAttribute('data-tag'),
        renderHTML: (attributes) => ({ 'data-tag': attributes.tag }),
      },
    };
  },

  parseHTML() {
    return [{ tag: 'span[data-type="hashtag"]' }];
  },

  renderHTML({ HTMLAttributes }) {
    return [
      'span',
      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, {
        'data-type': 'hashtag',
        class: 'hashtag bg-green-100 text-green-800 px-1.5 py-0.5 rounded text-sm cursor-pointer hover:bg-green-200',
      }),
      `#${HTMLAttributes.tag}`,
    ];
  },

  addProseMirrorPlugins() {
    return [
      Suggestion({
        editor: this.editor,
        pluginKey: new PluginKey('hashtagSuggestion'),
        char: '#',
        ...this.options.suggestion,
      }),
    ];
  },
});

export type HashtagSuggestionProps = SuggestionProps<string>;

export function createHashtagSuggestion(
  queryFn: (query: string) => Promise<string[]>,
  onSelectFn: (tag: string) => void,
  renderConfig: SuggestionOptions<string>['render']
): Partial<SuggestionOptions<string>> {
  return {
    char: '#',
    allowSpaces: false,
    items: async ({ query }) => {
      return queryFn(query);
    },
    command: ({ editor, range, props }) => {
      editor
        .chain()
        .focus()
        .deleteRange(range)
        .insertContent([
          {
            type: 'text',
            text: `#${props}`,
            marks: [
              {
                type: 'hashtag',
                attrs: { tag: props },
              },
            ],
          },
        ])
        .run();

      onSelectFn(props);
    },
    render: renderConfig,
  };
}
```

### Step 3: Create HashtagMenu (~15 min)

```typescript
// src/components/notebook/editor/HashtagMenu.tsx
// Similar pattern to WikiLinkMenu.tsx
// - Renders dropdown with tag suggestions
// - Keyboard navigation
// - Click to select
```

### Step 4: Create useHashtagSync (~10 min)

```typescript
// src/hooks/capture/useHashtagSync.ts
// - Extract hashtag marks from editor
// - Sync to PropertyEditor tags field
// - Handle PropertyEditor → editor updates (optional, can defer)
```

### Step 5: Integrate with useTipTapEditor (~5 min)

Wire up HashtagExtension with suggestion configuration.

### Step 6: Add CSS styling (~5 min)

Add styles for hashtag badges in editor CSS.

## Verification

```bash
npm run check:types  # Zero TypeScript errors
npm run check:lint   # Zero new errors
```

### Manual Test Plan

1. Type `#` in editor, verify dropdown appears
2. Type `#work`, verify filtered suggestions
3. Select tag from dropdown, verify badge renders
4. Check PropertyEditor tags field includes the tag
5. Add tag via PropertyEditor, verify it appears in tags list (read-only display)

## Estimated Duration

~65 minutes

## Dependencies

- Plan 97-01 complete (inline property infrastructure)
- WikiLink suggestion pattern
- TagService for querying existing tags
