# Plan 97-01: Inline Property Mark

## Objective

Implement `@key: value` inline property syntax that renders as a styled mark and syncs bidirectionally with PropertyEditor.

## Requirements Coverage

- **PROP-01**: User can type `@key: value` syntax and it renders as inline property mark
- **PROP-02**: Inline properties sync to PropertyEditor panel

## Design

### TipTap Extension Architecture

Create `InlinePropertyExtension.ts` as a TipTap Mark (similar to WikiLink pattern):

```typescript
// Pattern: @key: value
// - Trigger: @ symbol followed by alphanumeric characters
// - Delimiter: colon followed by space
// - Value: text until whitespace or end of block
// - Renders as: styled badge with key:value
```

### Files to Create

1. **`src/components/notebook/editor/extensions/InlinePropertyExtension.ts`**
   - TipTap Mark extension
   - Regex-based input rule: `/@(\w+):\s*([^\s@]+)/`
   - Attributes: `key`, `value`
   - Styled as badge: light background, rounded corners

2. **`src/components/notebook/editor/nodes/InlinePropertyNode.tsx`**
   - React NodeView for editing inline properties
   - Click to edit value
   - Delete button on hover

3. **`src/hooks/capture/useInlinePropertySync.ts`**
   - Extracts all `@key: value` marks from editor content
   - Syncs to PropertyEditor via NotebookContext
   - Debounced (500ms) to match existing property save pattern

### Files to Modify

1. **`src/components/notebook/editor/extensions/index.ts`**
   - Export InlinePropertyExtension

2. **`src/hooks/ui/useTipTapEditor.ts`**
   - Add InlinePropertyExtension to editor config
   - Wire up useInlinePropertySync

3. **`src/components/notebook/PropertyEditor.tsx`**
   - Display inline properties as read-only (sourced from editor)
   - Add visual indicator for inline-sourced vs directly-edited properties

## Implementation Steps

### Step 1: Create InlinePropertyExtension (~15 min)

```typescript
// src/components/notebook/editor/extensions/InlinePropertyExtension.ts
import { Mark, mergeAttributes } from '@tiptap/core';
import { InputRule } from '@tiptap/core';

export interface InlinePropertyAttributes {
  key: string;
  value: string;
}

export const InlinePropertyExtension = Mark.create<{
  HTMLAttributes: Record<string, unknown>;
}>({
  name: 'inlineProperty',

  addAttributes() {
    return {
      key: { default: null },
      value: { default: null },
    };
  },

  parseHTML() {
    return [{ tag: 'span[data-type="inline-property"]' }];
  },

  renderHTML({ HTMLAttributes }) {
    return [
      'span',
      mergeAttributes(HTMLAttributes, {
        'data-type': 'inline-property',
        'data-key': HTMLAttributes.key,
        'data-value': HTMLAttributes.value,
        class: 'inline-property bg-blue-100 text-blue-800 px-1.5 py-0.5 rounded text-sm font-mono',
      }),
      `@${HTMLAttributes.key}: ${HTMLAttributes.value}`,
    ];
  },

  addInputRules() {
    return [
      new InputRule({
        find: /@(\w+):\s*(\S+)\s$/,
        handler: ({ state, range, match }) => {
          const [, key, value] = match;
          const { tr } = state;

          tr.replaceWith(range.from, range.to,
            state.schema.text(`@${key}: ${value}`, [
              state.schema.marks.inlineProperty.create({ key, value })
            ])
          );

          return tr;
        },
      }),
    ];
  },
});
```

### Step 2: Create useInlinePropertySync hook (~10 min)

```typescript
// src/hooks/capture/useInlinePropertySync.ts
import { useCallback, useEffect, useRef } from 'react';
import type { Editor } from '@tiptap/react';
import { debounce } from '@/utils/debounce';

export function useInlinePropertySync(
  editor: Editor | null,
  onPropertiesChange: (properties: Record<string, string>) => void
) {
  const lastPropertiesRef = useRef<string>('');

  const extractProperties = useCallback(() => {
    if (!editor) return {};

    const properties: Record<string, string> = {};
    const doc = editor.state.doc;

    doc.descendants((node) => {
      node.marks.forEach((mark) => {
        if (mark.type.name === 'inlineProperty') {
          properties[mark.attrs.key] = mark.attrs.value;
        }
      });
    });

    return properties;
  }, [editor]);

  const debouncedSync = useCallback(
    debounce(() => {
      const properties = extractProperties();
      const serialized = JSON.stringify(properties);

      if (serialized !== lastPropertiesRef.current) {
        lastPropertiesRef.current = serialized;
        onPropertiesChange(properties);
      }
    }, 500),
    [extractProperties, onPropertiesChange]
  );

  useEffect(() => {
    if (!editor) return;

    const handleUpdate = () => debouncedSync();
    editor.on('update', handleUpdate);

    return () => {
      editor.off('update', handleUpdate);
    };
  }, [editor, debouncedSync]);
}
```

### Step 3: Integrate with TipTap editor (~5 min)

Update `useTipTapEditor.ts` to include the extension.

### Step 4: Add CSS styling (~5 min)

Add styles for inline property badges in editor CSS.

## Verification

```bash
npm run check:types  # Zero TypeScript errors
npm run check:lint   # Zero new errors
```

### Manual Test Plan

1. Type `@status: active` followed by space in editor
2. Verify it renders as styled badge
3. Check PropertyEditor shows "status: active"
4. Edit in PropertyEditor, verify badge doesn't duplicate (one-way sync)

## Estimated Duration

~35 minutes

## Dependencies

- Phase 96 complete (slash commands infrastructure)
- TipTap Mark extension pattern (from WikiLink)
- PropertyEditor sync pattern (from existing debounced save)
