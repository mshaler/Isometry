---
phase: 15-live-data-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [
  "src/hooks/useLiveData.tsx",
  "src/contexts/LiveDataContext.tsx",
  "src/components/debug/DataFlowMonitor.tsx",
  "native/Sources/Isometry/WebView/DatabaseMessageHandler.swift"
]
autonomous: false
user_setup: []

must_haves:
  truths:
    - "React components receive live data from native Swift database"
    - "Canvas renders actual nodes from 6,891 imported Apple Notes"
    - "Data updates flow through bridge within 100ms"
    - "Bridge communication errors are handled gracefully"
    - "Performance remains smooth with large datasets"
  artifacts:
    - path: "src/hooks/useLiveData.tsx"
      provides: "React hook for live data subscription"
      min_lines: 150
    - path: "src/contexts/LiveDataContext.tsx"
      provides: "Context for live data state management"
      min_lines: 100
    - path: "src/components/debug/DataFlowMonitor.tsx"
      provides: "Real-time data flow debugging UI"
      min_lines: 80
    - path: "native/Sources/Isometry/WebView/DatabaseMessageHandler.swift"
      provides: "Enhanced message handler with live subscriptions"
      contains: "subscription"
  key_links:
    - from: "src/hooks/useLiveData.tsx"
      to: "window._isometryBridge.database"
      via: "WebView bridge subscription"
      pattern: "sendMessage.*subscribe"
    - from: "native/Sources/Isometry/WebView/DatabaseMessageHandler.swift"
      to: "IsometryDatabase"
      via: "database query execution"
      pattern: "database\\.(read|write)"
    - from: "React components"
      to: "Swift database"
      via: "Live data context and bridge"
      pattern: "useLiveData.*nodes"
---

<objective>
Establish real-time data connection between React frontend and native Swift database, enabling live visualization of the 6,891 imported Apple Notes with seamless bridge communication and performance monitoring.

Purpose: Transform the WebView bridge from static API calls to live data streaming, enabling React components to visualize and interact with real dataset from native SQLite database while maintaining 60fps performance.
Output: Live data integration with real-time React-to-Swift data flow, performance monitoring, and graceful error handling for production-ready data visualization.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# WebView bridge infrastructure - established in Phase 14.x
@native/Sources/Isometry/WebView/WebViewBridge.swift
@native/Sources/Isometry/WebView/DatabaseMessageHandler.swift

# React database context system
@src/contexts/EnvironmentContext.tsx
@src/hooks/useBridgeDatabase.tsx
@src/db/WebViewDatabaseContext.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Live Data Hook Implementation</name>
  <files>src/hooks/useLiveData.tsx</files>
  <action>
    Create comprehensive live data hook with real-time subscription management:

    - **Core Subscription System**: Implement useLiveData hook with subscription to native database changes
    - **Data Fetching**: Add methods for getNodes, searchNodes, getFilteredNodes using bridge
    - **Real-time Updates**: Set up listener system for database change notifications via bridge
    - **Error Handling**: Comprehensive error boundaries for bridge disconnection and query failures
    - **Performance Optimization**: Debouncing, caching, and stale-while-revalidate patterns
    - **TypeScript Safety**: Full type definitions for Node data and query responses
    - **Memory Management**: Automatic cleanup of subscriptions and cached data

    Key features:
    - useNodes(options) hook for fetching node collections
    - useNodeSearch(query) hook for FTS5 search results
    - useNodeDetails(id) hook for individual node data
    - useDataSubscription() for real-time updates
    - Built-in loading states and error handling
    - Bridge health monitoring integration

    Integration with existing bridge infrastructure through DatabaseMessageHandler methods.
  </action>
  <verify>npm test -- --testNamePattern="useLiveData" passes, TypeScript compilation clean</verify>
  <done>useLiveData hooks provide reactive data access with real-time updates from native database</done>
</task>

<task type="auto">
  <name>Task 2: Live Data Context Provider</name>
  <files>src/contexts/LiveDataContext.tsx</files>
  <action>
    Create LiveDataContext for application-wide data state management:

    - **Context Architecture**: Provider pattern for live data state across React app
    - **State Management**: Central store for nodes, search results, subscriptions
    - **Bridge Integration**: Connection to WebView bridge with health monitoring
    - **Cache Management**: LRU cache for frequently accessed nodes and queries
    - **Subscription Manager**: Handle multiple component subscriptions efficiently
    - **Error Recovery**: Automatic retry and fallback strategies for failed bridge calls
    - **Performance Metrics**: Track query performance, cache hit rates, bridge latency

    State structure:
    - nodes: Map<string, Node> for cached node data
    - subscriptions: Set of active data subscriptions
    - searchResults: Map<string, Node[]> for cached search results
    - bridgeHealth: Connection status and performance metrics
    - loading: Per-operation loading states
    - errors: Categorized error handling (network, data, bridge)

    Integrates with existing EnvironmentContext and DatabaseContext patterns.
  </action>
  <verify>Context provider works without TypeScript errors, integrates with existing context hierarchy</verify>
  <done>LiveDataContext manages application-wide live data state with bridge integration</done>
</task>

<task type="auto">
  <name>Task 3: Data Flow Debug Monitor</name>
  <files>src/components/debug/DataFlowMonitor.tsx</files>
  <action>
    Create comprehensive data flow monitoring and debugging interface:

    - **Real-time Metrics Dashboard**: Display live bridge performance, query latency, cache statistics
    - **Data Flow Visualization**: Show data requests, responses, and errors in real-time
    - **Bridge Health Monitor**: Connection status, pending requests, message handler availability
    - **Query Inspector**: Log and inspect SQL queries, parameters, and results
    - **Performance Profiler**: Track render performance impact of live data updates
    - **Error Log**: Categorized error display with retry capabilities
    - **Data Inspector**: Browse cached nodes, search results, and subscription status

    UI components:
    - Metrics overview cards (queries/sec, avg latency, cache hit rate)
    - Real-time query log with filtering and search
    - Bridge status indicator with detailed health info
    - Interactive data browser for cached content
    - Performance charts showing trends and spikes
    - Error console with categorization and stack traces

    Development tool for monitoring live data integration performance and debugging issues.
  </action>
  <verify>Debug monitor displays real bridge data, performance metrics update in real-time</verify>
  <done>DataFlowMonitor provides comprehensive debugging interface for live data integration</done>
</task>

<task type="auto">
  <name>Task 4: Swift Database Message Handler Enhancement</name>
  <files>native/Sources/Isometry/WebView/DatabaseMessageHandler.swift</files>
  <action>
    Enhance existing DatabaseMessageHandler with live data subscription capabilities:

    - **Subscription Management**: Add subscription/unsubscribe methods for real-time data updates
    - **Change Notifications**: Implement database change listener that notifies React subscribers
    - **Performance Optimization**: Add query result caching and intelligent invalidation
    - **Bulk Operations**: Support efficient bulk data retrieval for large datasets (6,891 notes)
    - **Streaming Support**: Handle large result sets with pagination and streaming
    - **Error Enhancement**: Improve error categorization and recovery strategies
    - **Metrics Collection**: Track query performance, subscription counts, cache effectiveness

    New message handler methods:
    - subscribeToNodes: Subscribe to node changes with filter options
    - unsubscribeFromNodes: Clean up subscriptions
    - getBulkNodes: Efficient bulk retrieval with pagination
    - getCachedQuery: Retrieve cached query results
    - getPerformanceStats: Bridge performance metrics

    Preserve existing execute, getNodes, createNode, etc. methods while adding subscription layer.

    Use existing IsometryDatabase actor patterns for thread safety and performance.
  </action>
  <verify>Swift compilation succeeds, existing bridge functionality preserved, new subscription methods available</verify>
  <done>DatabaseMessageHandler supports live data subscriptions with enhanced performance and error handling</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete live data integration system with React hooks, context provider, debug monitor, and enhanced Swift message handler</what-built>
  <how-to-verify>
    1. Open native IsometryApp and navigate to React interface
    2. Open browser developer tools and check DataFlowMonitor component
    3. Verify data flow metrics show:
       - Bridge connection status: Connected
       - Active subscriptions: > 0
       - Query latency: < 100ms
       - Cache hit rate: > 50%
    4. Test live data hooks:
       - Navigate to canvas/visualization view
       - Confirm nodes render from actual database (should see Apple Notes data)
       - Verify real-time updates when data changes
       - Check search functionality works with live data
    5. Test error handling:
       - Simulate bridge disconnection
       - Verify graceful degradation and error recovery
    6. Performance verification:
       - Navigate with large datasets (6,891 notes)
       - Confirm smooth 60fps performance
       - Verify memory usage remains stable
    7. Check debug monitor functionality:
       - Real-time metrics update correctly
       - Query log shows actual SQL queries
       - Error handling displays appropriate messages
  </how-to-verify>
  <resume-signal>Type "live data integration verified" to continue, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
Live data integration system verification:

1. **Data Flow Verification**
   - React components receive actual data from native SQLite database
   - All 6,891 Apple Notes accessible through live data hooks
   - Bridge latency consistently under 100ms for data operations

2. **Performance Verification**
   - Canvas rendering maintains 60fps with live data updates
   - Memory usage remains stable during large dataset operations
   - Query caching achieves >50% hit rate for repeated operations

3. **Error Handling Verification**
   - Bridge disconnection handled gracefully with retry logic
   - Invalid queries return meaningful error messages
   - Component state remains consistent during error scenarios

4. **Debug Monitoring Verification**
   - Real-time metrics display accurately in DataFlowMonitor
   - Query logging captures actual SQL execution with parameters
   - Performance profiling identifies optimization opportunities

5. **Integration Verification**
   - Live data hooks integrate seamlessly with existing React components
   - Context provider works with established environment detection
   - Swift message handler maintains compatibility with existing bridge methods
</verification>

<success_criteria>
1. **Functional Success**: React components display real data from 6,891 imported Apple Notes
2. **Performance Success**: Live data updates maintain <100ms latency and 60fps rendering
3. **Reliability Success**: Bridge errors handled gracefully with automatic recovery
4. **Developer Success**: Debug monitoring provides actionable insights for optimization
5. **Integration Success**: Live data system integrates seamlessly with existing architecture

**Phase 15 enables real-time data visualization of actual dataset through production-ready WebView bridge integration.**
</success_criteria>

<output>
After completion, create `.planning/phases/15-live-data-integration/15-01-SUMMARY.md`
</output>