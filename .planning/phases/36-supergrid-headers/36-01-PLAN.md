---
phase: 36-supergrid-headers
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [
  "src/d3/SuperGridHeaders.ts",
  "src/services/HeaderLayoutService.ts",
  "src/types/grid.ts"
]
autonomous: true

must_haves:
  truths:
    - "User sees multi-level hierarchical headers with visual spanning across parent-child relationships"
    - "Header cells span appropriately across child dimensions without layout conflicts"
    - "User can expand/collapse header levels while maintaining grid performance"
  artifacts:
    - path: "src/d3/SuperGridHeaders.ts"
      provides: "Hierarchical header rendering system using d3-hierarchy"
      exports: ["SuperGridHeaders"]
      min_lines: 200
    - path: "src/services/HeaderLayoutService.ts"
      provides: "Hybrid span calculation and layout engine"
      exports: ["HeaderLayoutService", "calculateSpanWidths", "generateHeaderHierarchy"]
      min_lines: 150
    - path: "src/types/grid.ts"
      provides: "Extended types for hierarchical header structures"
      contains: "interface HeaderNode"
  key_links:
    - from: "src/d3/SuperGridHeaders.ts"
      to: "d3-hierarchy.stratify"
      via: "data transformation import"
      pattern: "import.*stratify.*d3-hierarchy"
    - from: "src/services/HeaderLayoutService.ts"
      to: "src/types/grid.HeaderNode"
      via: "type definitions import"
      pattern: "import.*HeaderNode.*grid"
    - from: "src/d3/SuperGrid.ts"
      to: "src/d3/SuperGridHeaders.ts"
      via: "header rendering integration"
      pattern: "new SuperGridHeaders"
---

<objective>
Implement the hierarchical header foundation system with nested PAFV headers and visual spanning across multiple dimension levels.

Purpose: Transform the current flat header system into a multi-level hierarchical structure where parent headers span their children with visual boundaries, enabling n-dimensional data projection through stacked headers. This establishes the core data transformation and rendering foundation for Phase 36.

Output: Working hierarchical header system with expand/collapse functionality, hybrid span calculations, and content-aware alignment, ready for Janus controls integration in Plan 2.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 36 user decisions and research
@.planning/phases/36-supergrid-headers/36-CONTEXT.md
@.planning/phases/36-supergrid-headers/36-RESEARCH.md

# Current SuperGrid foundation
@src/d3/SuperGrid.ts
@src/types/grid.ts
@src/services/LATCHFilterService.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Grid Types for Hierarchical Headers</name>
  <files>src/types/grid.ts</files>
  <action>
    Extend the existing grid type system to support hierarchical header structures. Add HeaderNode interface for d3-hierarchy integration with properties for id, label, parentId, facet, value, count, level, span, and children. Add HeaderHierarchy interface for the full tree structure. Add SpanCalculationConfig interface for the user-decided hybrid span calculation (data-proportional + content-based minimums + equal distribution fallback). Add ContentAlignment enum for user-decided content-aware alignment rules (center for short spans, left for long spans, numeric right-align, dates left-align). Ensure all new types integrate cleanly with existing AxisData interface.

    User decisions to honor exactly:
    - Dynamic/unlimited nesting depth based on data complexity
    - Hybrid span calculation: data-proportional + content-based minimums + equal distribution fallback
    - Content-aware alignment: center for short spans, left-align for long spans, numeric right-align, dates left-align
    - Per-dataset, per-app state persistence required
  </action>
  <verify>npm run typecheck passes with zero errors, new interfaces export correctly</verify>
  <done>HeaderNode, HeaderHierarchy, SpanCalculationConfig, and ContentAlignment types exist and integrate with existing grid type system</done>
</task>

<task type="auto">
  <name>Task 2: Create Header Layout Service</name>
  <files>src/services/HeaderLayoutService.ts</files>
  <action>
    Create HeaderLayoutService class implementing the user-decided hybrid span calculation system. Implement calculateSpanWidths method using data-proportional primary sizing (columns with more data get more space), content-based minimums (header text must fit), and equal distribution as fallback when data counts are uniform. This mirrors how Numbers and modern pivot tables handle column sizing per user specification. Implement generateHeaderHierarchy method converting flat LATCH data to nested hierarchy using d3-hierarchy stratify. Add getContentAlignment method implementing content-aware alignment rules: center for short spans (1-3 words), left-align for long spans (multi-word), numeric content right-align, dates left-align. Add state persistence methods for expanded/collapsed levels per user requirement. Include proper error handling and TypeScript strict mode compliance.

    User decisions to honor exactly:
    - Data-proportional for primary sizing, content-based minimums prevent illegibility, equal distribution as fallback
    - Content serves scannability over uniformity
    - Per-dataset and per-app state persistence required
    - Progressive rendering with lazy fallback when performance budgets exceeded
  </action>
  <verify>npm run typecheck passes, service exports all required methods, calculateSpanWidths returns valid width values</verify>
  <done>HeaderLayoutService provides hybrid span calculations, hierarchy generation, content alignment, and state persistence as specified in user decisions</done>
</task>

<task type="auto">
  <name>Task 3: Implement SuperGridHeaders Renderer</name>
  <files>src/d3/SuperGridHeaders.ts</files>
  <action>
    Create SuperGridHeaders class using d3-hierarchy for nested header rendering. Use d3.stratify to convert flat header data to hierarchy, then render each level as SVG groups with proper transforms. Implement multi-level header rendering with visual spanning using SVG rect elements and CSS-style span calculations from HeaderLayoutService. Add basic expand/collapse functionality using D3 data binding with key functions (always use d => d.id pattern). Implement the user-decided geometric click zones: parent label zone (~32px) for expand/collapse operations, child header body for data group selection, with "innermost wins + parent label exclusion" rule. Add cursor feedback for zone-specific interactions. Integrate with existing SuperGrid.renderHeaders method by extending rather than replacing. Use progressive rendering approach - render visible levels first, lazy load deeper levels when expanded. Maintain 60fps performance through efficient D3 join patterns and minimal DOM manipulation.

    User decisions to honor exactly:
    - Dynamic/unlimited nesting depth based on data complexity
    - Geometric click zones: parent label ~32px for expand/collapse, child body for selection
    - "innermost wins + parent label exclusion" rule for click handling
    - Cursor feedback eliminates guesswork about click targets
    - Progressive rendering with lazy fallback when performance budgets exceeded
  </action>
  <verify>SuperGrid demo loads without errors, hierarchical headers render with proper spanning, expand/collapse works with click zones</verify>
  <done>Multi-level hierarchical headers render with visual spanning, expand/collapse functionality works, click zones provide proper cursor feedback, and system maintains 60fps performance</done>
</task>

</tasks>

<verification>
1. Run SuperGrid demo and verify multi-level headers render with visual spanning
2. Test expand/collapse functionality with geometric click zones
3. Confirm header text displays with content-aware alignment (center/left/right based on span length and content type)
4. Verify span widths follow hybrid calculation (data-proportional + content minimums + equal fallback)
5. Check that click zones provide proper cursor feedback and trigger correct actions
</verification>

<success_criteria>
1. User sees multi-level hierarchical headers with visual spanning across parent-child relationships
2. Header cells span appropriately across child dimensions without layout conflicts
3. User can expand/collapse header levels while maintaining 60fps performance
4. Click zones work correctly with proper cursor feedback (parent label for expand/collapse, child body for selection)
5. Content alignment follows user-specified rules (center for short, left for long, right for numeric, left for dates)
6. Span widths use hybrid calculation system matching user decisions
7. System ready for Janus controls integration in Plan 2
</success_criteria>

<output>
After completion, create `.planning/phases/36-supergrid-headers/36-01-SUMMARY.md`
</output>