---
phase: 36-supergrid-headers
plan: 02
type: execute
wave: 2
depends_on: ["36-01"]
files_modified: [
  "src/d3/SuperGridZoom.ts",
  "src/d3/SuperGridHeaders.ts",
  "src/db/DatabaseService.ts",
  "src/d3/SuperGrid.ts"
]
autonomous: true

must_haves:
  truths:
    - "User can control data density through orthogonal zoom (value) and pan (extent) controls"
    - "User can navigate with pinned upper-left corner zoom behavior"
    - "Header expansion/collapse animations use morphing boundary style"
    - "User interactions persist per-dataset and per-app with state restoration"
  artifacts:
    - path: "src/d3/SuperGridZoom.ts"
      provides: "Janus orthogonal zoom/pan control system"
      exports: ["SuperGridZoom", "JanusControls"]
      min_lines: 180
    - path: "src/db/DatabaseService.ts"
      provides: "Header state persistence methods"
      contains: "saveHeaderState"
    - path: "src/d3/SuperGridHeaders.ts"
      provides: "Morphing boundary animations and state integration"
      contains: "animateHeaderExpansion"
  key_links:
    - from: "src/d3/SuperGridZoom.ts"
      to: "d3-zoom"
      via: "zoom behavior import"
      pattern: "import.*zoom.*d3"
    - from: "src/d3/SuperGridHeaders.ts"
      to: "d3-transition"
      via: "morphing animations"
      pattern: "transition.*duration.*ease"
    - from: "src/d3/SuperGrid.ts"
      to: "src/d3/SuperGridZoom.ts"
      via: "Janus controls integration"
      pattern: "new SuperGridZoom"
    - from: "src/d3/SuperGridHeaders.ts"
      to: "src/db/DatabaseService.saveHeaderState"
      via: "state persistence calls"
      pattern: "saveHeaderState"
---

<objective>
Implement Janus orthogonal zoom/pan controls and interactive header system with morphing boundary animations and state persistence.

Purpose: Complete the hierarchical header system by adding user-decided separate zoom/pan controls (Janus model), morphing boundary animations using D3 transitions, and comprehensive state persistence. This transforms the foundation from Plan 1 into a fully interactive hierarchical navigation system with cartographic zoom behavior and "quiet app" aesthetic.

Output: Complete SuperGrid header system with Janus density controls, smooth morphing animations, persistent state, and navigation that maintains semantic position during zoom/pan operations.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 36 user decisions and research
@.planning/phases/36-supergrid-headers/36-CONTEXT.md
@.planning/phases/36-supergrid-headers/36-RESEARCH.md

# Plan 1 foundation
@.planning/phases/36-supergrid-headers/36-01-PLAN.md

# Current implementation
@src/d3/SuperGrid.ts
@src/d3/SuperGridHeaders.ts
@src/services/HeaderLayoutService.ts
@src/db/DatabaseService.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Janus Zoom/Pan Control System</name>
  <files>src/d3/SuperGridZoom.ts</files>
  <action>
    Create SuperGridZoom class implementing the user-decided Janus orthogonal density model with separate zoom (value density) and pan (extent density) controls. Implement zoomLevel property controlling value density: 'leaf' shows individual values (Jan, Feb, Mar), 'collapsed' shows summary (Q1). Implement panLevel property controlling extent density: 'sparse' shows full Cartesian product, 'dense' shows populated-only cells. Use d3-zoom for cartographic navigation with user-decided fixed corner anchor (upper-left pinned). Add SparsityDensity slider for user toggle between sparse/dense display. Implement smooth animation transitions with "quiet app" aesthetic - all transitions under 300ms with ease-out curves. Add zoom behavior setup with scaleExtent, translateExtent, and proper event handling. Ensure orthogonal controls operate independently per user decision (zoom without affecting pan, pan without affecting zoom). Include proper TypeScript strict mode compliance and error handling.

    User decisions to honor exactly:
    - Separate controls initially (not combined widget)
    - Smooth animation transitions with "quiet app" aesthetic
    - Fixed corner anchor for zoom operations (upper-left pinned)
    - User toggle for sparse/dense display via SparsityDensity slider
    - Orthogonal controls (zoom and pan operate independently)
  </action>
  <verify>npm run typecheck passes, SuperGridZoom creates separate zoom/pan controls, smooth transitions work under 300ms</verify>
  <done>Janus orthogonal density controls work independently with smooth animations, fixed corner anchor zoom, and sparse/dense toggle functionality</done>
</task>

<task type="auto">
  <name>Task 2: Add Morphing Boundary Animations</name>
  <files>src/d3/SuperGridHeaders.ts</files>
  <action>
    Extend SuperGridHeaders with user-decided morphing boundary animations using D3 transitions. Implement animateHeaderExpansion method using d3-transition with duration 300ms (user-decided smooth transitions, "quiet app" aesthetic). Use ease-out curves for natural motion feel. Animate header span width changes with morphing boundaries - parent headers smoothly adjust span width when children expand/collapse. Animate child header positioning with coordinated transforms - when parent expands, children slide into position maintaining relative layouts. Add proper transition interruption handling - always call interrupt() before starting new transitions to prevent visual glitches from user clicking faster than animations complete. Implement progressive rendering fallback - if animation performance drops below 16ms budget (60fps), fall back to instant state changes. Add dynamic reflow with horizontal scroll fallback per user decision - automatically adjust layout to prevent conflicts while respecting minimum widths, fall back to horizontal scroll when reflow can't resolve narrow screens.

    User decisions to honor exactly:
    - Morphing boundary animation style using D3 transitions
    - Smooth animation transitions with "quiet app" aesthetic (300ms max)
    - Progressive rendering with lazy rendering fallback when performance budgets exceeded
    - Dynamic reflow with horizontal scroll fallback for layout conflict resolution
  </action>
  <verify>Header expand/collapse shows smooth morphing animations, transitions interrupt properly, performance stays above 16ms budget</verify>
  <done>Morphing boundary animations work smoothly with proper interruption handling, progressive rendering fallback, and dynamic reflow with scroll fallback</done>
</task>

<task type="auto">
  <name>Task 3: Implement State Persistence System</name>
  <files>src/db/DatabaseService.ts, src/d3/SuperGridHeaders.ts, src/d3/SuperGrid.ts</files>
  <action>
    Implement comprehensive state persistence for user-decided per-dataset and per-app state requirements. Add saveHeaderState method to DatabaseService accepting dataset_id, app_context, expanded_levels (JSON array of expanded header paths), zoom_level, pan_level, and last_updated timestamp. Add loadHeaderState method returning saved state for dataset/app combination. Add updateHeaderState method for incremental updates during user interactions. In SuperGridHeaders, integrate state persistence by calling saveHeaderState after expand/collapse operations, zoom/pan changes, and density level adjustments. Add state restoration in constructor - automatically restore expanded levels, zoom position, and density settings when headers initialize. In SuperGrid, coordinate state persistence across header and zoom systems. Ensure state saves are debounced to prevent excessive database writes during smooth animations. Add proper error handling for state save/load failures - graceful degradation to default state when persistence fails. Include state versioning for future compatibility.

    User decisions to honor exactly:
    - Per-dataset, per-app state persistence
    - State restoration maintains user's last interaction context
    - Smooth user experience with debounced saves during animations
  </action>
  <verify>Header states persist across page refreshes, zoom/pan positions restore correctly, expanded levels maintain state</verify>
  <done>Complete state persistence system works per-dataset and per-app with automatic restoration, debounced saves, and graceful error handling</done>
</task>

</tasks>

<verification>
1. Test Janus controls work independently - zoom without affecting pan, pan without affecting zoom
2. Verify morphing boundary animations are smooth and under 300ms duration
3. Confirm fixed corner anchor zoom maintains upper-left position during zoom operations
4. Check state persistence - expand headers, refresh page, verify state restoration
5. Test progressive rendering fallback under high load (expand many levels quickly)
6. Verify dynamic reflow with horizontal scroll fallback on narrow screens
</verification>

<success_criteria>
1. User can control data density through orthogonal zoom (value) and pan (extent) controls that operate independently
2. User can navigate with pinned upper-left corner zoom behavior maintaining semantic position
3. Header expansion/collapse shows smooth morphing boundary animations under 300ms duration
4. User interactions persist per-dataset and per-app with automatic state restoration
5. Progressive rendering maintains 60fps performance with lazy fallback when budgets exceeded
6. Dynamic reflow prevents layout conflicts with horizontal scroll fallback on narrow screens
7. Complete hierarchical header system ready for Phase 37 Grid Continuum integration
</success_criteria>

<output>
After completion, create `.planning/phases/36-supergrid-headers/36-02-SUMMARY.md`
</output>