---
phase: 14.4-graph-integration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [
  "src/services/ConnectionSuggestionService.ts",
  "src/services/QueryCacheService.ts",
  "src/utils/GraphPerformanceMonitor.ts",
  "src/hooks/useGraphAnalytics.ts"
]
autonomous: true

must_haves:
  truths:
    - "React components access cached graph analytics with intelligent TTL management"
    - "Connection suggestions render with real-time confidence updates"
    - "Query cache provides 90%+ hit rates for frequently accessed graph data"
    - "Performance monitoring identifies graph analytics bottlenecks with optimization suggestions"
  artifacts:
    - path: "src/services/ConnectionSuggestionService.ts"
      provides: "High-level connection suggestion management with caching and performance optimization"
      exports: ["ConnectionSuggestionService", "SuggestionCache", "SuggestionPerformanceMetrics"]
    - path: "src/services/QueryCacheService.ts"
      provides: "React interface to native QueryCache with intelligent invalidation"
      exports: ["QueryCacheService", "CacheEntry", "CacheStrategy"]
    - path: "src/utils/GraphPerformanceMonitor.ts"
      provides: "Graph analytics performance monitoring and optimization recommendations"
      exports: ["GraphPerformanceMonitor", "AnalyticsMetrics", "OptimizationSuggestion"]
    - path: "src/hooks/useGraphAnalytics.ts"
      provides: "React hook for seamless graph analytics integration"
      exports: ["useGraphAnalytics", "useConnectionSuggestions", "useGraphMetrics"]
  key_links:
    - from: "src/hooks/useGraphAnalytics.ts"
      to: "src/services/ConnectionSuggestionService.ts"
      via: "Hook interface for suggestion management"
      pattern: "useMemo.*ConnectionSuggestionService"
    - from: "src/services/QueryCacheService.ts"
      to: "native/Sources/Isometry/Graph/QueryCache.swift"
      via: "Bridge communication for cache management"
      pattern: "getOrCompute.*bridge"
    - from: "src/utils/GraphPerformanceMonitor.ts"
      to: "src/utils/d3Performance.ts"
      via: "Performance metrics integration"
      pattern: "extend.*d3.*performance"
---

<objective>
Create comprehensive React service layer for native graph analytics integration with intelligent caching, performance monitoring, and React hook interfaces.

Purpose: Build production-ready React services that seamlessly integrate with native graph analytics, providing optimal performance through caching strategies and comprehensive monitoring for enhanced user experience.
Output: Complete service layer enabling React components to leverage native graph analytics with enterprise-grade performance and reliability.
</objective>

<execution_context>
@/Users/mshaler/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mshaler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 14.1-14.3 patterns and infrastructure
@.planning/phases/14-pafv-integration/14-01-SUMMARY.md
@.planning/phases/14.2-latch-filter-integration/14.2-03-SUMMARY.md
@.planning/phases/14.3-d3-canvas-integration/14.3-02-SUMMARY.md

# Phase 14.4-01 foundation (dependency)
@.planning/phases/14.4-graph-integration/14.4-01-PLAN.md

# Performance monitoring patterns
@src/utils/d3Performance.ts

# Native graph analytics capabilities
@native/Sources/Isometry/Graph/ConnectionSuggestionEngine.swift
@native/Sources/Isometry/Graph/QueryCache.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Connection Suggestion Service with Intelligent Caching</name>
  <files>src/services/ConnectionSuggestionService.ts</files>
  <action>
    Create ConnectionSuggestionService.ts for high-level suggestion management:

    Core Service Architecture:
    - ConnectionSuggestionService class with singleton pattern for global state management
    - SuggestionCache with TTL-based invalidation (5-minute default, configurable by suggestion type)
    - Multi-tier caching: in-memory cache → native cache → computation
    - Performance tracking: cache hit rates, computation time, suggestion accuracy

    Advanced Suggestion Management:
    - Intelligent suggestion grouping by type (content, community, temporal, semantic)
    - Suggestion confidence filtering with dynamic thresholds based on graph density
    - Batch optimization for multiple node suggestions with request deduplication
    - Automatic suggestion refresh when graph structure changes (edge additions/deletions)

    Cache Strategy Implementation:
    - SuggestionType-specific cache TTLs: sharedTags (10min), temporalProximity (2min), similarContent (5min)
    - LRU eviction policy with memory pressure detection
    - Cache warming for frequently accessed nodes with predictive pre-loading
    - Invalidation triggers: graph mutations, node updates, user feedback on suggestions

    Performance Optimization:
    - Request coalescing for simultaneous identical requests
    - Background suggestion pre-computation for recently viewed nodes
    - Progressive loading: high-confidence suggestions first, lower-confidence suggestions on demand
    - Suggestion quality feedback loop improving future recommendation accuracy

    Integration Patterns:
    - GraphAnalyticsAdapter integration following Phase 14.4-01 patterns
    - Error handling with automatic fallback to cached suggestions
    - Metrics collection for suggestion effectiveness and user interaction patterns
    - Observer pattern for real-time suggestion updates across components
  </action>
  <verify>grep -E "(ConnectionSuggestionService|SuggestionCache|TTL|batchOptimization)" src/services/ConnectionSuggestionService.ts</verify>
  <done>ConnectionSuggestionService.ts exists with intelligent caching, batch optimization, TTL management, and performance tracking</done>
</task>

<task type="auto">
  <name>Task 2: React Query Cache Service Integration</name>
  <files>src/services/QueryCacheService.ts</files>
  <action>
    Create QueryCacheService.ts as React interface to native QueryCache:

    Cache Service Architecture:
    - QueryCacheService class interfacing with native QueryCache actor
    - CacheEntry interface: data, timestamp, ttl, isValid, timeToExpiry properties
    - CacheStrategy enum: aggressive, balanced, conservative with different TTL policies
    - Bridge communication with native QueryCache following Phase 14.1-14.2 patterns

    Query Cache Operations:
    - async get<T>(key: string): Promise<T | null> with type safety
    - async set<T>(key: string, value: T, ttl?: number): Promise<void>
    - async getOrCompute<T>(key: string, computeFn: () => Promise<T>, ttl?: number): Promise<T>
    - async invalidate(pattern: string): Promise<void> with regex pattern support

    React Integration:
    - Cache warming strategies for frequently accessed graph queries
    - Query deduplication preventing duplicate native bridge calls
    - Automatic cache invalidation on graph structure changes
    - React Suspense integration for seamless loading states

    Performance Integration:
    - Cache effectiveness monitoring with hit/miss ratios
    - Memory usage tracking with automatic cleanup recommendations
    - Query execution time analysis with optimization suggestions
    - Integration with GraphPerformanceMonitor for comprehensive analytics

    Cache Key Management:
    - Intelligent key generation for graph queries with parameter normalization
    - Cache key namespacing: connections, metrics, queries, suggestions
    - Hierarchical invalidation: node-level changes invalidate related queries
    - Cache versioning for schema changes and data migrations
  </action>
  <verify>grep -E "(QueryCacheService|getOrCompute|invalidate|CacheStrategy)" src/services/QueryCacheService.ts</verify>
  <done>QueryCacheService.ts exists with native bridge integration, cache strategies, React integration, and intelligent key management</done>
</task>

<task type="auto">
  <name>Task 3: Graph Performance Monitor and React Hooks</name>
  <files>src/utils/GraphPerformanceMonitor.ts, src/hooks/useGraphAnalytics.ts</files>
  <action>
    Create GraphPerformanceMonitor.ts extending Phase 14.3 performance monitoring:

    Performance Monitoring Architecture:
    - GraphPerformanceMonitor class extending existing d3Performance.ts patterns
    - AnalyticsMetrics interface: suggestionLatency, cacheHitRate, computeTime, memoryUsage
    - OptimizationSuggestion interface: type, description, expectedImprovement, actionRequired
    - Integration with native RenderingPerformanceMonitor for comprehensive tracking

    Graph Analytics Performance Tracking:
    - Connection suggestion performance: computation time, accuracy metrics, user acceptance rates
    - Cache performance: hit rates by query type, memory usage, expiration patterns
    - Bridge communication performance: request latency, throughput, error rates
    - Graph complexity metrics: node count impact, edge density effects on performance

    Optimization Recommendations:
    - Automatic cache TTL adjustment based on graph change frequency
    - Suggestion batch size optimization for memory and performance balance
    - Query pattern analysis with recommendation for pre-computation
    - Real-time performance alerts for degraded analytics performance

    ---

    Create useGraphAnalytics.ts as comprehensive React hook interface:

    Core Hook Implementation:
    - useGraphAnalytics(nodeId?: string): comprehensive graph analytics state management
    - useConnectionSuggestions(nodeId: string, options?: SuggestionOptions): suggestion-specific hook
    - useGraphMetrics(): global graph metrics and performance monitoring

    State Management:
    - Automatic suggestion loading and caching with React state synchronization
    - Real-time updates when graph structure changes via native bridge events
    - Error state management with retry logic and graceful degradation
    - Loading states with progressive enhancement (skeleton → data → optimized)

    Performance Integration:
    - Automatic performance monitoring with user interaction tracking
    - Suggestion effectiveness measurement: click-through rates, acceptance patterns
    - Memory usage optimization with automatic cleanup of unused suggestions
    - Integration with React DevTools for debugging graph analytics state

    Developer Experience:
    - TypeScript integration with complete type safety for all analytics operations
    - React Suspense support for seamless loading experiences
    - Error boundaries integration for robust error handling
    - Development mode debugging with comprehensive analytics state inspection
  </action>
  <verify>grep -E "(GraphPerformanceMonitor|useGraphAnalytics|AnalyticsMetrics|OptimizationSuggestion)" src/utils/GraphPerformanceMonitor.ts src/hooks/useGraphAnalytics.ts</verify>
  <done>GraphPerformanceMonitor.ts and useGraphAnalytics.ts exist with performance tracking, optimization recommendations, and comprehensive React integration</done>
</task>

</tasks>

<verification>
- ConnectionSuggestionService provides intelligent caching with TTL-based invalidation
- QueryCacheService successfully interfaces with native QueryCache actor
- GraphPerformanceMonitor extends Phase 14.3 patterns with graph analytics tracking
- useGraphAnalytics hook provides seamless React integration with TypeScript safety
- Service layer maintains performance standards from Phase 14.1-14.3 (<5ms operations)
- Cache hit rates achieve 90%+ for frequently accessed graph analytics
</verification>

<success_criteria>
- React components access graph analytics through clean hook interfaces with automatic caching
- Connection suggestions load with <100ms latency leveraging intelligent caching strategies
- Query cache provides 90%+ hit rates for frequently accessed graph data
- Performance monitoring identifies bottlenecks with actionable optimization recommendations
- Service layer integrates seamlessly with existing Phase 14.1-14.3 infrastructure
- Memory usage remains optimized through automatic cleanup and cache management
</success_criteria>

<output>
After completion, create `.planning/phases/14.4-graph-integration/14.4-02-SUMMARY.md`
</output>