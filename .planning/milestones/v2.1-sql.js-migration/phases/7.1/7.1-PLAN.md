# Phase 7.1: Native API Bridge Foundation
**Milestone:** v2.1 SQL.js Migration
**Phase:** 7.1 of 3
**Goal:** Replace sql.js database layer with native API calls while maintaining exact same React component interfaces

## Success Criteria
1. React DatabaseContext connects to native API instead of sql.js
2. All existing SQL queries work through API translation layer
3. IndexedDB persistence replaced with native app communication
4. Zero breaking changes to React component layer
5. Performance equals or exceeds sql.js implementation

## Implementation Steps

### Step 1: Native HTTP API Server
Create lightweight HTTP API server in Swift that exposes database operations:

**File:** `native/Sources/Isometry/API/DatabaseAPIServer.swift`
```swift
import Vapor
import GRDB

actor DatabaseAPIServer {
    private let app: Application
    private let database: IsometryDatabase

    init(database: IsometryDatabase) async throws {
        self.database = database
        self.app = try await Application.make(.development)
        await setupRoutes()
    }

    private func setupRoutes() {
        // POST /api/query - Execute SQL query
        app.post("api", "query") { req async throws -> QueryResponse in
            let query = try req.content.decode(QueryRequest.self)
            return try await executeQuery(query)
        }

        // GET /api/cards - Get all cards
        app.get("api", "cards") { req async throws -> [Card] in
            return try await database.getAllCards()
        }

        // POST /api/cards - Create/update card
        app.post("api", "cards") { req async throws -> Card in
            let card = try req.content.decode(Card.self)
            return try await database.saveCard(card)
        }

        // DELETE /api/cards/:id - Delete card
        app.delete("api", "cards", ":id") { req async throws -> HTTPStatus in
            let id = req.parameters.get("id", as: String.self)
            try await database.deleteCard(id: id)
            return .ok
        }
    }
}

struct QueryRequest: Codable {
    let sql: String
    let parameters: [String: DatabaseValue]
}

struct QueryResponse: Codable {
    let rows: [[String: DatabaseValue]]
    let changes: Int?
    let lastInsertRowId: Int64?
}
```

### Step 2: React API Client
Replace sql.js DatabaseContext with native API calls:

**File:** `src/db/NativeAPIContext.tsx`
```typescript
interface NativeAPIClient {
  query: (sql: string, params?: Record<string, any>) => Promise<QueryResult>
  getCards: () => Promise<Card[]>
  saveCard: (card: Partial<Card>) => Promise<Card>
  deleteCard: (id: string) => Promise<void>
}

class NativeAPIClientImpl implements NativeAPIClient {
  private baseUrl = 'http://localhost:8080/api'

  async query(sql: string, params: Record<string, any> = {}): Promise<QueryResult> {
    const response = await fetch(`${this.baseUrl}/query`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ sql, parameters: params })
    })

    if (!response.ok) {
      throw new Error(`API query failed: ${response.statusText}`)
    }

    return response.json()
  }

  async getCards(): Promise<Card[]> {
    const response = await fetch(`${this.baseUrl}/cards`)
    return response.json()
  }

  async saveCard(card: Partial<Card>): Promise<Card> {
    const response = await fetch(`${this.baseUrl}/cards`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(card)
    })
    return response.json()
  }

  async deleteCard(id: string): Promise<void> {
    await fetch(`${this.baseUrl}/cards/${id}`, {
      method: 'DELETE'
    })
  }
}

export const NativeAPIContext = createContext<NativeAPIClient>(
  new NativeAPIClientImpl()
)
```

### Step 3: Query Translation Layer
Create adapter that translates sql.js patterns to native API:

**File:** `src/db/QueryTranslator.ts`
```typescript
export class QueryTranslator {
  private apiClient: NativeAPIClient

  constructor(apiClient: NativeAPIClient) {
    this.apiClient = apiClient
  }

  // Translate sql.js exec calls to native API
  async translateExec(sql: string, params?: any[]): Promise<QueryExecResult[]> {
    const result = await this.apiClient.query(sql, this.arrayToObject(params))

    return [{
      columns: Object.keys(result.rows[0] || {}),
      values: result.rows.map(row => Object.values(row))
    }]
  }

  // Translate sql.js prepare/step pattern
  async translatePreparedQuery(sql: string, params?: Record<string, any>): Promise<any[]> {
    const result = await this.apiClient.query(sql, params)
    return result.rows
  }

  private arrayToObject(params?: any[]): Record<string, any> {
    if (!params) return {}
    return params.reduce((obj, value, index) => {
      obj[`$${index + 1}`] = value
      return obj
    }, {})
  }
}
```

### Step 4: Drop-in Replacement
Update DatabaseContext to use native API while maintaining interface:

**File:** `src/db/DatabaseContext.tsx`
```typescript
export function DatabaseProvider({ children }: { children: React.ReactNode }) {
  const [database, setDatabase] = useState<Database | null>(null)
  const [isLoading, setIsLoading] = useState(true)
  const apiClient = useContext(NativeAPIContext)
  const translator = new QueryTranslator(apiClient)

  useEffect(() => {
    const initDatabase = async () => {
      try {
        // Create sql.js-compatible interface using native API
        const nativeDatabase: Database = {
          exec: translator.translateExec.bind(translator),
          prepare: (sql: string) => ({
            step: () => translator.translatePreparedQuery(sql),
            get: (params: any) => translator.translatePreparedQuery(sql, params),
            reset: () => {},
            free: () => {}
          }),
          close: () => {}
        }

        setDatabase(nativeDatabase)
        setIsLoading(false)
      } catch (error) {
        console.error('Failed to initialize native database API:', error)
        setIsLoading(false)
      }
    }

    initDatabase()
  }, [])

  // Rest of component stays identical - zero breaking changes
  return (
    <DatabaseContext.Provider value={{ database, isLoading }}>
      {children}
    </DatabaseContext.Provider>
  )
}
```

## Integration Points

### Existing Hooks Compatibility
- `useSQLiteQuery` - No changes needed
- `useDatabaseMutation` - No changes needed
- `useCards`, `useNodes`, `useEdges` - No changes needed

### Performance Targets
- Query response time: <100ms (matching current sql.js)
- API server startup: <2s
- Memory overhead: <50MB additional

### Error Handling
- Network failures fallback to cached data
- API server auto-restart on crash
- Clear error messages for debugging

## Testing Strategy

### Unit Tests
- API endpoint functionality
- Query translation accuracy
- Error handling robustness

### Integration Tests
- React components work unchanged
- Data consistency across API boundary
- Performance benchmarks vs sql.js

### Manual Verification
- All existing React views function normally
- No visual regressions in UI
- Database operations complete successfully

## Rollback Plan
- Keep sql.js implementation alongside native API
- Environment flag to switch between implementations
- Automated tests validate both paths work identically

## Next Phase Dependencies
Phase 7.2 requires:
- Working HTTP API server
- Functional query translation layer
- Zero React component breaking changes
- Performance benchmarks proving equivalency